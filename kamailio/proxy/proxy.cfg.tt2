[% IF rsyslog.elasticsearch.enable == "yes" -%]
[% elasticsearch_template='S=$rs SS=\'$rr\' M=$rm R=$ru F=$fu T=$tu IP=$avp(s:ip):$avp(s:port)($si:$sp) UAIP=$si UA=\'$ua\' ID=$ci ' -%]
[% logreq_init=elasticsearch_template -%]
[% logreq=elasticsearch_template -%]
[% logres_init=elasticsearch_template -%]
[% logres=elasticsearch_template -%]
[% ELSE -%]
[% MACRO logreq_init GET kamailio.proxy.log.request_init.join(' ') -%]
[% MACRO logreq GET kamailio.proxy.log.request.join(' ') -%]
[% MACRO logres_init GET kamailio.proxy.log.response_init.join(' ') -%]
[% MACRO logres GET kamailio.proxy.log.response.join(' ') -%]
[% END -%]
[% MACRO debug_dump(type, name) BLOCK -%]
#!ifdef WITH_DEBUG_TEST
xdbg("[% type %] of route [% name %] - $mi $rm\n");
dbg_pv_dump(30, "L_DBG");
#!endif
[% END -%]
[% PROCESS '/usr/lib/ngcp-ngcpcfg/get_hostname'; hostname = out -%]
[% argv.host=hostname; argv.type='sip_int'; PROCESS '/usr/lib/ngcp-ngcpcfg/get_all_shared_ips_for_host'; sip_int_ips = out -%]
[% IF !sip_int_ips.size -%]
[% argv.host=hostname; argv.type='sip_int'; PROCESS '/usr/lib/ngcp-ngcpcfg/get_all_ips_for_host'; sip_int_ips = out -%]
[% END -%]
[% argv.role='lb'; argv.type='sip_ext'; PROCESS '/usr/lib/ngcp-ngcpcfg/get_all_shared_ips'; sip_ext_ips = out -%]
[% IF !sip_ext_ips.size -%]
[% argv.role='lb'; argv.type='sip_ext'; PROCESS '/usr/lib/ngcp-ngcpcfg/get_all_ips'; sip_ext_ips = out -%]
[% END -%]
[% argv.role='lb'; argv.type='sip_int'; PROCESS '/usr/lib/ngcp-ngcpcfg/get_all_shared_ips'; sip_lb_ips = out -%]
[% IF !sip_lb_ips.size -%]
[% argv.role='lb'; argv.type='sip_int'; PROCESS '/usr/lib/ngcp-ngcpcfg/get_all_ips'; sip_lb_ips = out -%]
[% END -%]
[% argv.role='proxy'; argv.type='sip_int'; PROCESS '/usr/lib/ngcp-ngcpcfg/get_all_shared_ips'; sip_proxy_ips = out -%]
[% IF !sip_proxy_ips.size -%]
[% argv.role='proxy'; argv.type='sip_int'; PROCESS '/usr/lib/ngcp-ngcpcfg/get_all_ips'; sip_proxy_ips = out -%]
[% END -%]
#TODO: FLAG_FORWARD, FLAG_EXT_TIMEOUT: vars correctly set?

########################################################################
# Entry route for new request
########################################################################
route[ROUTE_PRX_REQUEST]
{
	[% debug_dump('start', 'ROUTE_PRX_REQUEST') %]



	# agranig: we need this pbx flag for the inital loop over PBX
	# to not use rtpproxy
	$var(from_pbx_initial) = 0;

	$var(proxylu_src) = 0;
	$var(proxylu_dst_caller) = 0;
	$var(proxylu_dst_callee) = 0;
	#!ifdef PROXY_LOOKUP
	route(ROUTE_FIX_PROXYLU_URI);
	#!endif

	if($avp(s:nat) == 1)
	{
		setbflag(FLB_NATB);
	}
	if($avp(s:af) == 6)
	{
		setbflag(FLB_CALLER_IPV6);
 	}

	#!ifdef AUTH_BYE
	if(is_method("BYE"))
	{
		if(!from_any_gw($avp(s:ip), $avp(s:protoid)) && !ds_is_from_list("3") && !ds_is_from_list("5") &&
		   !([% FOREACH ip IN sip_proxy_ips -%]$si == "[% ip %]"[% IF sip_proxy_ips.last != ip -%] || [% END -%][% END -%]))
		{
			route(ROUTE_AUTH);
			#!ifdef ENABLE_AUTHCHECK
			sl_send_reply("101", "Connecting");
			#!endif
		}
	}
	#!endif


	# these need to be avps because we need it in reply/failure-route
	$(avp(s:from_faxserver)[*]) = 0;
	$(avp(s:to_faxserver)[*]) = 0;
	$(avp(s:cf_from_pstn)[*]) = 0;
	$(avp(s:from_pstn)[*]) = 0;
	$(avp(s:proxylu_from_pstn)[*]) = 0;
	$(avp(s:lcr_flags)[*]) = 0;
	$(avp(s:em_call)[*]) = 0;
	$(avp(s:from_pbx)[*]) = 0;
	$(avp(s:p_to_device)[*]) = 0;
	$(avp(s:p_to_group)[*]) = 0;
	$(avp(s:p_from_aa)[*]) = 0;
	$(avp(s:is_primary)[*]) = 0;
	$(avp(s:cf_loop_counter)[*]) = 1;
	$(avp(s:hih_caller_index)[*]) = 0;
	$(avp(s:hih_cause)[*]) = 0;

	# need to initialise variables in failure route as well
	route(ROUTE_INITVARS);

	$(avp(s:first_caller_ipv46_for_rtpproxy)[*]) = $null;

	if(loose_route())
	{
		if(check_route_param("rtpprx=yes"))
		{
			# force rtpproxy
			setbflag(FLB_RTPPROXY);
			add_rr_param(";rtpprx=yes");
			if(is_method("BYE"))
			{
				$var(stop_rtpproxy) = 1;
			}
		}
		else
		{
			# TODO: the resetbflag doesn't actually reset it for a BYE?
			resetbflag(FLB_RTPPROXY);
			$var(stop_rtpproxy) = 0;
		}
		if(!has_totag())
		{
			if($du != $null && is_domain_local("$dd"))
			{
				xlog("L_INFO", "Reset initial local route - [% logreq -%]\n");
				$du = $null;
			}
			else
			{
				xlog("L_NOTICE", "Initial loose-routing rejected - [% logreq -%]\n");
				sl_send_reply("403", "Initial Loose-Routing Forbidden");
				[% debug_dump('exit', 'ROUTE_PRX_REQUEST') %]
				exit;
			}
		}
		else
		{
			record_route();
			# Work around sems-sbc sending a Route header
			# also for non-200 ACK.
			if(is_method("ACK") && $oU == "proxylu_callee")
			{
				xlog("L_INFO", "Trying to consume proxylu ACK - [% logreq -%]\n");
				t_check_trans();

				xlog("L_NOTICE", "Drop misrouted proxylu ACK - [% logreq -%]\n");
				[% debug_dump('exit', 'ROUTE_PRX_REQUEST') %]
				exit;
			}
			else if(is_method("BYE"))
			{
				setflag(FLAG_ACC_FAILED);
				setflag(FLAG_ACC_DB);
				route(ROUTE_STOP_RTPPROXY);
			}
			#!ifdef ENABLE_PBX
			else if(is_method("REFER"))
			{
				$var(refto) = $(hdr(Refer-To){nameaddr.uri}{uri.user});
				if($var(refto) =~ "^\*[% sems.vsc.park_code %]\*.+") 
				{
					$var(orbit) = $(var(refto){s.substr,[% sems.vsc.park_code.length + 2 %],0});
					xlog("L_NOTICE", "Rewrite park request to orbit '$var(orbit)' - [% logreq -%]");
					remove_hf("Refer-To");
					append_hf("Refer-To: sip:callpark@$rd;orbit=$var(orbit)\r\n");
				}
				if(is_present_hf("Referred-By"))
				{
					$(avp(s:tmp)[*]) = $null;
					$(avp(s:tmp_domain)[*]) = $null;
					$(avp(s:caller_uuid)[*]) = $null;
					$var(tmprefby) = $hdr(Referred-By);
					#remove_hf("Referred-By");
					$var(fU) = $(var(tmprefby){nameaddr.uri}{uri.user});
					$var(fd) = $(var(tmprefby){nameaddr.uri}{uri.host});
					xlog("L_INFO", "Use Referred-By URI '$var(fU)@$var(fd)' for attended transfer caller - [% logreq -%]");
					avp_db_query("select uuid, username, domain from subscriber where username='$(var(fU){s.escape.common})' and domain='$(var(fd){s.escape.common})'", "$avp(s:caller_uuid);$avp(s:tmp);$avp(s:tmp_domain)");
					if($avp(s:caller_uuid) != $null)
					{
						# clear transfer initiator's dialogs from the list
						$avp(s:refcid) = $ci;
						avp_subst("$avp(s:refcid)", "/_pbx\-1.*$//"); # remove suffix from callid
						xlog("L_INFO", "Remove dlg list for call-id '$avp(s:refcid)' and caller uuid '$avp(s:caller_uuid)' - [% logreq -%]\n");
						lua_run("pop_dlg_list", "$avp(s:refcid)", "callqueue:$avp(s:caller_uuid)");

						# find the huntgroup the transfer initiator belongs to and clear dialog from the list (for queue tracking)
						avp_db_query("select uuid,username from usr_preferences where attribute='cloud_pbx_hunt_group' and value='sip:$avp(s:tmp)@$avp(s:tmp_domain)'", "$avp(s:caller_hg_uuid);$avp(s:caller_hg_username)");
						while(pv_isset("$(avp(s:caller_hg_uuid)[0])") && pv_isset("$(avp(s:caller_hg_username)[0])"))
						{
							xlog("L_INFO", "Remove dlg list for call-id '$avp(s:refcid)' and huntgroup $avp(s:caller_hg_username) with uuid '$avp(s:caller_hg_uuid)' - [% logreq -%]\n");
							lua_run("pop_dlg_list", "$avp(s:refcid)", "callqueue:$avp(s:caller_hg_uuid)");
							pv_unset("$(avp(s:caller_hg_uuid)[0])");
							pv_unset("$(avp(s:caller_hg_username)[0])");
						}
					}
				}
			}
			if(check_route_param("sca=1") &&
			  (method=="INVITE" || method=="BYE" || method=="PRACK" || method=="REFER"))
			{
				$(avp(s:sca_active)[*]) = 1;
				sca_call_info_update();
			}
			if(check_route_param("colp=.*") &&
			  (method=="INVITE" || method=="ACK" || method=="PRACK" || method=="BYE"))
			{
				$var(tmpcolp) = $(route_uri{uri.param,colp}{s.decode.hexa});
				xlog("L_INFO", "Injecting COLP identity '$var(tmpcolp)' - [% logres -%]\n");
				remove_hf("P-Asserted-Identity");
				append_hf("P-Asserted-Identity: $var(tmpcolp)\r\n");
			}
			#!endif
			if(is_direction("downstream"))
			{
				setflag(FLAG_DOWNSTREAM);
			}
			else
			{
				setflag(FLAG_UPSTREAM);
			}
			if(sdp_content() && isbflagset(FLB_RTPPROXY))
			{
				route(ROUTE_RESTORE_CLUSTERSET);

				if(isflagset(FLAG_DOWNSTREAM))
				{ #same direction as original dialog-forming request

					xlog("L_INFO", "Not switching caller did and callee did for downstream in-dialog, caller did is '$avp(s:lbrtp_dispatcher_id_caller)' and callee did is '$avp(s:lbrtp_dispatcher_id_callee)' - [% logreq -%]\n");

					if(check_route_param("ice_callee=replace"))
					{
						xlog("L_INFO", "Replace existing ICE candidates (if any) for callee with mediaproxy ICE canditate - [% logreq -%]\n");
						$var(ice_flags) = "ICE=force ";
						add_rr_param(";ice_callee=replace");
						setbflag(FLB_ICE_CALLEE_REPLACE);
					}
					else if(check_route_param("ice_callee=strip"))
					{
						xlog("L_INFO", "Remove existing ICE candidates (if any) for callee - [% logreq -%]\n");
						$var(ice_flags) = "ICE=remove ";
						add_rr_param(";ice_callee=strip");
						setbflag(FLB_ICE_CALLEE_STRIP);
					}
					else if(check_route_param("ice_callee=add"))
					{
						xlog("L_INFO", "Add mediaproxy as ICE candidate for callee - [% logreq -%]\n");
						add_rr_param(";ice_callee=add");
						setbflag(FLB_ICE_CALLEE_ADD);
					}
					# Set caller flags for use in onreply_route later
					if(check_route_param("ice_caller=replace"))
					{
						add_rr_param(";ice_caller=replace");
						setbflag(FLB_ICE_CALLER_REPLACE);
					}
					else if(check_route_param("ice_caller=strip"))
					{
						add_rr_param(";ice_caller=strip");
						setbflag(FLB_ICE_CALLER_STRIP);
					}
					else if(check_route_param("ice_caller=add"))
					{
						add_rr_param(";ice_caller=add");
						setbflag(FLB_ICE_CALLER_ADD);
					}
				}
				else if(isflagset(FLAG_UPSTREAM))
				{ #opposite direction to original dialog-forming request

					# switch dispatcher ids for reverse re-invite
					$var(tmpdid) = $avp(s:lbrtp_dispatcher_id_caller);
					$(avp(s:lbrtp_dispatcher_id_caller)[*]) = $avp(s:lbrtp_dispatcher_id_callee);
					$(avp(s:lbrtp_dispatcher_id_callee)[*]) = $var(tmpdid);
					xlog("L_INFO", "Switching caller did and callee did for upstream in-dialog, caller did is '$avp(s:lbrtp_dispatcher_id_caller)' and callee did is '$avp(s:lbrtp_dispatcher_id_callee)' - [% logreq -%]\n");

					if(check_route_param("ice_caller=replace"))
					{
						xlog("L_INFO", "Replace existing ICE candidates (if any) for caller with mediaproxy ICE canditate - [% logreq -%]\n");
						$var(ice_flags) = "ICE=force ";
						add_rr_param(";ice_caller=replace");
						setbflag(FLB_ICE_CALLER_REPLACE);
					}
					else if(check_route_param("ice_caller=strip"))
					{
						xlog("L_INFO", "Remove existing ICE candidates (if any) for caller - [% logreq -%]\n");
						$var(ice_flags) = "ICE=remove ";
						add_rr_param(";ice_caller=strip");
						setbflag(FLB_ICE_CALLER_STRIP);
					}
					else if(check_route_param("ice_caller=add"))
					{
						xlog("L_INFO", "Add mediaproxy as ICE candidate for caller - [% logreq -%]\n");
						add_rr_param(";ice_caller=add");
						setbflag(FLB_ICE_CALLER_ADD);
					}
					# Set callee flags for use in onreply_route later
					if(check_route_param("ice_callee=replace"))
					{
						add_rr_param(";ice_callee=replace");
						setbflag(FLB_ICE_CALLEE_REPLACE);
					}
					else if(check_route_param("ice_callee=strip"))
					{
						add_rr_param(";ice_callee=strip");
						setbflag(FLB_ICE_CALLEE_STRIP);
					}
					else if(check_route_param("ice_callee=add"))
					{
						add_rr_param(";ice_callee=add");
						setbflag(FLB_ICE_CALLEE_ADD);
					}
				}
				if(is_method("ACK"))
				{
					xlog("L_INFO", "Force mediaproxy lookup for forward direction - [% logreq -%]\n");
					$var(rtpp_flags) = "replace-origin replace-session-connection rtcp-mux-demux ";
					if($var(ice_flags) != '')
					{
						$var(rtpp_flags) = $var(rtpp_flags) + $var(ice_flags);
					}
					if($avp(s:lbrtp_dispatcher_id_caller) == $avp(s:lbrtp_dispatcher_id_callee))
					{
						set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})");
						add_rr_param(";aset=$avp(s:lbrtp_dispatcher_id_caller)");
					}
					else
					{
						set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})", "$(avp(s:lbrtp_dispatcher_id_callee){s.int})");
						add_rr_param(";aset=$avp(s:lbrtp_dispatcher_id_caller)");
						add_rr_param(";bset=$avp(s:lbrtp_dispatcher_id_callee)");
					}
					rtpengine_answer($var(rtpp_flags));
				}
				else
				{
					# always force an rtpproxy lookup in reply for a
					# loose-routed request, even for ack, because there
					# is no reply for that anyways
					setbflag(FLB_RTPPROXY_LOOKUP);

					$var(rtpp_flags) = "replace-origin replace-session-connection rtcp-mux-demux ";
					if($var(ice_flags) != '')
					{
						$var(rtpp_flags) = $var(rtpp_flags) + $var(ice_flags);
					}
					xlog("L_INFO", "Engage rtpengine for in-dialog request, caller did is '$avp(s:lbrtp_dispatcher_id_caller)' and callee did is '$avp(s:lbrtp_dispatcher_id_callee)' - [% logreq -%]\n");
					if($avp(s:lbrtp_dispatcher_id_caller) == $avp(s:lbrtp_dispatcher_id_callee))
					{
						set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})");
						add_rr_param(";aset=$avp(s:lbrtp_dispatcher_id_caller)");
					}
					else
					{
						set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})", "$(avp(s:lbrtp_dispatcher_id_callee){s.int})");
						add_rr_param(";aset=$avp(s:lbrtp_dispatcher_id_caller)");
						add_rr_param(";bset=$avp(s:lbrtp_dispatcher_id_callee)");
					}
					rtpengine_offer($var(rtpp_flags));
 				}
			}

			$var(loose_routed) = 1;
			route(ROUTE_OUTBOUND);
		}
	}

	if(is_method("CANCEL|ACK"))
	{
		route(ROUTE_LOCAL);
	}

	if($fu == "sip:faxserver@sipwise.local" && ds_is_from_list("2"))
	{
		$var(sendfax) = 1;
	}

	if(is_method("INVITE"))
	{
		route(ROUTE_INVITE);
	}
	[% debug_dump('exit', 'ROUTE_PRX_REQUEST') %]
	exit;
}

########################################################################
# Route for variable initialization that should be re-used
########################################################################
route[ROUTE_INITVARS]
{
	[% debug_dump('start', 'ROUTE_INITVARS') %]
	$var(allow_peer) = 0;
	$var(loose_routed) = 0;
	$var(no_acc) = 0;
	$var(no_auth) = 0;
	$var(forward) = 0;
	$var(redirected_forward) = 0;
	$var(external_domain) = 0;
	$var(ext_timeout) = 0;
	$var(from_trusted) = 0;
	$var(to_pstn) = 0;
	$var(dpid) = 0;
	$var(reset_acc_callee) = 0;
	$var(no_sbc) = 0;
	$var(sendfax) = 0;
	$var(from_local_endpoint) = 0;
	$var(to_local_endpoint) = 0;
	$var(cf_loop) = 0;
	$var(rtpp_flags) = '';
	$var(ice_flags) = '';
	$var(foreign_dom) = 0;
	$var(to_pbx) = 0;
	$var(blind_transfer) = 0;
	$var(referrer_callee_in_dpid) = 0;
	$var(pbx_app_name) = 0;
	$var(proxylu_uuid) = 0;
	$var(caller_info_added) = 0;
	$var(callee_info_added) = 0;
	$var(caller_account_id) = 0;
	$var(caller_ext_subscriber_id) = '';
	$var(caller_ext_contract_id) = '';
	$var(callee_account_id) = 0;
	$var(callee_ext_subscriber_id) = '';
	$var(callee_ext_contract_id) = '';
	$var(rgroup_uris) = 0;
	$var(is_replaces) = 0;
	$var(callee_is_hwfax) = 0;
	$var(block_override) = 0;
	$var(adm_block_override) = 0;
	$var(contract_block_override) = 0;
	$var(contract_adm_block_override) = 0;
	$var(forced_outbound_call_to_peer) = 0;

	# for BYE, mark whether or not to stop rtproxy
	$var(stop_rtpproxy) = 0;

	# agranig: we need this pbx flag for the inital loop over PBX
	# to not use rtpproxy
	$var(from_pbx_initial) = 0;

	$var(proxylu_src) = 0;
	$var(proxylu_dst_caller) = 0;
	$var(proxylu_dst_callee) = 0;
	$var(hunt_failure) = 0;
	$var(hih_user) = 0;
	$var(new_hih_user) = 0;
	$var(count_dlg) = 0;
	$var(cloud_pbx_hg_members) = 0;
	$var(from_push_server) = 0;
	$var(group_uuid) = 0;

	$var(announce_handle) = "";
	$var(announce_set) = 0;

	# set defaults for calls to or from voicebox, faxserver etc which have no prefs
	# for calls to real user or peer these will be cleared before loading the prefs
	# so we still need the defaults for real user and peer in the prefs.lua script
	$(avp(s:lbrtp_dispatcher_id_caller)[*]) = [% cluster_sets.${cluster_sets.default_set}.dispatcher_id %];
	$(avp(s:lbrtp_dispatcher_id_callee)[*]) = [% cluster_sets.${cluster_sets.default_set}.dispatcher_id %];
	[% debug_dump('end', 'ROUTE_INITVARS') %]
}

########################################################################
# Request route 'clear-peer-preferences-caller'
########################################################################
route[ROUTE_CLEAR_PEER_OUT_PREF]
{
	[% debug_dump('start', 'ROUTE_CLEAR_PEER_OUT_PREF') %]
	xlog("L_INFO", "Clean peer preferences for callee - [% logreq -%]\n");
	if (!lua_run("ngcp_clean", "callee", "peer")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_CLEAR_PEER_OUT_PREF') %]
		exit;
	}
	[% debug_dump('end', 'ROUTE_CLEAR_PEER_OUT_PREF') %]
}

########################################################################
# Request route 'load-peer-preferences-caller'
########################################################################
route[ROUTE_LOAD_PEER_OUT_PREF]
{
	[% debug_dump('start', 'ROUTE_LOAD_PEER_OUT_PREF') %]
	xlog("L_INFO", "Load peer preferences for peer host '$avp(s:lcr_flags)' - [% logreq -%]\n");
	if (!lua_run("ngcp_callee_peer_load", "$avp(s:lcr_flags)")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_LOAD_PEER_OUT_PREF') %]
		exit;
	}
	$(avp(s:lbrtp_dispatcher_id_callee)[*]) = $xavp(callee_peer_prefs[0]=>lbrtp_set);
	xlog("L_INFO", "Use lb/rtp set id '$avp(s:lbrtp_dispatcher_id_callee)' for call to peer - [% logreq -%]\n");

	xlog("L_INFO", "Load dialplan IDs for peer host '$avp(s:lcr_flags)' - [% logreq -%]\n");
	xlog("L_INFO", "Fetched dialplan IDs caller_out='$xavp(callee_peer_prefs[0]=>rewrite_caller_out_dpid)', callee_out='$xavp(callee_peer_prefs[0]=>rewrite_callee_out_dpid)' - [% logreq -%]\n");

	xlog("L_INFO", "Load route set for peer host '$avp(s:lcr_flags)' - [% logreq -%]\n");
	$(avp(s:peer_out_route)[*]) = $null;
	avp_db_query("select via_route from provisioning.voip_peer_hosts where id=$avp(s:lcr_flags)", "$avp(s:peer_out_route)");
	if(pv_isset("$avp(s:peer_out_route)"))
	{
		xlog("L_INFO", "Setting outbound route set to '$avp(s:peer_out_route)' - [% logreq -%]\n");
	}
	else
	{
		xlog("L_INFO", "No outbound route set for this peer found - [% logreq -%]\n");
	}

	[% debug_dump('end', 'ROUTE_LOAD_PEER_OUT_PREF') %]
}


########################################################################
# Request route 'clear-peer-preferences-callee'
########################################################################
route[ROUTE_CLEAR_PEER_IN_PREF]
{
	[% debug_dump('start', 'ROUTE_CLEAR_PEER_IN_PREF') %]
	xlog("L_INFO", "Clean peer preferences for caller - [% logreq -%]\n");
	if (!lua_run("ngcp_clean", "caller", "peer")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_CLEAR_PEER_IN_PREF') %]
		exit;
	}
	$(avp(s:caller_ip_val)[*]) = $null;
	[% debug_dump('end', 'ROUTE_CLEAR_PEER_IN_PREF') %]
}

########################################################################
# Request route 'load-peer-preferences-caller'
########################################################################
route[ROUTE_LOAD_PEER_IN_PREF]
{
	[% debug_dump('start', 'ROUTE_LOAD_PEER_IN_PREF') %]
	xlog("L_INFO", "Load peer preferences for peer host '$avp(s:lcr_flags)' - [% logreq -%]\n");
	if (!lua_run("ngcp_caller_peer_load", "$avp(s:lcr_flags)")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_LOAD_PEER_IN_PREF') %]
		exit;
	}

	$(avp(s:lbrtp_dispatcher_id_caller)[*]) = $xavp(caller_peer_prefs[0]=>lbrtp_set);
	xlog("L_INFO", "Use lb/rtp set id '$avp(s:lbrtp_dispatcher_id_caller)' for call from peer - [% logreq -%]\n");

	xlog("L_INFO", "Load dialplan IDs for peer host '$avp(s:lcr_flags)' - [% logreq -%]\n");
	xlog("L_INFO", "Fetched dialplan IDs caller_in='$xavp(caller_peer_prefs[0]=>rewrite_caller_in_dpid)', callee_in='$xavp(caller_peer_prefs[0]=>rewrite_callee_in_dpid)' - [% logreq -%]\n");

	if($avp(s:first_caller_ipv46_for_rtpproxy) == $null)
	{
		$(avp(s:first_caller_ipv46_for_rtpproxy)[*]) = $xavp(caller_peer_prefs[0]=>ipv46_for_rtpproxy);
	}
	if(!pv_isset("$avp(s:first_caller_use_rtpproxy)"))
	{
		$(avp(s:first_caller_use_rtpproxy)[*]) = $xavp(caller_peer_prefs[0]=>use_rtpproxy);
	}
	if(!pv_isset("$avp(s:first_caller_transport_protocol)"))
	{
		$(avp(s:first_caller_transport_protocol)[*]) = $xavp(caller_peer_prefs[0]=>transport_protocol);
	}

	if($avp(s:caller_ip_val) == $null)
	{
		if(pv_isset("$xavp(caller_peer_prefs[0]=>ip_header)") && $hdr($xavp(caller_peer_prefs[0]=>ip_header)) != $null)
		{
			xlog("L_INFO", "Use '$xavp(caller_peer_prefs[0]=>ip_header)' for CDR IP - [% logreq -%]\n");
			$(avp(s:caller_ip_val)[*]) = $hdr($xavp(caller_peer_prefs[0]=>ip_header));
		}
		else if($hdr(P-NGCP-Src-Ip) != $null)
		{
			xlog("L_INFO", "CDR IP header '$xavp(caller_peer_prefs[0]=>ip_header)' not found, use 'P-NGCP-Src-Ip' - [% logreq -%]\n");
			$(avp(s:caller_ip_val)[*]) = $hdr(P-NGCP-Src-Ip);
		}
		else
		{
			xlog("L_INFO", "CDR IP header '$xavp(caller_peer_prefs[0]=>ip_header)' and 'P-NGCP-Src-Ip' not found, use received IP - [% logreq -%]\n");
			$(avp(s:caller_ip_val)[*]) = $si;
		}
	}
	if($avp(s:first_caller_ua_header_mode) == $null)
	{
		$avp(s:first_caller_ua_header_mode) = $xavp(caller_peer_prefs[0]=>ua_header_mode);	
	}
	if($avp(s:first_caller_ua_header_replace) == $null)
	{
		$avp(s:first_caller_ua_header_replace) = $xavp(caller_peer_prefs[0]=>ua_header_replace);	
	}
	#Dialog handling for incoming pstn call
	dlg_manage();
	if (!lua_run("set_dlg_profile", "$ci", "total"))
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_LOAD_PEER_IN_PREF') %]
		exit;
	}
 	xlog("L_INFO", "Dialog set mark total - [% logreq -%]\n");
	if(!lua_run("set_dlg_profile", "$ci", "peer:$avp(s:lcr_flags)"))
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_LOAD_PEER_IN_PREF') %]
		exit;
	}
 	xlog("L_INFO", "Dialog set mark peer to '$avp(s:lcr_flags)' - [% logreq -%]\n");
	[% debug_dump('end', 'ROUTE_LOAD_PEER_IN_PREF') %]
}


########################################################################
# Request route 'clear-callee-dom-preferences-caller'
########################################################################
route[ROUTE_CLEAR_CALLEE_DOMAIN_PREF]
{
	[% debug_dump('start', 'ROUTE_CLEAR_CALLEE_DOMAIN_PREF') %]
	xlog("L_INFO", "Clean domain preferences for callee - [% logreq -%]\n");
	if (!lua_run("ngcp_clean", "callee", "dom")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_CLEAR_CALLEE_DOMAIN_PREF') %]
		exit;
	}

	[% debug_dump('end', 'ROUTE_CLEAR_CALLEE_DOMAIN_PREF') %]
}

########################################################################
# Request route 'load-callee-dom-preferences-caller'
########################################################################
route[ROUTE_LOAD_CALLEE_DOMAIN_PREF]
{
	[% debug_dump('start', 'ROUTE_LOAD_CALLEE_DOMAIN_PREF') %]
	xlog("L_INFO", "Load domain preferences for callee - [% logreq -%]\n");
	if (!lua_run("ngcp_callee_usr_load", "", "$rd")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_DOMAIN_PREF') %]
		exit;
	}

	# we only load this specific dom-pref here because
	# we need it for authentication.
	$(avp(s:callee_dom_unauth_in)[*]) = $xavp(callee_dom_prefs=>unauth_inbound_calls);
	route(ROUTE_CLEAR_CALLEE_DOMAIN_PREF);
	[% debug_dump('end', 'ROUTE_LOAD_CALLEE_DOMAIN_PREF') %]
}

########################################################################
# Request route 'clear-usr-preferences-caller'
########################################################################
route[ROUTE_CLEAR_CALLER_PREF]
{
	[% debug_dump('start', 'ROUTE_CLEAR_CALLER_PREF') %]
	xlog("L_INFO", "Clear caller preferences - [% logreq -%]\n");
	if (!lua_run("ngcp_clean", "caller", "usr")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_CLEAR_CALLER_PREF') %]
		exit;
	}
	if (!lua_run("ngcp_clean", "caller", "contract")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_CLEAR_CALLER_PREF') %]
		exit;
	}

	$(avp(s:caller_cli_netprov)[*]) = $null;
	$(avp(s:caller_ip_val)[*]) = $null;
	[% debug_dump('end', 'ROUTE_CLEAR_CALLER_PREF') %]
}

########################################################################
# Request route 'clear-usr-preferences-callee'
########################################################################
route[ROUTE_CLEAR_CALLEE_PREF]
{
	[% debug_dump('start', 'ROUTE_CLEAR_CALLEE_PREF') %]
	xlog("L_INFO", "Clear callee preferences - [% logreq -%]\n");
	if (!lua_run("ngcp_clean", "callee", "usr")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_CLEAR_CALLEE_PREF') %]
		exit;
	}
	if (!lua_run("ngcp_clean", "callee", "contract")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_CLEAR_CALLEE_PREF') %]
		exit;
	}

	$(avp(s:callee_fr_inv_timer)[*]) = $null;
	t_reset_fr();
	[% debug_dump('end', 'ROUTE_CLEAR_CALLEE_PREF') %]
}

########################################################################
# Request route 'usr-preferences-caller'
########################################################################
route[ROUTE_LOAD_CALLER_PREF]
{
	[% debug_dump('start', 'ROUTE_LOAD_CALLER_PREF') %]
	route(ROUTE_CLEAR_CALLER_PREF);

	$var(pref_domain) = 0;
	if($var(forward) == 1 || $var(cf_loop) == 1 || $avp(s:from_faxserver) == 1 || $avp(s:from_pbx) == 1)
	{
		$var(pref_domain) = $avp(s:acc_caller_domain);
	}
	else
	{
		if ($var(from_trusted) == 1 && $avp(s:caller_domain) == $null)
		{
			$var(pref_domain) = $fd;
		}
		else
		{
			$var(pref_domain) = $avp(s:caller_domain);
		}
	}

	xlog("L_INFO", "Load caller preferences for uuid '$avp(s:caller_uuid)' and domain '$var(pref_domain)' - [% logreq -%]\n");
	if (!lua_run("ngcp_caller_usr_load", "$avp(s:caller_uuid)", "$var(pref_domain)")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_LOAD_CALLER_PREF') %]
		exit;
	}

	$var(caller_account_id) = $xavp(caller_real_prefs[0]=>account_id);

	if($var(caller_account_id) != 0)
	{
		xlog("L_INFO", "Load caller contract preferences for contract id '$var(caller_account_id)' - [% logreq -%]\n");
		if (!lua_run("ngcp_caller_contract_load", "$var(caller_account_id)")) 
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_LOAD_CALLER_PREF') %]
			exit;
		}
	}

	$var(caller_ext_subscriber_id) = $xavp(caller_real_prefs[0]=>ext_subscriber_id);
	$var(caller_ext_contract_id) = $xavp(caller_real_prefs[0]=>ext_contract_id);

	# we preserve avps for those prefs, as they are being used in rewrite rules:
	$(avp(s:caller_ac)[*]) = $xavp(caller_real_prefs[0]=>ac);
	$(avp(s:caller_cc)[*]) = $xavp(caller_real_prefs[0]=>cc);
	$(avp(s:caller_cloud_pbx_base_cli)[*]) = $xavp(caller_real_prefs[0]=>cloud_pbx_base_cli);
	$(avp(s:caller_cloud_pbx_ext)[*]) = $xavp(caller_real_prefs[0]=>cloud_pbx_ext);
	$(avp(s:caller_emergency_prefix)[*]) = $xavp(caller_real_prefs[0]=>emergency_prefix);
	$(avp(s:caller_emergency_suffix)[*]) = $xavp(caller_real_prefs[0]=>emergency_suffix);
	$(avp(s:caller_emergency_cli)[*]) = $xavp(caller_real_prefs[0]=>emergency_cli);

	#!ifdef ENABLE_PBX
	pv_unset("$(avp(s:caller_cloud_pbx_account_cli_list)[*])");
	if(pv_isset("$xavp(caller_real_prefs[0]=>cloud_pbx)"))
	{
		avp_db_query("select vda.username from provisioning.voip_dbaliases vda left join provisioning.voip_subscribers vs on vda.subscriber_id = vs.id where vs.account_id = $xavp(caller_real_prefs[0]=>account_id)", "$avp(s:caller_cloud_pbx_account_cli_list)");
		if($avp(s:from_pbx) != 1)
		{
			# find the huntgroup the caller belongs to
			# and add it to the list (for queue tracking)
			avp_db_query("select uuid,username from usr_preferences where attribute='cloud_pbx_hunt_group' and value='sip:$avp(s:acc_caller_user)@$avp(s:acc_caller_domain)'", "$avp(s:caller_hg_uuid);$avp(s:caller_hg_username)");
			while(pv_isset("$avp(s:caller_hg_uuid)[0]"))
			{
				xlog("L_INFO", "Set caller dlg list for a member of huntgroup $avp(s:caller_hg_username) with uuid '$avp(s:caller_hg_uuid)' - [% logreq -%]\n");
				lua_run("add_dlg_list", "$ci", "callqueue:$avp(s:caller_hg_uuid)");
				pv_unset("$avp(s:caller_hg_uuid)[0]");
			}
		}
	}
	if(pv_isset("$xavp(caller_real_prefs[0]=>cloud_pbx)") && $xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
	  !pv_isset("$avp(s:first_caller_pbx_account_id)")) 
	{
		$(avp(s:first_caller_pbx_account_id)[*]) = $xavp(caller_real_prefs[0]=>account_id);
	}
	#!endif

	if(pv_isset("$xavp(caller_real_prefs[0]=>cli)"))
	{
		$(avp(s:caller_cli_netprov)[*]) = $xavp(caller_real_prefs[0]=>cli);
	}
	else
	{
		$(avp(s:caller_cli_netprov)[*]) = $fU;
	}
	if($var(cf_loop) == 1)
	{
		# We don't have caller_domain after CF loop and don't want to use $fd of original INVITE
		$(avp(s:caller_domain_netprov)[*]) = $avp(s:acc_caller_domain);
	}
	else if($avp(s:caller_domain) == $null)
	{
		# call from trusted IP
		$(avp(s:caller_domain_netprov)[*]) = $fd;
	}
	else
	{
		$(avp(s:caller_domain_netprov)[*]) = $avp(s:caller_domain);
	}

	# use network-provided domain for accounting. when coming from cf loop, it's already set correctly
	if($var(cf_loop) != 1)
	{
		$(avp(s:acc_caller_domain)[*]) = $(avp(s:caller_domain_netprov)[*]);
	}

	#!ifdef ENABLE_FRITZBOX_NUMBERS
	# TODO: set this in a config
	$var(fritz_prefix_pattern)= "0" + $avp(s:caller_ac);
[% FOREACH code IN kamailio.proxy.fritzbox.prefixes -%]
[% IF code -%]
	$var(fritzcode) = "^sip:" + $var(fritz_prefix_pattern) + "[% code %]@";
	if($ru =~ $var(fritzcode))
	{
		$var(fritzcode)= $rU;
		$rU=$(var(fritzcode){s.replace,$var(fritz_prefix_pattern),});
		xlog("L_NOTICE", "FritzBox prefix detected! ruri changes to $ru - [% logreq -%]\n");
	}
[% END -%]
[% END -%]
	$var(fritzcode) = "^" + $var(fritz_prefix_pattern) + "[% sems.vsc.voicemail_number %]$";
	if($rU =~ $var(fritzcode))
	{
		$rU="[% sems.vsc.voicemail_number %]";
		xlog("L_NOTICE", "FritzBox Voicemail call detected! ruri changes to $ru - [% logreq -%]\n");
	}
	#!endif

	if($avp(s:caller_clir) != 1 && !(pv_isset("$avp(s:caller_clir)") && $avp(s:from_pbx) == 1))
	{
		$(avp(s:caller_clir)[*]) = $xavp(caller_real_prefs[0]=>clir);
	}

	# only do ipv4/ipv6 rtpproxy checks for the initial caller,
	# since this will be the one handling the SDP of the reply
	if($avp(s:first_caller_ipv46_for_rtpproxy) == $null)
	{
		if(pv_isset("$xavp(caller_real_prefs[0]=>ipv46_for_rtpproxy)"))
		{
			$(avp(s:first_caller_ipv46_for_rtpproxy)[*]) = $xavp(caller_real_prefs[0]=>ipv46_for_rtpproxy);
		}
	}

	if($avp(s:first_caller_use_rtpproxy) == $null)
	{
		$(avp(s:first_caller_use_rtpproxy)[*]) = $xavp(caller_real_prefs[0]=>use_rtpproxy);
	}
	if(!pv_isset("$avp(s:first_caller_transport_protocol)"))
	{
		$(avp(s:first_caller_transport_protocol)[*]) = $xavp(caller_real_prefs[0]=>transport_protocol);
	}

	$(avp(s:lbrtp_dispatcher_id_caller)[*]) = $xavp(caller_real_prefs[0]=>lbrtp_set);
	xlog("L_INFO", "Use lb/rtp set id '$avp(s:lbrtp_dispatcher_id_caller)' for local caller - [% logreq -%]\n");

	xlog("L_INFO", "Fetched dialplan IDs caller_in='$xavp(caller_real_prefs[0]=>rewrite_caller_in_dpid)', callee_in='$xavp(caller_real_prefs[0]=>rewrite_callee_in_dpid)' - [% logreq -%]\n");

	if($avp(s:caller_ip_val) == $null)
	{
		if(pv_isset("$xavp(caller_real_prefs[0]=>ip_header)") && $hdr($xavp(caller_real_prefs[0]=>ip_header)) != $null)
		{
			xlog("L_INFO", "Use '$xavp(caller_real_prefs[0]=>ip_header)' for CDR IP - [% logreq -%]\n");
			$(avp(s:caller_ip_val)[*]) = $hdr($xavp(caller_real_prefs[0]=>ip_header));
		}
		else if($hdr(P-NGCP-Src-Ip) != $null)
		{
			xlog("L_INFO", "CDR IP header '$xavp(caller_real_prefs[0]=>ip_header)' not found, use 'P-NGCP-Src-Ip' - [% logreq -%]\n");
			$(avp(s:caller_ip_val)[*]) = $hdr(P-NGCP-Src-Ip);
		}
		else
		{
			xlog("L_INFO", "CDR IP header '$xavp(caller_real_prefs[0]=>ip_header)' and 'P-NGCP-Src-Ip' not found, use received IP - [% logreq -%]\n");
			$(avp(s:caller_ip_val)[*]) = $si;
		}
	}
	if($avp(s:first_caller_ua_header_mode) == $null)
	{
		$(avp(s:first_caller_ua_header_mode)[*]) = $xavp(caller_real_prefs[0]=>ua_header_mode);	
	}
	if($avp(s:first_caller_ua_header_replace) == $null)
	{
		$(avp(s:first_caller_ua_header_replace)[*]) = $xavp(caller_real_prefs[0]=>ua_header_replace);	
	}

	if(!(is_domain_local("$rd") || $rd =~ "^.+\.local$" || $var(is_replaces) == 1))
	{
		if($xavp(caller_real_prefs[0]=>allow_out_foreign_domain) == 1)
		{
			xlog("L_WARN", "Allow call to foreign domain by preference - [% logreq -%]\n");
			$var(foreign_dom) = 1;
		}
		else
		{
			xlog("L_WARN", "Reject call to foreign domain - [% logreq -%]\n");
			route(ROUTE_ADD_CALLINFO_REPLY);
			t_newtran();
			t_reply("403", "Call to foreign domain rejected");
			[% debug_dump('exit', 'ROUTE_LOAD_CALLER_PREF') %]
			exit;
		}
	}


	#!ifdef ENABLE_VSC
	if(uri =~ "^sip:\*[% sems.vsc.block_override_code %]\*")
	{
		$var(ov_len) = 0;
		$var(adm_ov_len) = 0;
		$var(contract_ov_len) = 0;
		$var(contract_adm_ov_len) = 0;
		strip([% sems.vsc.block_override_code.length + 2 %]);
		if(pv_isset("$xavp(caller_contract_prefs[0]=>block_out_override_pin)"))
		{
			$var(contract_ov_len) = $(xavp(caller_contract_prefs[0]=>block_out_override_pin){s.len});
			$var(pin) = $(rU{s.substr, 0, $var(contract_ov_len)});
			if($xavp(caller_contract_prefs[0]=>block_out_override_pin) == $var(pin))
			{
				xlog("L_NOTICE", "Contract Block override PIN '$xavp(caller_contract_prefs[0]=>block_out_override_pin)' accepted - [% logreq -%]\n");
				$var(contract_block_override) = 1;
			}
			else
			{
				xlog("L_NOTICE", "Contract Block override PIN '$var(pin)' does not match '$xavp(caller_contract_prefs[0]=>block_out_override_pin)', rejected - [% logreq -%]\n");
			}
		}
		if(pv_isset("$xavp(caller_real_prefs[0]=>block_out_override_pin)"))
		{
			$var(ov_len) = $(xavp(caller_real_prefs[0]=>block_out_override_pin){s.len});
			$var(pin) = $(rU{s.substr, 0, $var(ov_len)});
			if($xavp(caller_real_prefs[0]=>block_out_override_pin) == $var(pin))
			{
				xlog("L_NOTICE", "Block override PIN '$xavp(caller_real_prefs[0]=>block_out_override_pin)' accepted - [% logreq -%]\n");
				$var(block_override) = 1;
			}
			else
			{
				xlog("L_NOTICE", "Block override PIN '$var(pin)' does not match '$xavp(caller_real_prefs[0]=>block_out_override_pin)', rejected - [% logreq -%]\n");
			}
		}
		if(pv_isset("$xavp(caller_contract_prefs[0]=>adm_block_out_override_pin)"))
		{
			$var(contract_adm_ov_len) = $(xavp(caller_contract_prefs[0]=>adm_block_out_override_pin){s.len});
			$var(pin) = $(rU{s.substr, 0, $var(contract_adm_ov_len)});
			if($xavp(caller_contract_prefs[0]=>adm_block_out_override_pin) == $var(pin))
			{
				xlog("L_NOTICE", "Admin Contract Block override PIN '$xavp(caller_contract_prefs[0]=>adm_block_out_override_pin)' accepted - [% logreq -%]\n");
				$var(contract_adm_block_override) = 1;
			}
			else
			{
				xlog("L_NOTICE", "Admin Contract Block override PIN '$var(pin)' does not match '$xavp(caller_contract_prefs[0]=>adm_block_out_override_pin)', rejected - [% logreq -%]\n");
			}
		}
		if(pv_isset("$xavp(caller_real_prefs[0]=>adm_block_out_override_pin)"))
		{
			$var(adm_ov_len) = $(xavp(caller_real_prefs[0]=>adm_block_out_override_pin){s.len});
			$var(pin) = $(rU{s.substr, 0, $var(adm_ov_len)});
			if($xavp(caller_real_prefs[0]=>adm_block_out_override_pin) == $var(pin))
			{
				xlog("L_NOTICE", "Administrative Block override PIN '$xavp(caller_real_prefs[0]=>adm_block_out_override_pin)' accepted - [% logreq -%]\n");
				$var(adm_block_override) = 1;
				$var(block_override) = 1;
			}
			else
			{
				xlog("L_NOTICE", "Administrative Block override PIN '$var(pin)' does not match '$xavp(caller_real_prefs[0]=>adm_block_out_override_pin)', rejected - [% logreq -%]\n");
			}
		}
		if($var(contract_adm_block_override) == 1)
		{
			$rU = $(rU{s.substr, $var(contract_adm_ov_len), 0});
		}
		else if($var(adm_block_override) == 1)
		{
			$rU = $(rU{s.substr, $var(adm_ov_len), 0});
		}
		else if($var(contract_block_override) == 1)
		{
			$rU = $(rU{s.substr, $var(contract_ov_len), 0});
		}
		else if($var(block_override) == 1)
		{
			$rU = $(rU{s.substr, $var(ov_len), 0});
		}
		else
		{
			xlog("L_NOTICE", "Reject PIN override attempt, contract_block_override='$xavp(caller_contract_prefs[0]=>block_out_override_pin)', contract_adm_block_override='$xavp(caller_contract_prefs[0]=>adm_block_out_override_pin)', block_override='$xavp(caller_real_prefs[0]=>block_out_override_pin)', adm_block_override='$xavp(caller_real_prefs[0]=>adm_block_out_override_pin)' - [% logreq -%]\n");
			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$var(announce_handle) = "block_override_pin_wrong";
			$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 403;
			$(avp(s:announce_reason)[*]) = "Incorrect Override PIN";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}
	#!endif
	[% debug_dump('end', 'ROUTE_LOAD_CALLER_PREF') %]
}

########################################################################
# Request route 'set-caller-dialog'
########################################################################
route[ROUTE_SET_CALLER_DIALOG]
{
	[% debug_dump('start', 'ROUTE_SET_CALLER_DIALOG') %]
	if($avp(s:from_pstn) != 1 && $var(proxylu_dst_callee) != 1 &&
	   $avp(s:from_faxserver) != 1 && $avp(s:from_voicebox) != 1 && $avp(s:from_pbx) != 1)
	{
		# set dialog for caller
		if (!lua_run("set_dlg_profile_caller_totals", "$ci"))
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
			exit;
		}
		xlog("L_INFO", "Dialog set total - [% logreq -%]\n");
		xlog("L_INFO", "Set caller dialogs: totaluser, totaluserout, totalaccount, totalaccountout to '$avp(s:caller_uuid)/$var(caller_account_id)' - [% logreq -%]\n");
		#!ifdef ENABLE_PBX
		xlog("L_INFO", "Set caller dlg list: 'callqueue:$avp(s:caller_uuid)' - [% logreq -%]\n");
		lua_run("add_dlg_list", "$ci", "callqueue:$avp(s:caller_uuid)");
		#!endif
	}
	if($var(count_dlg) == 1 && $avp(s:from_pstn) != 1 && $var(proxylu_dst_callee) != 1 &&
	   $avp(s:from_faxserver) != 1 && $avp(s:from_voicebox) != 1 && $avp(s:from_pbx) != 1 &&
	   # no dialog for initial loop to PBX on calls between PBX users
	   !(pv_isset("$xavp(caller_real_prefs[0]=>cloud_pbx)") && $xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
	     pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") && $xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
	     $xavp(caller_real_prefs[0]=>account_id) == $xavp(callee_real_prefs[0]=>account_id) )
	  )
	{
		if (!lua_run("set_dlg_profile_caller", "$ci"))
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
			exit;
		}
		xlog("L_INFO", "Set caller dialogs: user, userout, account, accountout to '$avp(s:caller_uuid)/$var(caller_account_id)' - [% logreq -%]\n");
	}

	# Dialog count for caller. Need to check after emergency calls have been detected not to drop them.
	# Dialog count caller subscriber/domain concurrent_max total
	if(pv_isset("$xavp(caller_real_prefs[0]=>concurrent_max_total)") &&
	   $xavp(caller_real_prefs[0]=>concurrent_max_total) != 0)
	{
		if(lua_run("get_profile_size", "totaluser:$avp(s:caller_uuid)", "size"))
		{
			if ($avp(s:size) > $xavp(caller_real_prefs[0]=>concurrent_max_total))
			{
				xlog("L_NOTICE", "Concurrent_max total calls exceeded for caller '$avp(s:caller_uuid)' - [% logreq -%]\n");
				$(avp(s:acc_callee_user_in)[*]) = $rU;
				$(avp(s:acc_callee_domain_in)[*]) = $rd;

				$var(announce_handle) = "max_calls_out";
				$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
				$(avp(s:announce_code)[*]) = 403;
				$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
		}
		else
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
			exit;
		}
	}
	# Dialog count caller subscriber/domain concurrent_max_out total
	if(pv_isset("$xavp(caller_real_prefs[0]=>concurrent_max_out_total)") &&
	   $xavp(caller_real_prefs[0]=>concurrent_max_out_total) != 0)
	{
		if(lua_run("get_profile_size", "totaluserout:$avp(s:caller_uuid)","size"))
		{
			if ($avp(s:size) > $xavp(caller_real_prefs[0]=>concurrent_max_out_total))
			{
				xlog("L_NOTICE", "Concurrent_max outbound total calls exceeded for caller '$avp(s:caller_uuid)' - [% logreq -%]\n");
				$(avp(s:acc_callee_user_in)[*]) = $rU;
				$(avp(s:acc_callee_domain_in)[*]) = $rd;

				$var(announce_handle) = "max_calls_out";
				$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
				$(avp(s:announce_code)[*]) = 403;
				$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
		}
		else
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
			exit;
		}
	}

	# Dialog count caller contract concurrent_max total per account
	if(pv_isset("$xavp(caller_contract_prefs[0]=>concurrent_max_total)") &&
	   $xavp(caller_contract_prefs[0]=>concurrent_max_total) != 0)
	{
		if(lua_run("get_profile_size", "totalaccount:$var(caller_account_id)","size"))
		{
			if ($avp(s:size) > $xavp(caller_contract_prefs[0]=>concurrent_max_total))
			{
				xlog("L_NOTICE", "Concurrent_max calls total exceeded for caller '$avp(s:caller_uuid)' in account '$var(caller_account_id)' - [% logreq -%]\n");
				$(avp(s:acc_callee_user_in)[*]) = $rU;
				$(avp(s:acc_callee_domain_in)[*]) = $rd;

				$var(announce_handle) = "max_calls_out";
				$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
				$(avp(s:announce_code)[*]) = 403;
				$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
		}
		else
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
			exit;
		}
	}
	# Dialog count caller contract concurrent_max_out total per account
	if(pv_isset("$xavp(caller_contract_prefs[0]=>concurrent_max_out_total)") &&
	   $xavp(caller_contract_prefs[0]=>concurrent_max_out_total) != 0)
	{
		if(lua_run("get_profile_size","totalaccountout:$var(caller_account_id)","size"))
		{
			if ($avp(s:size) > $xavp(caller_contract_prefs[0]=>concurrent_max_out_total))
			{
				xlog("L_NOTICE", "Concurrent_max outbound total calls exceeded for caller '$avp(s:caller_uuid) in account '$var(caller_account_id)' - [% logreq -%]\n");
				$(avp(s:acc_callee_user_in)[*]) = $rU;
				$(avp(s:acc_callee_domain_in)[*]) = $rd;

				$var(announce_handle) = "max_calls_out";
				$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
				$(avp(s:announce_code)[*]) = 403;
				$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
		}
		else
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
			exit;
		}
	}

	if($var(count_dlg) == 1)
	{
		# Dialog count for caller. Need to check after emergency calls have been detected not to drop them.
		# Dialog count caller subscriber/domain concurrent_max
		if(pv_isset("$xavp(caller_real_prefs[0]=>concurrent_max)") &&
		   $xavp(caller_real_prefs[0]=>concurrent_max) != 0)
		{
			if(lua_run("get_profile_size","user:$avp(s:caller_uuid)","size"))
			{
				if ($avp(s:size) > $xavp(caller_real_prefs[0]=>concurrent_max))
				{
					xlog("L_NOTICE", "Concurrent_max calls exceeded for caller '$avp(s:caller_uuid)' - [% logreq -%]\n");
					$(avp(s:acc_callee_user_in)[*]) = $rU;
					$(avp(s:acc_callee_domain_in)[*]) = $rd;

					$var(announce_handle) = "max_calls_out";
					$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 403;
					$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
				exit;
			}
		}
		# Dialog count caller subscriber/domain concurrent_max_out
		if(pv_isset("$xavp(caller_real_prefs[0]=>concurrent_max_out)") &&
		   $xavp(caller_real_prefs[0]=>concurrent_max_out) != 0)
		{
			if(lua_run("get_profile_size","userout:$avp(s:caller_uuid)","size"))
			{
				if ($avp(s:size) > $xavp(caller_real_prefs[0]=>concurrent_max_out))
				{
					xlog("L_NOTICE", "Concurrent_max outbound calls exceeded for caller '$avp(s:caller_uuid)' - [% logreq -%]\n");
					$(avp(s:acc_callee_user_in)[*]) = $rU;
					$(avp(s:acc_callee_domain_in)[*]) = $rd;

					$var(announce_handle) = "max_calls_out";
					$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 403;
					$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
				exit;
			}
		}

		# Dialog count caller subscriber/domain concurrent_max per account
		if(pv_isset("$xavp(caller_real_prefs[0]=>concurrent_max_per_account)") &&
		   $xavp(caller_real_prefs[0]=>concurrent_max_per_account) != 0)
		{
			if(lua_run("get_profile_size","account:$var(caller_account_id)","size"))
			{
				if ($avp(s:size) > $xavp(caller_real_prefs[0]=>concurrent_max_per_account))
				{
					xlog("L_NOTICE", "Concurrent_max calls per account exceeded for caller '$avp(s:caller_uuid)' in account '$var(caller_account_id)' - [% logreq -%]\n");
					$(avp(s:acc_callee_user_in)[*]) = $rU;
					$(avp(s:acc_callee_domain_in)[*]) = $rd;

					$var(announce_handle) = "max_calls_out";
					$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 403;
					$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
				exit;
			}
		}
		# Dialog count caller subscriber/domain concurrent_max_out per account
		if(pv_isset("$xavp(caller_real_prefs[0]=>concurrent_max_out_per_account)") &&
		   $xavp(caller_real_prefs[0]=>concurrent_max_out_per_account) != 0)
		{
			if(lua_run("get_profile_size","accountout:$var(caller_account_id)","size"))
			{
				if ($avp(s:size) > $xavp(caller_real_prefs[0]=>concurrent_max_out_per_account))
				{
					xlog("L_NOTICE", "Concurrent_max outbound calls per account exceeded for caller '$avp(s:caller_uuid) in account '$var(caller_account_id)' - [% logreq -%]\n");
					$(avp(s:acc_callee_user_in)[*]) = $rU;
					$(avp(s:acc_callee_domain_in)[*]) = $rd;

					$var(announce_handle) = "max_calls_out";
					$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 403;
					$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
				exit;
			}
		}

		# Dialog count caller contract concurrent_max per account
		if(pv_isset("$xavp(caller_contract_prefs[0]=>concurrent_max)") &&
		   $xavp(caller_contract_prefs[0]=>concurrent_max) != 0)
		{
			if(lua_run("get_profile_size", "account:$var(caller_account_id)","size"))
			{
				if ($avp(s:size) > $xavp(caller_contract_prefs[0]=>concurrent_max))
				{
					xlog("L_NOTICE", "Concurrent_max calls exceeded for caller '$avp(s:caller_uuid)' in account '$var(caller_account_id)' - [% logreq -%]\n");
					$(avp(s:acc_callee_user_in)[*]) = $rU;
					$(avp(s:acc_callee_domain_in)[*]) = $rd;

					$var(announce_handle) = "max_calls_out";
					$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 403;
					$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
				exit;
			}
		}
		# Dialog count caller contract concurrent_max_out per account
		if(pv_isset("$xavp(caller_contract_prefs[0]=>concurrent_max_out)") &&
		   $xavp(caller_contract_prefs[0]=>concurrent_max_out) != 0)
		{
			if(lua_run("get_profile_size","accountout:$var(caller_account_id)","size"))
			{
				if ($avp(s:size) > $xavp(caller_contract_prefs[0]=>concurrent_max_out))
				{
					xlog("L_NOTICE", "Concurrent_max outbound calls exceeded for caller '$avp(s:caller_uuid)' in account '$var(caller_account_id)' - [% logreq -%]\n");
					$(avp(s:acc_callee_user_in)[*]) = $rU;
					$(avp(s:acc_callee_domain_in)[*]) = $rd;

					$var(announce_handle) = "max_calls_out";
					$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 403;
					$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
				exit;
			}
		}
	}
	[% debug_dump('end', 'ROUTE_SET_CALLER_DIALOG') %]
}

########################################################################
# Request route 'usr-preferences-callee'
########################################################################
route[ROUTE_LOAD_CALLEE_PREF]
{
	[% debug_dump('start', 'ROUTE_LOAD_CALLEE_PREF') %]
	xlog("L_INFO", "Load callee preferences for uuid '$avp(s:callee_uuid)' domain: '$rd'- [% logreq -%]\n");
	if (!lua_run("ngcp_callee_usr_load", "$avp(s:callee_uuid)", "$rd")) 
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
		exit;
	}
	$var(callee_account_id) = $xavp(callee_real_prefs[0]=>account_id);

	if($avp(s:has_extension) == 1 && $xavp(callee_real_prefs[0]=>extended_dialing_mode) == "strict")
	{
		xlog("L_NOTICE", "Strict number matching forced for callee but an extension was dialed - [% logreq -%]\n");
		$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
		$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

		$var(announce_handle) = "callee_unknown";
		$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
		$(avp(s:announce_code)[*]) = 404;
		$(avp(s:announce_reason)[*]) = "Not Found";
		#route(ROUTE_ACC_FAILURE);
		route(ROUTE_EARLY_REJECT);
	}
	$var(count_dlg) = 1;

	if($var(callee_account_id) != 0)
	{
		xlog("L_INFO", "Load callee contract preferences for contract id '$var(callee_account_id)' - [% logreq -%]\n");
		if (!lua_run("ngcp_callee_contract_load", "$var(callee_account_id)")) 
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_LOAD_CALLER_PREF') %]
			exit;
		}

		pv_unset("$(avp(s:callee_cloud_pbx_account_cli_list)[*])");
		if(pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)"))
		{
			avp_db_query("select vda.username from provisioning.voip_dbaliases vda left join provisioning.voip_subscribers vs on vda.subscriber_id = vs.id where vs.account_id = $xavp(callee_real_prefs[0]=>account_id)", "$avp(s:callee_cloud_pbx_account_cli_list)");
		}
	}

	$(avp(s:callee_cloud_pbx_base_cli)[*]) = $xavp(callee_real_prefs[0]=>cloud_pbx_base_cli);
	$(avp(s:callee_cloud_pbx_ext)[*]) = $xavp(callee_real_prefs[0]=>cloud_pbx_ext);
	$var(callee_ext_subscriber_id) = $xavp(callee_real_prefs[0]=>ext_subscriber_id);
	$var(callee_ext_contract_id) = $xavp(callee_real_prefs[0]=>ext_contract_id);
	if(!pv_isset("$xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting)"))
	{
		$xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting) = $xavp(callee_dom_prefs[0]=>ignore_cf_when_hunting);
	}

	$(avp(s:lbrtp_dispatcher_id_callee)[*]) = $xavp(callee_real_prefs[0]=>lbrtp_set);
	xlog("L_INFO", "Use lb/rtp set id '$avp(s:lbrtp_dispatcher_id_callee)' for local callee - [% logreq -%]\n");

	xlog("L_INFO", "Fetched dialplan IDs caller_out='$xavp(callee_real_prefs[0]=>rewrite_caller_out_dpid)', callee_out='$xavp(callee_real_prefs[0]=>rewrite_callee_out_dpid)' - [% logreq -%]\n");

	if(is_method("INVITE"))
	{
		if(pv_isset("$xavp(caller_real_prefs[0]=>cloud_pbx)") && $xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
		   pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") && $xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
		   $xavp(caller_real_prefs[0]=>account_id) == $xavp(callee_real_prefs[0]=>account_id) && $avp(s:from_pbx) == 0)
		{
			xlog("L_INFO", "Skip setting callee dialog for call inside customer PBX - [% logreq -%]\n");
			if (!lua_run("set_dlg_profile_callee_totals", "$ci"))
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
				exit;
			}
			xlog("L_INFO", "Set callee dialogs: totaluser, totalaccount to '$avp(s:callee_uuid)/$var(callee_account_id)' - [% logreq -%]\n");
			#!ifdef ENABLE_PBX
			xlog("L_INFO", "Set callee dlg list for intra-PBX call: 'callqueue:$avp(s:callee_uuid)' - [% logreq -%]\n");
			lua_run("add_dlg_list", "$ci", "callqueue:$avp(s:callee_uuid)");
			#!endif
		}
		else if($avp(s:from_pbx) == 1 && pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") && $xavp(callee_real_prefs[0]=>cloud_pbx) == 1)
		{
			xlog("L_INFO", "Skip setting callee dialog for call from PBX - [% logreq -%]\n");
			#!ifdef ENABLE_PBX
			if(pv_isset("$avp(s:p_from_aa)") && $avp(s:p_from_aa) == 1)
			{
				xlog("L_INFO", "Set callee dlg list for call from AA: 'callqueue:$avp(s:callee_uuid)' - [% logreq -%]\n");
				lua_run("add_dlg_list", "$ci", "callqueue:$avp(s:callee_uuid)");
			}
			#!endif
		}
		# other call (NOT from PBX user to non-PBX user) - set dialog only on initial loop to PBX
		else if(!(pv_isset("$xavp(caller_real_prefs[0]=>cloud_pbx)") && $xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
		    $avp(s:from_pbx) == 1 && $xavp(callee_real_prefs[0]=>cloud_pbx) != 1))
		{
			# dialog mark for local callee
			if (!lua_run("set_dlg_profile_callee", "$ci"))
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
				exit;
			}
			xlog("L_INFO", "Set callee dialogs: user, account to '$avp(s:callee_uuid)/$var(callee_account_id)' - [% logreq -%]\n");
			if (!lua_run("set_dlg_profile_callee_totals", "$ci"))
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
				exit;
			}
			xlog("L_INFO", "Set callee dialogs: totaluser, totalaccount to '$avp(s:callee_uuid)/$var(callee_account_id)' - [% logreq -%]\n");
			#!ifdef ENABLE_PBX
			xlog("L_INFO", "Set callee dlg list for normal call: 'callqueue:$avp(s:callee_uuid)' - [% logreq -%]\n");
			lua_run("add_dlg_list", "$ci", "callqueue:$avp(s:callee_uuid)");
			#!endif
		}
		#!ifdef ENABLE_PBX
		if($avp(s:from_pbx) == 0 || ($avp(s:from_pbx) == 1 && pv_isset("$avp(s:p_from_aa)") && $avp(s:p_from_aa) == 1 &&
		   pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") && $xavp(callee_real_prefs[0]=>cloud_pbx) == 1))
		{
			# find the huntgroup the callee belongs to
			# and add it to the list (for queue tracking)
			avp_db_query("select uuid,username from usr_preferences where attribute='cloud_pbx_hunt_group' and value='sip:$(rU{s.escape.common})@$(rd{s.escape.common})'", "$avp(s:callee_hg_uuid);$avp(s:callee_hg_username)");
			while(pv_isset("$avp(s:callee_hg_uuid)[0]"))
			{
				xlog("L_INFO", "Set callee dlg list for a member of huntgroup $avp(s:callee_hg_username) with uuid '$avp(s:callee_hg_uuid)' - [% logreq -%]\n");
				lua_run("add_dlg_list", "$ci", "callqueue:$avp(s:callee_hg_uuid)");
				pv_unset("$avp(s:callee_hg_uuid)[0]");
			}
		}
		#!endif
		if((avp_check("$xavp(callee_real_prefs[0]=>lock)", "eq/s:3") ||
		    avp_check("$xavp(callee_real_prefs[0]=>lock)", "eq/s:4")) &&
		   $avp(s:from_faxserver) == 0 && $avp(s:from_voicebox) == 0)
		{
			xlog("L_NOTICE", "Callee locked for incoming with mode '$xavp(callee_real_prefs[0]=>lock)' - [% logreq -%]\n");
			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$var(announce_handle) = "locked_in";
			$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 403;
			$(avp(s:announce_reason)[*]) = "Callee locked";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}

		# dialog count for callee subscriber/dom concurrent max
		if(pv_isset("$xavp(callee_real_prefs[0]=>concurrent_max)") &&
		   $xavp(callee_real_prefs[0]=>concurrent_max) != 0)
		{
			if(lua_run("get_profile_size","user:$avp(s:callee_uuid)","size"))
			{
				if ($avp(s:size) > $xavp(callee_real_prefs[0]=>concurrent_max))
				{
					xlog("L_NOTICE", "Concurrent max calls exceeded for callee '$avp(s:callee_uuid)' - [% logreq -%]\n");

					$var(announce_handle) = "max_calls_in";
					$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 486;
					$(avp(s:announce_reason)[*]) = "Busy";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
				exit;
			}
		}
		# dialog count for callee subscriber/dom concurrent max per account
		if(pv_isset("$xavp(callee_real_prefs[0]=>concurrent_max_per_account)") &&
		   $xavp(callee_real_prefs[0]=>concurrent_max_per_account) != 0)
		{
			if(lua_run("get_profile_size","account:$var(callee_account_id)","size"))
			{
				if ($avp(s:size) > $xavp(callee_real_prefs[0]=>concurrent_max_per_account))
				{
					xlog("L_NOTICE", "Concurrent max calls per account exceeded for callee '$avp(s:callee_uuid)' in account '$var(callee_account_id)' - [% logreq -%]\n");

					$var(announce_handle) = "max_calls_in";
					$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 486;
					$(avp(s:announce_reason)[*]) = "Busy";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
				exit;
			}
		}

		# Dialog count callee subscriber/domain concurrent_max total
		if(pv_isset("$xavp(callee_real_prefs[0]=>concurrent_max_total)") &&
		   $xavp(callee_real_prefs[0]=>concurrent_max_total) != 0)
		{
			if(lua_run("get_profile_size", "totaluser:$avp(s:callee_uuid)", "size"))
			{
				if ($avp(s:size) > $xavp(callee_real_prefs[0]=>concurrent_max_total))
				{
					xlog("L_NOTICE", "Concurrent_max total calls exceeded for callee '$avp(s:callee_uuid)' - [% logreq -%]\n");

					$var(announce_handle) = "max_calls_in";
					$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 403;
					$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
				exit;
			}
		}

		# Dialog count callee contract concurrent_max total per account
		if(pv_isset("$xavp(callee_contract_prefs[0]=>concurrent_max_total)") &&
		   $xavp(callee_contract_prefs[0]=>concurrent_max_total) != 0)
		{
			if(lua_run("get_profile_size", "totalaccount:$var(callee_account_id)","size"))
			{
				if ($avp(s:size) > $xavp(callee_contract_prefs[0]=>concurrent_max_total))
				{
					xlog("L_NOTICE", "Concurrent_max calls total exceeded for callee '$avp(s:callee_uuid)' in account '$var(callee_account_id)' - [% logreq -%]\n");

					$var(announce_handle) = "max_calls_in";
					$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 403;
					$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_SET_CALLER_DIALOG') %]
				exit;
			}
		}

		# Dialog count callee contract concurrent max per account
		if(pv_isset("$xavp(callee_contract_prefs[0]=>concurrent_max)") &&
		   $xavp(callee_contract_prefs[0]=>concurrent_max) != 0)
		{
			if(lua_run("get_profile_size","account:$var(callee_account_id)","size"))
			{
				if ($avp(s:size) > $xavp(callee_contract_prefs[0]=>concurrent_max))
				{
					xlog("L_NOTICE", "Concurrent max calls exceeded for callee '$avp(s:callee_uuid)' in account '$var(callee_account_id)' - [% logreq -%]\n");

					$var(announce_handle) = "max_calls_in";
					$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
					$(avp(s:announce_code)[*]) = 486;
					$(avp(s:announce_reason)[*]) = "Busy";
					route(ROUTE_ACC_FAILURE);
					route(ROUTE_EARLY_REJECT);
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
				exit;
			}
		}
		if($var(cf_loop) == 1 && pv_isset("$avp(s:first_caller_clir)") && $avp(s:first_caller_clir) != 0)
		{
			if(($xavp(callee_real_prefs[0]=>outbound_from_user) =~ "^uprn" || $xavp(callee_real_prefs[0]=>outbound_from_display) =~ "^uprn") &&
			    pv_isset("$avp(s:forwarder_cli_userprov)") && $avp(s:forwarder_cli_userprov) != 0)
			# first caller is anonymous but the callee choose to see forwarder's UPRN => ignore first caller CLIR
			{
				xlog("L_INFO", "Ignore first caller CLIR because UPRN is selected by callee dom/usr preference - [% logreq -%]\n");
				$(avp(s:caller_clir_ignore)[*]) = 1;
			}
			else
			{
				xlog("L_INFO", "Use first caller CLIR as caller CLIR - [% logreq -%]\n");
				$(avp(s:caller_clir)[*]) = $avp(s:first_caller_clir);
			}
		}
		else if($var(cf_loop) == 1 && pv_isset("$avp(s:caller_clir)") && $avp(s:caller_clir) != 0)
		{
			if(!($xavp(callee_real_prefs[0]=>outbound_from_user) =~ "^uprn" || $xavp(callee_real_prefs[0]=>outbound_from_display) =~ "^uprn") &&
			    pv_isset("$avp(s:forwarder_cli_userprov)") && $avp(s:forwarder_cli_userprov) != 0)
			# caller is anonymous but the callee choose to see first/original caller => unset caller CLIR
			{
				xlog("L_INFO", "Unset forwarder's CLIR because first CLI is selected by callee dom/usr preference - [% logreq -%]\n");
				$(avp(s:caller_clir)[*]) = $null;
			}

		}
		# check incoming block-list
		route(ROUTE_BLOCK_IN);

		if(pv_isset("$xavp(callee_real_prefs[0]=>cft)") && !($avp(s:from_pbx) == 1 &&
		   ($avp(s:p_to_device) == 1 || ($avp(s:p_to_group) == 1 && $xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting) == 1))))
		{
			xlog("L_INFO", "Setting ring timeout to $xavp(callee_real_prefs[0]=>ringtimeout)s - [% logreq -%]\n");
			$(avp(s:callee_fr_inv_timer)[*]) = $xavp(callee_real_prefs[0]=>ringtimeout) * 1000;
			t_set_fr("$avp(s:callee_fr_inv_timer)");
		}

	}
	[% debug_dump('end', 'ROUTE_LOAD_CALLEE_PREF') %]
}

########################################################################
# Request route to load call-forward maps - needs $var(cf_id) set
########################################################################
route[ROUTE_LOAD_CF_MAP]
{
	[% debug_dump('start', 'ROUTE_LOAD_CF_MAP') %]
	$(avp(s:cf_destinations)[*]) = $null;
	$(avp(s:cf_timeouts)[*]) = $null;
	$(avp(s:cf_periods)[*]) = $null;

	avp_db_query("select d.destination, d.timeout from provisioning.voip_cf_destinations d, provisioning.voip_cf_destination_sets ds, provisioning.voip_cf_mappings m where m.id=$var(cf_id) and m.destination_set_id=ds.id and d.destination_set_id=ds.id order by d.priority asc", "$avp(s:cf_destinations),$avp(s:cf_timeouts)");
	xlog("L_INFO", "Loaded CF destination set for CF map id '$var(cf_id)': '$(avp(s:cf_destinations)[*])' - [% logreq -%]\n");
	xlog("L_INFO", "Loaded CF timeouts for CF map id '$var(cf_id)': '$(avp(s:cf_timeouts)[*])' - [% logreq -%]\n");

	avp_db_query("select concat(if(p.year is null, '', concat('yr{', p.year, '} ')), if(p.month is null, '', concat('mo{', p.month, '} ')), if(p.mday is null, '', concat('md{', p.mday, '} ')), if(p.wday is null, '', concat('wd{', p.wday, '} ')), if(p.hour is null, '', concat('hr{', p.hour, '} ')), if(p.minute is null, '', concat('min{', p.minute, '} '))) as period from provisioning.voip_cf_periods p, provisioning.voip_cf_time_sets ts, provisioning.voip_cf_mappings m where m.id=$var(cf_id) and m.time_set_id=ts.id and p.time_set_id=ts.id", "$avp(s:cf_periods)");
	if($avp(s:cf_periods) != $null)
	{
		xlog("L_INFO", "Loaded CF time destination set for CF map id '$var(cf_id)': '$(avp(s:cf_periods)[*])' - [% logreq -%]\n");
	}
	else
	{
		xlog("L_INFO", "No CF time destination set for CF map id '$var(cf_id)' found, CF is done always - [% logreq -%]\n");
	}
	[% debug_dump('end', 'ROUTE_LOAD_CF_MAP') %]
}

########################################################################
# Request route to check CF time period
########################################################################
route[ROUTE_CHECK_CF_PERIOD]
{
	[% debug_dump('start', 'ROUTE_CHECK_CF_PERIOD') %]
	if($avp(s:cf_periods) != $null)
	{
		$(avp(s:tmp_cf_periods)[*]) = $null;
		avp_copy("$avp(s:cf_periods)", "$avp(s:tmp_cf_periods)/g");
		while($avp(s:tmp_cf_periods) != $null)
		{
			xlog("L_INFO", "Checking CF time period '$(avp(s:tmp_cf_periods)[0])' - [% logreq -%]\n");
			if(time_period_match("$(avp(s:tmp_cf_periods)[0])", "$TS"))
			{
				xlog("L_INFO", "CF time period '$(avp(s:tmp_cf_periods)[0])' matched, performing call-forward - [% logreq -%]\n");
				[% debug_dump('return', 'ROUTE_CHECK_CF_PERIOD') %]
				return(1);
			}
			else
			{
				$(avp(s:tmp_cf_periods)[0]) = $null;
			}
		}
		[% debug_dump('return', 'ROUTE_CHECK_CF_PERIOD') %]
		return(-1);
	}
	else
	{
		[% debug_dump('return', 'ROUTE_CHECK_CF_PERIOD') %]
		return(1);
	}
}

########################################################################
# Request route 'acc-caller'
########################################################################
route[ROUTE_ACC_CALLER]
{
	[% debug_dump('start', 'ROUTE_ACC_CALLER') %]

	if($avp(s:caller_peer_auth_user) != $null)
	{
		$(avp(s:acc_caller_pau)[*]) = $avp(s:caller_peer_auth_user);
	}
	else
	{
		$(avp(s:acc_caller_pau)[*]) = '';
	}
	if($avp(s:caller_peer_auth_realm) != $null)
	{
		$(avp(s:acc_caller_par)[*]) = $avp(s:caller_peer_auth_realm);
	}
	else
	{
		$(avp(s:acc_caller_par)[*]) = '';
	}
	$var(gpp) = $xavp(caller_real_prefs[0]=>gpp0) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp1) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp2) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp3) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp4) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp5) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp6) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp7) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp8) + "|" +
	            $xavp(caller_real_prefs[0]=>gpp9);

	# agranig: we add a trailing "|" to avoid special handling for 
	# last gpp in mediator
	xlog("L_NOTICE", "Setting acc source-leg for uuid '$avp(s:caller_uuid)': '$avp(s:caller_uuid)|$avp(s:acc_caller_user)|$avp(s:acc_caller_domain)|$avp(s:caller_cli_userprov)|$var(caller_ext_subscriber_id)|$var(caller_ext_contract_id)|$var(caller_account_id)|$avp(s:acc_caller_pau)|$avp(s:acc_caller_par)|$avp(s:caller_clir)|$avp(s:acc_state)|$avp(s:caller_ip_val)|$TV(Sn)|$var(gpp)|' - [% logreq -%]\n");
	$avp(i:901) = $_s($avp(s:caller_uuid)|$avp(s:acc_caller_user)|$avp(s:acc_caller_domain)|$avp(s:caller_cli_userprov)|$var(caller_ext_subscriber_id)|$var(caller_ext_contract_id)|$var(caller_account_id)|$avp(s:acc_caller_pau)|$avp(s:acc_caller_par)|$avp(s:caller_clir)|$avp(s:acc_state)|$avp(s:caller_ip_val)|$TV(Sn)|) + $var(gpp) + "|";
	[% debug_dump('end', 'ROUTE_ACC_CALLER') %]
}

########################################################################
# Request route 'acc-callee'
########################################################################
route[ROUTE_ACC_CALLEE]
{
	[% debug_dump('start', 'ROUTE_ACC_CALLEE') %]
	if($var(proxylu_src) == 1 || $var(proxylu_dst_callee == 1))
	{
		$(avp(s:callee_acc_proxylu)[*]) = 1;
	}
	else
	{
		$(avp(s:callee_acc_proxylu)[*]) = 0;
	}

	$var(gpp) = $xavp(callee_real_prefs[0]=>gpp0) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp1) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp2) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp3) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp4) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp5) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp6) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp7) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp8) + "|" +
	            $xavp(callee_real_prefs[0]=>gpp9);

	xlog("L_NOTICE", "Setting acc destination-leg for uuid '$avp(s:callee_uuid)': '$avp(s:callee_acc_proxylu)|$var(callee_ext_subscriber_id)|$var(callee_ext_contract_id)|$var(callee_account_id)|$avp(s:acc_callee_dialed)|$avp(s:callee_uuid)|$avp(s:acc_callee_user)|$avp(s:acc_callee_domain)|$avp(s:acc_callee_user_in)|$avp(s:acc_callee_domain_in)|$avp(s:lcr_flags)|$var(gpp)|' - [% logreq -%]\n");
	$avp(i:902) = $_s($avp(s:callee_acc_proxylu)|$var(callee_ext_subscriber_id)|$var(callee_ext_contract_id)|$var(callee_account_id)|$avp(s:acc_callee_dialed)|$avp(s:callee_uuid)|$avp(s:acc_callee_user)|$avp(s:acc_callee_domain)|$avp(s:acc_callee_user_in)|$avp(s:acc_callee_domain_in)|$avp(s:lcr_flags)|) + $var(gpp) + "|";
	[% debug_dump('end', 'ROUTE_ACC_CALLEE') %]
}

########################################################################
# Request route 'acc-failure'
########################################################################
route[ROUTE_ACC_FAILURE]
{
	[% debug_dump('start', 'ROUTE_ACC_FAILURE') %]

	if($var(no_acc) == 1)
	{
		xlog("L_INFO", "Skip accounting for failed request as flagged - [% logreq -%]\n");
		return;
	}


	xlog("L_INFO", "Accounting failed request for uuid '$avp(s:caller_uuid)' - [% logreq -%]\n");
	if($avp(s:acc_callee_user) == $null)
	{
		$(avp(s:acc_callee_user)[*]) = $rU;
	}
	if($avp(s:acc_callee_domain) == $null)
	{
		$(avp(s:acc_callee_domain)[*]) = $rd;
	}
	if($avp(s:caller_uuid) == $null)
	{
		$(avp(s:caller_uuid)[*]) = 0;
	}
	if($avp(s:callee_uuid) == $null)
	{
		$(avp(s:callee_uuid)[*]) = 0;
	}
	route(ROUTE_ACC_CALLER);
	route(ROUTE_ACC_CALLEE);
	resetflag(FLAG_ACC_FAILED);
	# TODO: be sure $avps are set for this message
	if (pv_isset("$avp(s:announce_reason)")) {
		if (pv_isset("$avp(s:announce_code)")) {
			acc_db_request("$avp(s:announce_code) $avp(s:announce_reason)", "acc");
		} else {
			acc_db_request("$avp(s:announce_reason)", "acc");
		}
	} else {
		# old behaviour
		acc_db_request("404", "acc");
	}
	[% debug_dump('end', 'ROUTE_ACC_FAILURE') %]
}

########################################################################
# Request route 'cfu-acc'
########################################################################
route[ROUTE_ACC_CF]
{
	[% debug_dump('start', 'ROUTE_ACC_CF') %]
	$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
	$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

	route(ROUTE_ACC_CALLER);
	route(ROUTE_ACC_CALLEE);
	[% debug_dump('end', 'ROUTE_ACC_CF') %]
}

########################################################################
# Check for anonymization
########################################################################
route[ROUTE_CLIR]
{
	[% debug_dump('start', 'ROUTE_CLIR') %]
	if($avp(s:from_pstn) == 0 && uri =~ "^sip:\*[% sems.vsc.clir_code %]\*")
	{
		strip([% sems.vsc.clir_code.length + 2 %]);
		if($avp(s:override_caller_clir) == 0)
		{
			if($avp(s:caller_clir) == 1)
			{
				xlog("L_NOTICE", "Per-call CLIR disabled - [% logreq -%]\n");
				$(avp(s:caller_clir)[*]) = 0;
			}
			else
			{
				xlog("L_NOTICE", "Per-call CLIR enabled - [% logreq -%]\n");
				$(avp(s:caller_clir)[*]) = 1;
			}
		}
	}

	if($avp(s:caller_clir) == 1)
	{
		xlog("L_INFO", "Caller anonymization - [% logreq -%]\n");
	}
	else if(avp_check("$fn", "fm/[Aa]nonymous") || avp_check("$fn", "fm/\"[Aa]nonymous\""))
	{
		$(avp(s:caller_clir)[*]) = 1;
		xlog("L_NOTICE", "Caller anonymization user-provided (display) - [% logreq -%]\n");
	}
	else if(avp_check("$fU", "fm/[Aa]nonymous"))
	{
		$(avp(s:caller_clir)[*]) = 1;
		xlog("L_NOTICE", "Caller anonymization user-provided (user) - [% logreq -%]\n");
	}
	else if(is_present_hf("Privacy"))
	{
		$var(priv) = $hdr(Privacy);
		$var(priv_value) = 0;
		$var(priv_loop_idx) = 0;
		while($(var(priv){s.select,$var(priv_loop_idx),;}) != '')
		{
			$var(priv_value) = $(var(priv){s.select,$var(priv_loop_idx),;});
			if($var(priv_value) == "id")
			{
				$(avp(s:caller_clir)[*]) = 1;
				xlog("L_NOTICE", "Caller anonymization user-provided (privacy) - [% logreq -%]\n");
			}
			$var(priv_loop_idx) = $var(priv_loop_idx) + 1;
		}
	}

	# set to 0 for marking it in CDR
	if($avp(s:caller_clir) == $null)
	{
		$(avp(s:caller_clir)[*]) = 0;
	}
	[% debug_dump('end', 'ROUTE_CLIR') %]
}

########################################################################
# Reply route to restore lbrtp cluster set from Route params
########################################################################
route[ROUTE_RESTORE_CLUSTERSET]
{
	[% debug_dump('start', 'ROUTE_RESTORE_CLUSTERSET') %]
	if(!pv_isset("$avp(s:lbrtp_dispatcher_id_caller)"))
	{
		$var(tmproute) = $(hdr(Route)[0]{nameaddr.uri});
		$var(tmprouteparam) = $(var(tmproute){uri.param,aset});
		$(avp(s:lbrtp_dispatcher_id_caller)[*]) = $var(tmprouteparam);
		if(!pv_isset("$avp(s:lbrtp_dispatcher_id_caller)") || $avp(s:lbrtp_dispatcher_id_caller) == "")
		{
			$(avp(s:lbrtp_dispatcher_id_caller)[*]) = [% cluster_sets.${cluster_sets.default_set}.dispatcher_id %];
			xlog("L_INFO", "Recovered rtpengine caller did '$avp(s:lbrtp_dispatcher_id_caller)' from default value - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Recovered rtpengine caller did '$avp(s:lbrtp_dispatcher_id_caller)' from Route - [% logreq -%]\n");
		}
	}
	if(!pv_isset("$avp(s:lbrtp_dispatcher_id_callee)"))
	{
		$var(tmproute) = $(hdr(Route)[0]{nameaddr.uri});
		$var(tmprouteparam) = $(var(tmproute){uri.param,bset});
		$(avp(s:lbrtp_dispatcher_id_callee)[*]) = $var(tmprouteparam);
		if(!pv_isset("$avp(s:lbrtp_dispatcher_id_callee)") || $avp(s:lbrtp_dispatcher_id_callee) == "")
		{
			$(avp(s:lbrtp_dispatcher_id_callee)[*]) = $avp(s:lbrtp_dispatcher_id_caller);
			xlog("L_INFO", "Recovered rtpengine callee did '$avp(s:lbrtp_dispatcher_id_callee)' from caller value - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Recovered rtpengine callee did '$avp(s:lbrtp_dispatcher_id_callee)' from Route - [% logreq -%]\n");
		}
	}
	[% debug_dump('end', 'ROUTE_RESTORE_CLUSTERSET') %]
}

########################################################################
# Request route to stop rtpproxy for all branches
########################################################################
route[ROUTE_STOP_RTPPROXY]
{
	[% debug_dump('start', 'ROUTE_STOP_RTPPROXY') %]
	if($var(stop_rtpproxy) == 1)
	{
		route(ROUTE_RESTORE_CLUSTERSET);
		xlog("L_INFO", "Stop mediaproxy for all branches, caller did is '$avp(s:lbrtp_dispatcher_id_caller)' and callee did is '$avp(s:lbrtp_dispatcher_id_callee)' - [% logreq -%]\n");
		if($avp(s:lbrtp_dispatcher_id_caller) == $avp(s:lbrtp_dispatcher_id_callee))
		{
			set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})");
		}
		else
		{
			set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})", "$(avp(s:lbrtp_dispatcher_id_callee){s.int})");
		}
		rtpengine_delete("to-tag");
	}
	else
	{
		xlog("L_INFO", "No mediaproxy engaged, no need for stopping  - [% logreq -%]\n");
	}
	[% debug_dump('end', 'ROUTE_STOP_RTPPROXY') %]
}

########################################################################
# Request route to stop rtpproxy for current branch
########################################################################
route[ROUTE_STOP_RTPPROXY_BRANCH]
{
	[% debug_dump('start', 'ROUTE_STOP_RTPPROXY_BRANCH') %]
	if(isbflagset(FLB_RTPPROXY))
	{
		route(ROUTE_RESTORE_CLUSTERSET);
		xlog("L_INFO", "Stop mediaproxy for current branch using first Via, caller did is '$avp(s:lbrtp_dispatcher_id_caller)' and callee did is '$avp(s:lbrtp_dispatcher_id_callee)' - [% logreq -%]\n");
		if($avp(s:lbrtp_dispatcher_id_caller) == $avp(s:lbrtp_dispatcher_id_callee))
		{
			set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})");
		}
		else
		{
			set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})", "$(avp(s:lbrtp_dispatcher_id_callee){s.int})");
		}
		rtpengine_delete("to-tag");
	}
	else
	{
		xlog("L_INFO", "No mediaproxy engaged for this branch, no need for stopping  - [% logreq -%]\n");
	}
	[% debug_dump('end', 'ROUTE_STOP_RTPPROXY_BRANCH') %]
}


########################################################################
# Request route 'base-outbound'
########################################################################
route[ROUTE_OUTBOUND]
{
	[% debug_dump('start', 'ROUTE_OUTBOUND') %]
	if(is_present_hf("P-Asserted-Identity"))
	{
		remove_hf("P-Asserted-Identity");
	}
	if(is_present_hf("P-Preferred-Identity"))
	{
		remove_hf("P-Preferred-Identity");
	}
	if(is_present_hf("Remote-Party-ID"))
	{
		remove_hf("Remote-Party-ID");
	}
	if(is_present_hf("Privacy"))
	{
		remove_hf("Privacy");
	}
	if(is_present_hf("Diversion"))
	{
		remove_hf("Diversion");
	}

	[% IF kamailio.proxy.allow_info_method == "no" -%]
	if ($var(loose_routed) != 1 && hf_value_exists("Allow", "INFO"))
	{
		xlog("L_INFO", "Remove INFO from Allow - [% logreq -%]\n");
		exclude_hf_value("Allow", "INFO");
		msg_apply_changes();
	}
	[% END -%]

	[% IF kamailio.proxy.allow_refer_method == "no" -%]
	if ($var(loose_routed) != 1 && hf_value_exists("Allow", "REFER")) {
		xlog("L_INFO", "Remove REFER from Allow - [% logreq -%]\n");
		exclude_hf_value("Allow", "REFER");
		msg_apply_changes();
	}
	[% END -%]
	if($var(loose_routed) != 1)
	{
		if(!t_is_failure_route() && $rU != "earlyannounce" && !uri =~ "^sip:emergency_")
		{
			route(ROUTE_SET_CALLER_DIALOG);
		}
		else if($rU == "earlyannounce" && $var(to_pbx) == 1)
		{
			xlog("L_INFO", "Keep call from PBX user to media server local - [% logreq -%]\n");
			$var(to_pbx) = 0;
			$var(no_sbc) = 0;
		}
		if($var(no_acc) != 1)
		{
			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);
			# e.g. call intercepted by ROUTE_CHECK_PBX before the callee_user/domain is set
			if(!pv_isset("$avp(s:acc_callee_user)"))
			{
				$(avp(s:acc_callee_user)[*]) = $rU;
			}
			if(!pv_isset("$avp(s:acc_callee_domain)"))
			{
				$(avp(s:acc_callee_domain)[*]) = $rd;
			}

			route(ROUTE_ACC_CALLER);
			route(ROUTE_ACC_CALLEE);
		}
		else
		{
			# for proper UPN/NPN assignment on calls from PSTN via PBX
			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);
		}

		if($var(no_sbc) == 1)
		{
			t_on_branch("BRANCH_ROUTE_NO_SBC");
		}
		else
		{
			t_on_branch("BRANCH_ROUTE_SBC");
		}
		setflag(FLAG_DOWNSTREAM);
		#!ifdef ENABLE_PBX
		if($var(to_pbx) == 1)
		{
			if(($xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
			    $var(from_pbx_initial) == 1) ||
			   !(pv_isset("$xavp(caller_real_prefs[0]=>cloud_pbx)") && $xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
			     $avp(s:from_pbx) == 1 && $xavp(callee_real_prefs[0]=>cloud_pbx) != 1))
			{
				$(avp(s:sca_active)[*]) = 1;
				subst_hf("To", "/:.+@/:$rU@/", "a");
				msg_apply_changes();
				sca_call_info_update();
			}
		}
	        #!endif
		if(!t_is_failure_route() && $var(redirected_forward) != 1)
		{
			record_route();
		}
	}

	t_on_reply("REPLY_ROUTE_NAT");

	if(
	   $var(proxylu_src) != 1 &&
	   !($var(loose_routed) == 1 && 
	   ([% FOREACH ip IN sip_proxy_ips -%]$si == "[% ip %]"[% IF sip_proxy_ips.last != ip -%] || [% END -%][% END -%])
	  ))
	{
		if(is_present_hf("Proxy-Authorization"))
		{
			remove_hf("Proxy-Authorization");
		}
		if(is_present_hf("Authorization"))
		{
			remove_hf("Authorization");
		}
	}
	if($var(to_pstn) == 1 || $avp(s:to_faxserver) == 1)
	{
		$var(lburi) = "";
		$var(origdu) = $du;
		xlog("L_INFO", "Loading dispatcher entries for lb using did '$avp(s:lbrtp_dispatcher_id_callee)' - [% logreq -%]\n");
		if(!ds_select_dst("$(avp(s:lbrtp_dispatcher_id_callee){s.int})", "4"))
		{
			xlog("L_WARN", "Failed to load dispatcher entries for lb using did '$avp(s:lbrtp_dispatcher_id_callee)', use first lb found in network.yml - [% logreq -%]\n");
			$var(lburi) = "sip:[% sip_lb_ips.0 %]:[% kamailio.lb.port %]";
		}
		else
		{
			$var(lburi) = $du;
			xlog("L_INFO", "Successfully loaded lb '$var(lburi)' from dispatcher using did '$avp(s:lbrtp_dispatcher_id_callee)' - [% logreq -%]\n");
		}
		$du = $var(origdu);
		if($du == 0 || $du == "")
		{
			$du = $null;
		}
	}

	if($var(to_pstn) == 1 && $xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer) =~ "^force" && $avp(s:callee_uuid) != "0")
	{
		$var(forced_outbound_call_to_peer) = 1;
	}
	xlog("L_INFO", "Relaying request, du='$du' - [% logreq -%]\n");

	# no 100 (we already sent it)
	if(!t_relay_to("0x01"))
	{
		sl_reply_error();
		if(is_method("INVITE"))
		{
			route(ROUTE_STOP_RTPPROXY_BRANCH);
		}
	}
	[% debug_dump('exit', 'ROUTE_OUTBOUND') %]
	exit;
}

########################################################################
# Request route to extract CLI from SIP message
# in:  $var(ccli_selector), $var(ccli_desc)
# out: $var(ccli_user), $var(ccli_domain)
########################################################################
route[ROUTE_GET_CALLER_CLI]
{
	[% debug_dump('start', 'ROUTE_GET_CALLER_CLI') %]
	if($var(ccli_selector) == 0)
	{
		$var(ccli_selector) = "";
	}
	if($var(ccli_selector) == "ppi_user" && is_present_hf("P-Preferred-Identity"))
	{
		$var(ccli_user) = $pU;
		$var(ccli_domain) = $pd;
		xlog("L_NOTICE", "$var(ccli_desc) '$var(ccli_user)' taken from PPI - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "pai_user" && is_present_hf("P-Asserted-Identity"))
	{
		$var(ccli_user) = $(ai{uri.user});
		$var(ccli_domain) = $(ai{uri.host});
		xlog("L_NOTICE", "$var(ccli_desc) '$var(ccli_user)' taken from PAI - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "rpid_user" && is_present_hf("Remote-Party-ID"))
	{
		$var(ccli_user) = $(re{uri.user});
		$var(ccli_domain) = $(re{uri.host});
		xlog("L_NOTICE", "$var(ccli_desc) '$var(ccli_user)' taken from RPID - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "from_display" && $fn != $null && $(fn{s.len}) > 0)
	{
		$var(ccli_user) = $fn;
		# strip optional double-quotes
		if($var(ccli_user) =~ "^\".+\"$")
		{
			#$var(ccli_user) = $(var(ccli_user){s.select,1,"});
			# TODO: the above seems to break in unpredictable cases, use old/safe way for now
			$var(ccli_user) = $(var(ccli_user){re.subst,/^\"?([^\"]*)\"?$/\1/});
		}
		$var(ccli_domain) = $fd;
		xlog("L_NOTICE", "$var(ccli_desc) '$var(ccli_user)' taken from From-Display - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "from_user")
	{
		$var(ccli_user) = $fU;
		$var(ccli_domain) = $fd;
		xlog("L_NOTICE", "$var(ccli_desc) '$var(ccli_user)' taken from From-User - [% logreq -%]\n");
	}
	else
	{
		$var(ccli_user) = $fU;
		$var(ccli_domain) = $fd;
		xlog("L_NOTICE", "$var(ccli_desc) '$var(ccli_user)' taken from From-User as fallback, should be from '$var(ccli_selector)' - [% logreq -%]\n");
	}
	[% debug_dump('end', 'ROUTE_GET_CALLER_CLI') %]
}

########################################################################
# Request route 'base-route-invite'
########################################################################
route[ROUTE_INVITE]
{
	[% debug_dump('start', 'ROUTE_INVITE') %]
	#unescape before escaping to not encode '%' as '%25'
	if($rU != $null)
	{
		if(uri =~ "\%[0-9]+")
		{
			$var(uuser) = $(rU{s.unescape.user});
			$rU = $(var(uuser){s.escape.user});
		}
		else
		{
			$rU = $(rU{s.escape.user});
		}
	}

	$(avp(s:from_voicebox)[*]) = $null;
	$(avp(s:pstn)[*]) = 0;
	$(avp(s:cf_depth)[*]) = 0;
	$(avp(s:to_voicebox)[*]) = $null;
	$(avp(s:size)[*]) = 0;

	# checking if a request is a retransmission, if so it will exit
	t_check_trans();

	route(ROUTE_LOAD_CALLEE_DOMAIN_PREF);
	route(ROUTE_FIND_CALLER);
	if($var(no_acc) == 0)
	{
		setflag(FLAG_ACC_FAILED);
		setflag(FLAG_ACC_DB);
	}
	if(!pv_isset("$avp(s:acc_callee_dialed)"))
	{
		$(avp(s:acc_callee_dialed)[*]) = $rU;
	}

	#!ifdef ENABLE_PBX
	if((($rd == $fd && $avp(s:from_pbx) != 1) ||
	   ([% FOREACH ip IN sip_int_ips -%]$rd == "[% ip %]"[% IF sip_int_ips.last != ip -%] || [% END -%][% END -%]) && $rp == "[% pbx.bindport %]") &&
	   $var(loose_routed) != 1 && is_present_hf("Replaces"))
	{
		$var(is_replaces) = 1;
		if($hdr(Replaces) =~ "^.+;early-only$")
		{
			xlog("L_INFO", "Got BLF pickup by INVITE with Replaces  - [% logreq -%]\n");

			# TODO: either Cisco or Innovaphone uses wrong order of from/to tags in Replaces,
			# for now fix the Innovaphone case
			if($hdr(User-Agent) =~ "innovaphone")
			{
				xlog("L_INFO", "Swap tags in Replaces from Innovaphone - [% logreq -%]\n");
				$var(tmp_replaces) = $hdr(Replaces);
				$var(dlg_callid) = $(hdr(Replaces){s.select,0,;});
				$(avp(s:colpid)[*]) = $hdr(Replaces);
				avp_subst("$avp(s:colpid)", "/^[^;]+;//"); # remove callid
				$var(dlg_ftag) = $(avp(s:colpid){param.value,from-tag,;});
				$var(dlg_ttag) = $(avp(s:colpid){param.value,to-tag,;});
				remove_hf("Replaces");
				append_hf("Replaces: $var(dlg_callid);to-tag=$var(dlg_ftag);from-tag=$var(dlg_ttag);early-only\r\n");
			}	

			# try to figure out the originally calling party and set avp s:colpid to be
			# injected in replies back to the picking up party for proper displaying it
			route(ROUTE_BLF_PICKUP);
		}
		else
		{
			xlog("L_INFO", "Got SLA pickup by INVITE with Replaces  - [% logreq -%]\n");
		}
	}
	#!endif

	if($avp(s:from_pstn) == 1)
	{
		$(avp(s:acc_caller_user)[*]) = $fU;
		$(avp(s:acc_caller_domain)[*]) = $avp(s:ip);
	}
	else if($avp(s:from_faxserver) != 1 && $avp(s:from_pbx) != 1 && $var(cf_loop) != 1)
	{
		# if coming from CF loop, it's already passed by header
		# for normal calls, set it using From
		$(avp(s:acc_caller_user)[*]) = $fU;
		$(avp(s:acc_caller_domain)[*]) = $fd;
	}
	$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
	$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);

	if($var(cf_loop) != 1)
	{
		$(avp(s:acc_state)[*]) = "call";
	}
	if($var(cf_loop) == 1 && $avp(s:cf_depth) >= [% kamailio.proxy.cf_depth_limit %])
	{
		xlog("L_WARN", "REJECT recursive call forward - [% logreq -%]\n");
		$(avp(s:announce_code)[*]) = 480;
		$(avp(s:announce_reason)[*]) = "Unavailable";
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_EARLY_REJECT);
		[% debug_dump('exit', 'ROUTE_INVITE') %]
		exit;
	}

	if($avp(s:from_pstn) != 1 && $var(proxylu_dst_callee) != 1)
	{
		route(ROUTE_LOAD_CALLER_PREF);
		if($avp(s:from_faxserver) != 1 && $avp(s:from_voicebox) != 1 && $var(cf_loop) != 1)
		{
			# set dialog for calls from subscriber
			dlg_manage();
		}
	}

	#!ifdef ENABLE_PBX
	if($xavp(caller_real_prefs[0]=>cloud_pbx) == 1 && uri =~ "^sip:\*[% sems.vsc.directed_pickup_code %]\*.+@")
	{
		route(ROUTE_DIRECTED_PICKUP);
	}
	#!endif

	# IP authorization
	if(
	   (!pv_isset("$xavp(caller_real_prefs[0]=>ignore_allowed_ips)") &&
	    !pv_isset("$xavp(caller_real_prefs[0]=>allowed_ips_grp)") &&
	    !pv_isset("$xavp(caller_real_prefs[0]=>man_allowed_ips_grp)")) ||
	   $avp(s:from_pstn) == 1 ||
	   $avp(s:from_faxserver) == 1 ||
	   $avp(s:from_voicebox) == 1 ||
	   $var(proxylu_dst_callee) == 1 ||
	   $var(cf_loop) == 1
	   )
	{
		xlog("L_INFO", "IP authorization for caller not provisioned, allow call - [% logreq -%]\n");
	}
	else if($xavp(caller_real_prefs[0]=>ignore_allowed_ips) == 1)
	{
		xlog("L_INFO", "IP authorization for caller disabled, allow call - [% logreq -%]\n");
	}
	else
	{
		$(avp(s:ipauth_id)[*]) = 0;
		if(!pv_isset("$xavp(caller_real_prefs[0]=>allowed_ips_grp)"))
		{
			$xavp(caller_real_prefs[0]=>allowed_ips_grp) = 0;
		}
		if(!pv_isset("$xavp(caller_real_prefs[0]=>man_allowed_ips_grp)"))
		{
			$xavp(caller_real_prefs[0]=>man_allowed_ips_grp) = 0;
		}

		avp_db_query("SELECT id FROM address WHERE ip_addr = INET_NTOA(INET_ATON('$(avp(s:ip){s.escape.common})') & (0xFFFFFFFF << 32 - mask & 0xFFFFFFFF)) and grp in ($xavp(caller_real_prefs[0]=>allowed_ips_grp), $xavp(caller_real_prefs[0]=>man_allowed_ips_grp))", "$avp(s:ipauth_id)");

		if($avp(s:ipauth_id) == 0)
		{
			xlog("L_WARN", "No ipauth id found for caller, block call - [% logreq -%]\n");

			$var(announce_handle) = "unauth_caller_ip";
			$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 403;
			$(avp(s:announce_reason)[*]) = "Unauthorized IP detected";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else
		{
			xlog("L_INFO", "Found ipauth id '$avp(s:ipauth_id)' for caller, call authorized on IP level - [% logreq -%]\n");
		}
	}

	$(avp(s:tmp)[*]) = $null;
	if($var(cf_loop) == 1)
	{
		xlog("L_INFO", "Use NPN '$avp(s:caller_cli_netprov)' as UPN for CF loop - [% logreq -%]\n");
		$(avp(s:caller_cli_userprov)[*]) = $avp(s:caller_cli_netprov);
		$(avp(s:caller_domain_userprov)[*]) = $avp(s:caller_domain_netprov);
	}
	else if($var(blind_transfer) == 1 || $var(is_replaces) == 1)
	{
		xlog("L_INFO", "Use NPN '$avp(s:caller_cli_netprov)' as UPN for PBX transfer - [% logreq -%]\n");
		$(avp(s:caller_cli_userprov)[*]) = $avp(s:caller_cli_netprov);
		$(avp(s:caller_domain_userprov)[*]) = $avp(s:caller_domain_netprov);
	}
	else if($var(proxylu_dst_callee) == 1)
	{
		xlog("L_INFO", "Use UPN '$avp(s:caller_cli_userprov)' and NPN '$avp(s:caller_cli_netprov)' from source proxy - [% logreq -%]\n");
	}
	else
	{
		$(avp(s:caller_cli_userprov)[*]) = $null;
		$(avp(s:caller_domain_userprov)[*]) = $null;

		# extract UPN
		if($avp(s:from_faxserver) == 1)
		{
			if(pv_isset("$xavp(caller_real_prefs[0]=>user_cli)"))
			{
				$(avp(s:caller_cli_userprov)[*]) = $xavp(caller_real_prefs[0]=>user_cli);
			}
			else if(pv_isset("$xavp(caller_real_prefs[0]=>cli)"))
			{
				$(avp(s:caller_cli_userprov)[*]) = $xavp(caller_real_prefs[0]=>cli);
			}
			else
			{
				$(avp(s:caller_cli_userprov)[*]) = $avp(s:acc_caller_user);
			}
			$(avp(s:caller_domain_userprov)[*]) = $avp(s:acc_caller_domain);
			# in case of calls from internal services, NPN==UPN
			if(pv_isset("$xavp(caller_real_prefs[0]=>cli)"))
			{
				$(avp(s:caller_cli_netprov)[*]) = $xavp(caller_real_prefs[0]=>cli);
			}
			else
			{
				$(avp(s:caller_cli_netprov)[*]) = $avp(s:acc_caller_user);
			}
			$(avp(s:caller_domain_netprov)[*]) = $avp(s:caller_domain_userprov);
		}
		else
		{
			if($avp(s:from_pstn) == 1)
			{
				$var(ccli_selector) = $xavp(caller_peer_prefs[0]=>inbound_upn);
			}
			else
			{
				$var(ccli_selector) = $xavp(caller_real_prefs[0]=>inbound_upn);
			}
			$var(ccli_desc) = "User-Provided CLI";
			route(ROUTE_GET_CALLER_CLI);
			$(avp(s:caller_cli_userprov)[*]) = $var(ccli_user);
			$(avp(s:caller_domain_userprov)[*]) = $var(ccli_domain);
		}
		# extract NPN
		if($avp(s:from_pstn) == 1)
		{
			$var(ccli_selector) = $xavp(caller_peer_prefs[0]=>inbound_npn);
			$var(ccli_desc) = "Network-Provided CLI";
			route(ROUTE_GET_CALLER_CLI);
			$(avp(s:caller_cli_netprov)[*]) = $var(ccli_user);
			$(avp(s:caller_domain_netprov)[*]) = $var(ccli_domain);
			$(avp(s:acc_caller_user)[*]) = $avp(s:caller_cli_netprov);
		}
		else if($avp(s:from_voicebox) == 1)
		{
			# in case of calls from internal services, NPN==UPN
			$(avp(s:caller_cli_netprov)[*]) = $avp(s:caller_cli_userprov);
			$(avp(s:caller_domain_netprov)[*]) = $avp(s:caller_domain_userprov);
		}
	}
	# extract UPRN
	# If it's a proxylu destination, the value is passed via
	# headers from the source.
	if($var(proxylu_dst_callee) != 1)
	{
		$(avp(s:forwarder_cli_userprov)[*]) = $null;
		$(avp(s:forwarder_domain_userprov)[*]) = $null;
		$var(ccli_user) = 0;
		$var(ccli_domain) = 0;
		if($avp(s:from_pstn) == 1)
		{
			$var(ccli_selector) = $xavp(caller_peer_prefs[0]=>inbound_uprn);
		}
		else
		{
			$var(ccli_selector) = $xavp(caller_real_prefs[0]=>inbound_uprn);
		}
		$var(ccli_desc) = "User-Provided Redirecting CLI";
		route(ROUTE_GET_FORWARDER_CLI);
		$(avp(s:forwarder_cli_userprov)[*]) = $var(ccli_user);
		$(avp(s:forwarder_domain_userprov)[*]) = $var(ccli_domain);
	}

	if($avp(s:from_pstn) == 1 &&
	   pv_isset("$xavp(caller_peer_prefs[0]=>rewrite_caller_in_dpid)"))
	{
		$var(dpid) = $xavp(caller_peer_prefs[0]=>rewrite_caller_in_dpid);
		$var(dpid_desc) = "caller-in peer";
		route(ROUTE_APPLY_CALLER_RWR);
	}
	else if($avp(s:from_pstn) != 1 &&
		pv_isset("$xavp(caller_real_prefs[0]=>rewrite_caller_in_dpid)"))
	{
		$var(dpid) = $xavp(caller_real_prefs[0]=>rewrite_caller_in_dpid);
		$var(dpid_desc) = "caller-in usr/domain";
		route(ROUTE_APPLY_CALLER_RWR);
	}

	if($avp(s:caller_cli_userprov) != $null && $avp(s:from_pstn) != 1 &&
	   $avp(s:from_faxserver) != 1 && $avp(s:from_voicebox) != 1 &&
	   $var(proxylu_dst_callee) != 1 && $avp(s:p_from_aa) != 1)
	{
		# Check UPN
		$var(ccli_desc) = "User-provided CLI";
		$var(userprov_cli) = $avp(s:caller_cli_userprov);
		$var(userprov_domain) = $avp(s:caller_domain_userprov);
		route(ROUTE_CHECK_USERPROV_CLI);
		$(avp(s:caller_cli_userprov)[*]) = $var(userprov_cli);
		$(avp(s:caller_domain_userprov)[*]) = $var(userprov_domain);
	}
	if($avp(s:forwarder_cli_userprov) != $null && $avp(s:from_pstn) != 1 &&
	   $avp(s:from_faxserver) != 1 && $avp(s:from_voicebox) != 1 &&
	   $var(proxylu_dst_callee) != 1 && $avp(s:p_from_aa) != 1 && $avp(s:forwarder_cli_userprov) != 0)
	{
		# Check UPRN
		$var(ccli_desc) = "User-provided Redirecting CLI";
		$var(userprov_cli) = $avp(s:forwarder_cli_userprov);
		$var(userprov_domain) = $avp(s:forwarder_domain_userprov);
		route(ROUTE_CHECK_USERPROV_CLI);
		$(avp(s:forwarder_cli_userprov)[*]) = $var(userprov_cli);
		$(avp(s:forwarder_domain_userprov)[*]) = $var(userprov_domain);
	}

	# in case of CF loops, it's already set at that point
	if($var(cf_loop) != 1)
	{
		if($avp(s:first_caller_cli_userprov) == $null)
		{
			$(avp(s:first_caller_cli_userprov)[*]) = $avp(s:caller_cli_userprov);
			$(avp(s:first_caller_domain_userprov)[*]) = $avp(s:caller_domain_userprov);

			xlog("L_NOTICE", "Setting '$avp(s:first_caller_cli_userprov)@$avp(s:first_caller_domain_userprov)' as initiating user-provided CLI - [% logreq -%]\n");
		}
		if($avp(s:first_caller_cli_netprov) == $null)
		{
			$(avp(s:first_caller_cli_netprov)[*]) = $avp(s:caller_cli_netprov);
			$(avp(s:first_caller_domain_netprov)[*]) = $avp(s:caller_domain_netprov);

			xlog("L_NOTICE", "Setting '$avp(s:first_caller_cli_netprov)@$avp(s:first_caller_domain_netprov)' as initiating network-provided CLI - [% logreq -%]\n");
		}
	}

	#!ifdef ENABLE_PBX
	if($var(is_replaces) == 1)
	{
		xlog("L_INFO", "Send BLF/SLA pickup request to PBX - [% logreq -%]\n");
		$var(to_pbx) = 1;
		$var(no_sbc) = 1;
		$var(pbx_app_name) = "sbc";

		if($var(is_replaces) == 1)
		{
			xlog("L_INFO", "Skip accounting for BLF/SLA pickup request - [% logreq -%]\n");
			$var(no_acc) = 1;
			resetflag(FLAG_ACC_FAILED);
			resetflag(FLAG_ACC_DB);
		}

		if(is_present_hf("P-To-Device"))
		{
			remove_hf("P-To-Device");
		}

		route(ROUTE_OUTBOUND);
	}
	#!endif
	route(ROUTE_FIND_CALLEE);
	[% debug_dump('end', 'ROUTE_INVITE') %]
}

#!ifdef ENABLE_PBX

########################################################################
# Request route to prepare for directed call pickup
########################################################################
route[ROUTE_BLF_PICKUP]
{
	[% debug_dump('start', 'ROUTE_BLF_PICKUP') %]
	$var(dlg_callid) = $(hdr(Replaces){s.select,0,;});
	$(avp(s:colpid)[*]) = $hdr(Replaces);
	avp_subst("$avp(s:colpid)", "/^[^;]+;//"); # remove callid
	$var(dlg_ftag) = $(avp(s:colpid){param.value,from-tag,;});
	$var(dlg_ttag) = $(avp(s:colpid){param.value,to-tag,;});

	route(ROUTE_PICKUP_SET_COLP);
	[% debug_dump('end', 'ROUTE_BLF_PICKUP') %]
}

########################################################################
# Request route to set COLP for directed/VSC and BLF call pickup
########################################################################
route[ROUTE_PICKUP_SET_COLP]
{
	[% debug_dump('start', 'ROUTE_PICKUP_SET_COLP') %]
	xlog("L_INFO", "BLF pickup, cid=$var(dlg_callid), ft=$var(dlg_ftag), tt=$var(dlg_ttag) - [% logreq -%]\n");

	pv_unset("$avp(s:colpid)");
	pv_unset("$avp(s:dlginfo)");
	pv_unset("$avp(s:colpid_ext)");
	pv_unset("$avp(s:colpid_name)");
	avp_db_query("select body from presentity where domain = '$(fd{s.escape.common})' and expires > unix_timestamp(now()) and body like '%call-id=\"$var(dlg_callid)\"%' and body like '%local-tag=\"$var(dlg_ftag)\"%' and body like '%remote-tag=\"$var(dlg_ttag)\"%' and body like '%direction=\"recipient\"%' and body like '%<state>early</state>%' order by received_time desc limit 1", "$avp(s:dlginfo)");
	if(pv_isset("$avp(s:dlginfo)"))
	{
		$xml(x=>doc) = $avp(s:dlginfo);
		$var(dlg_caller) = $xml(x=>xpath:/dlginfo:dialog-info/dlginfo:dialog/dlginfo:remote/dlginfo:identity/text());
		if($var(dlg_caller) != "")
		{
			# MT#12761: dlg_caller can potentially be a list of uris, so select first
			$var(tmp) = $(var(dlg_caller){s.select,0,,});
			$var(dlg_caller) = $var(tmp);

			xlog("L_NOTICE", "BLF pickup for initial caller '$var(dlg_caller)' - [% logreq -%]\n");
			avp_db_query("select vs1.pbx_extension, vp.value from provisioning.voip_subscribers vs1 left join provisioning.voip_subscribers vs2 on vs1.account_id = vs2.account_id left join provisioning.voip_domains vd on vs2.domain_id = vd.id left join kamailio.usr_preferences vp on vs1.uuid = vp.uuid and vp.attribute = 'display_name' where vs2.username = '$fU' and vd.domain = '$fd' and vp.username = '$(var(dlg_caller){uri.user})' and vp.domain = '$(var(dlg_caller){uri.host})';", "$avp(s:colpid_ext);$avp(s:colpid_name)");
			if($avp(s:colpid_ext) != $null)
			{
				if($avp(s:colpid_name) != $null)
				{
					$(avp(s:colpid)[*]) = "\"" + $avp(s:colpid_name) + "\" <sip:" + $avp(s:colpid_ext) + "@" + $fd + ">";
				}
				else
				{
					$(avp(s:colpid)[*]) = "<sip:" + $avp(s:colpid_ext) + "@" + $fd + ">";
				}
			}
			else
			{
				$(avp(s:caller_domain)[*]) = $fd;
				route(ROUTE_LOAD_CALLER_PREF);
				$var(dpid) = 0;
				if(pv_isset("$xavp(caller_real_prefs[0]=>rewrite_caller_out_dpid)"))
				{
					$var(dpid) = $xavp(caller_real_prefs[0]=>rewrite_caller_out_dpid);
				}

				# we try to set an alias number first to set the DID instead of primary number,
				# which might be pilot+ext
				avp_db_query("select alias_username from dbaliases where username='$(var(dlg_caller){uri.user})' and domain='$(var(dlg_caller){uri.host})' order by is_primary asc limit 1", "$avp(s:colpid_ext)");
				if($avp(s:colpid_ext) == $null)
				{
					$(avp(s:colpid_ext)[*]) = $(var(dlg_caller){uri.user});
					xlog("L_INFO", "No calling party number for BLF pickup found, use username '$avp(s:colpid_ext)' - [% logreq -%]\n");
				}
				else
				{
					xlog("L_INFO", "Calling party number '$avp(s:colpid_ext)' for BLF pickup found - [% logreq -%]\n");
				}

				xlog("L_INFO", "BLF pickup rewrite with dpid $var(dpid) - [% logreq -%]\n");
				if($var(dpid) != 0)
				{
					$var(dp_input) = $avp(s:colpid_ext);
					$var(dp_input_desc) = "picking up party";
					$var(dpid_desc) = "caller-out user";
					xlog("L_INFO", "Apply BLF pickup rewrite for '$var(dp_input)' - [% logreq -%]\n");
					if(!pv_isset("$(avp(s:callee_cloud_pbx_account_cli_list)[0])"))
					{
						# TODO MT#12761
						# set to dummy value to make dialplan not choke if this avp list is used
						# needs to be fixed in dialplan module directly
						$(avp(s:callee_cloud_pbx_account_cli_list)[*]) = "GFHFUJKHGhgfhjhkljhkhcfg";
					}
					if(route(ROUTE_APPLY_REWRITE_RULE))
					{
						xlog("L_INFO", "Applying BLF pickup rewrite successful, output is '$var(dp_user)' - [% logreq -%]\n");
						$(avp(s:colpid)[*]) = "<sip:" + $var(dp_user) + "@" + $(var(dlg_caller){uri.host}) + ">";
					}
					else
					{
						xlog("L_INFO", "Applying BLF pickup rewrite failed - [% logreq -%]\n");
						$(avp(s:colpid)[*]) = "<sip:" + $var(dp_input) + "@" + $(var(dlg_caller){uri.host}) + ">";
					}
				}
				else
				{
					$(avp(s:colpid)[*]) = "<sip:" + $avp(s:colpid_ext) + "@" + $(var(dlg_caller){uri.host}) + ">";
				}
			}
			xlog("L_INFO", "Setting BLF pickup identity '$avp(s:colpid)' - [% logreq -%]\n");
		}
	}
	[% debug_dump('end', 'ROUTE_PICKUP_SET_COLP') %]
}

########################################################################
# Request route to prepare for directed call pickup
########################################################################
route[ROUTE_DIRECTED_PICKUP]
{
	[% debug_dump('start', 'ROUTE_DIRECTED_PICKUP') %]
	# TODO: calculate length dynamically
	strip([% sems.vsc.directed_pickup_code.length + 2 %]);

	xlog("L_INFO", "Got pickup by VSC for target $rU@$rd - [% logreq -%]\n");

	pv_unset("$avp(s:dlgcallee_user)");
	pv_unset("$avp(s:dlgcallee_domain)");
	pv_unset("$avp(s:dlgcallee_contract_id)");
	avp_db_query("select vs.username,vd.domain,vs.account_id from provisioning.voip_subscribers vs left join provisioning.voip_domains vd on vs.domain_id = vd.id  where vs.account_id='$xavp(caller_real_prefs[0]=>account_id)' and pbx_extension='$(rU{s.escape.common})'", "$avp(s:dlgcallee_user);$avp(s:dlgcallee_domain);$avp(s:dlgcallee_contract_id)");
	if($avp(s:dlgcallee_user) != $null && $avp(s:dlgcallee_domain) != $null && $avp(s:dlgcallee_contract_id) != $null)
	{
		xlog("L_INFO", "Found callee '$avp(s:dlgcallee_user)@$avp(s:dlgcallee_domain)' by PBX extension lookup using '$rU@$rd' - [% logreq -%]\n");
		$rU = $avp(s:dlgcallee_user);
		$rd = $avp(s:dlgcallee_domain);
		pv_unset("$avp(s:dlgcallee_user)");
		pv_unset("$avp(s:dlgcallee_domain)");
	}
	else
	{
		pv_unset("$avp(s:dlgcallee_contract_id)");
		avp_db_query("select vs.account_id from provisioning.voip_subscribers vs left join provisioning.voip_domains vd on vs.domain_id = vd.id  where vs.account_id='$xavp(caller_real_prefs[0]=>account_id)' and vs.username='$(rU{s.escape.common})' and vd.domain='$(rd{s.escape.common})'", "$avp(s:dlgcallee_contract_id)");
		if($avp(s:dlgcallee_contract_id) == $null)
		{
			xlog("L_NOTICE", "Pickup attempt of $rU@$rd belonging to a different account than caller' - [% logreq -%]\n");
			$(avp(s:announce_code)[*]) = 404;
			$(avp(s:announce_reason)[*]) = "No call to pick up";
			$(avp(s:acc_state)[*]) = "call";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_ADD_CALLINFO_REPLY);
			t_newtran();
			t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
			[% debug_dump('exit', 'ROUTE_DIRECTED_PICKUP') %]
			exit;
		}
	}

	pv_unset("$avp(s:dlginfo)");
	# TODO: do we need limitation on certain pickup groups?
	avp_db_query("select body from presentity where username = '$(rU{s.escape.common})' and domain = '$(rd{s.escape.common})' and expires > unix_timestamp(now()) and body like '% direction=\"recipient\" %' and body like '%<state>early</state>%' order by received_time desc limit 1", "$avp(s:dlginfo)");
	if(pv_isset("$avp(s:dlginfo)"))
	{
		$xml(x=>doc) = $avp(s:dlginfo);
		$var(dlg_callid) = $xml(x=>xpath:/dlginfo:dialog-info/dlginfo:dialog[last()]/@call-id);
		$var(dlg_ftag) = $xml(x=>xpath:/dlginfo:dialog-info/dlginfo:dialog[last()]/@local-tag);
		$var(dlg_ttag) = $xml(x=>xpath:/dlginfo:dialog-info/dlginfo:dialog[last()]/@remote-tag);

		if($var(dlg_callid) == "" || $var(dlg_ftag) == "" || $var(dlg_ttag) == "")
		{
			xlog("L_NOTICE", "Incomplete call information for pending call to $rU@$rd with call-id '$var(dlg_callid)', from-tag '$var(dlg_ftag)' and to-tag '$var(dlg_ttag)' - [% logreq -%]\n");
			$(avp(s:announce_code)[*]) = 404;
			$(avp(s:announce_reason)[*]) = "No call to pick up";
			$(avp(s:acc_state)[*]) = "call";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_ADD_CALLINFO_REPLY);
			t_newtran();
			t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
			[% debug_dump('exit', 'ROUTE_DIRECTED_PICKUP') %]
			exit;
		}
		remove_hf("Replaces");
		append_hf("Replaces: $var(dlg_callid);to-tag=$var(dlg_ttag);from-tag=$var(dlg_ftag);early-only\r\n");
		$var(is_replaces) = 1;

		# prepare COLP identity
		route(ROUTE_PICKUP_SET_COLP);
	}
	else
	{
		xlog("L_NOTICE", "No pending call for $rU@$rd to pick up - [% logreq -%]\n");
		$(avp(s:announce_code)[*]) = 404;
		$(avp(s:announce_reason)[*]) = "No call to pick up";
		$(avp(s:acc_state)[*]) = "call";
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_ADD_CALLINFO_REPLY);
		t_newtran();
		t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
		[% debug_dump('exit', 'ROUTE_DIRECTED_PICKUP') %]
		exit;
	}
	[% debug_dump('end', 'ROUTE_DIRECTED_PICKUP') %]
}
#!endif

########################################################################
# Request route to apply dialplan transformations on UPN, NPN and UPRN
########################################################################
route[ROUTE_APPLY_CALLER_RWR]
{
	[% debug_dump('start', 'ROUTE_APPLY_CALLER_RWR') %]
	$var(dp_input) = $avp(s:caller_cli_userprov);
	$var(dp_input_desc) = "user-provided CLI";
	if(route(ROUTE_APPLY_REWRITE_RULE))
	{
		$(avp(s:caller_cli_userprov)[*]) = $var(dp_user);
	}

	if($avp(s:from_pstn) == 1)
	{
		$var(dp_input) = $avp(s:caller_cli_netprov);
		$var(dp_input_desc) = "network-provided CLI";
		if(route(ROUTE_APPLY_REWRITE_RULE))
		{
			$(avp(s:caller_cli_netprov)[*]) = $var(dp_user);
		}
	}

	if($avp(s:forwarder_cli_userprov) != 0)
	{
		$var(dp_input) = $avp(s:forwarder_cli_userprov);
		$var(dp_input_desc) = "user-provided Redirecting CLI";
		if(route(ROUTE_APPLY_REWRITE_RULE))
		{
			$(avp(s:forwarder_cli_userprov)[*]) = $var(dp_user);
		}
	}
	[% debug_dump('end', 'ROUTE_APPLY_CALLER_RWR') %]
}

########################################################################
# Request route to apply dialplan transformations on first-UPN, first-NPN and UPRN
########################################################################
route[ROUTE_APPLY_CALLER_RWR_FIRST]
{
	[% debug_dump('start', 'ROUTE_APPLY_CALLER_RWR_FIRST') %]
	$var(dp_input) = $var(caller_cli_userprov);
	$var(dp_input_desc) = "first user-provided CLI";
	if(route(ROUTE_APPLY_REWRITE_RULE))
	{
		$var(caller_cli_userprov) = $var(dp_user);
	}

	$var(dp_input) = $var(caller_cli_netprov);
	$var(dp_input_desc) = "first network-provided CLI";
	if(route(ROUTE_APPLY_REWRITE_RULE))
	{
		$var(caller_cli_netprov) = $var(dp_user);
	}

	if($avp(s:forwarder_cli_userprov) != 0)
	{
		$var(dp_input) = $avp(s:forwarder_cli_userprov);
		$var(dp_input_desc) = "user-provided Redirecting CLI";
		if(route(ROUTE_APPLY_REWRITE_RULE))
		{
			$(avp(s:forwarder_cli_userprov)[*]) = $var(dp_user);
		}
	}
	[% debug_dump('end', 'ROUTE_APPLY_CALLER_RWR_FIRST') %]
}

########################################################################
# Request route to apply dialplan transformations
# in:  $var(dpid), $var(dpid_desc), $var(dp_input), $var(dp_input_desc)
# out: $var(dp_user)
########################################################################
route[ROUTE_APPLY_REWRITE_RULE]
{
	[% debug_dump('start', 'ROUTE_APPLY_REWRITE_RULE') %]
	xlog("L_INFO", "Applying $var(dpid_desc) rewrite rules on $var(dp_input_desc) using dpid '$var(dpid)' - [% logreq -%]\n");
	$var(dp_user) = 0;
	if(dp_translate("$var(dpid)", "$var(dp_input)/$var(dp_user)"))
	{
		xlog("L_NOTICE", "Rewriting $var(dp_input_desc) '$var(dp_input)' to '$var(dp_user)' - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_APPLY_REWRITE_RULE') %]
		return(1);
	}
	else
	{
		xlog("L_INFO", "No matching rewrite rules for '$var(dp_input)' found - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_APPLY_REWRITE_RULE') %]
		return(0);
	}
	$var(dpid) = 0;
	[% debug_dump('end', 'ROUTE_APPLY_REWRITE_RULE') %]
}

########################################################################
# Request route to extract forwarder CLI
# in:  $var(ccli_selector), $var(ccli_desc)
# out: $var(ccli_user), $var(ccli_domain)
########################################################################
route[ROUTE_GET_FORWARDER_CLI]
{
	[% debug_dump('start', 'ROUTE_GET_FORWARDER_CLI') %]
	if($var(ccli_selector) == 0)
	{
		$var(ccli_selector) = "";
	}
	if($var(cf_loop) == 1)
	{
		if($var(ccli_selector) == "npn" || $var(ccli_selector) == "npn_diversion")
		{
			$var(ccli_user) = $avp(s:caller_cli_netprov);
			$var(ccli_domain) = $avp(s:caller_domain_netprov);
			xlog("L_NOTICE", "$var(ccli_desc) '$var(ccli_user)' taken from NPN - [% logreq -%]\n");
		}
	}
	else
	{
		if(($var(ccli_selector) == "diversion" || $var(ccli_selector) == "npn_diversion")
			&& is_present_hf("Diversion"))
		{
			$var(ccli_user) = $(di{uri.user});
			$var(ccli_domain) = $(di{uri.host});
			remove_hf("Diversion");
			xlog("L_NOTICE", "$var(ccli_desc) '$var(ccli_user)' taken from Diversion - [% logreq -%]\n");
		}
	}
	[% debug_dump('end', 'ROUTE_GET_FORWARDER_CLI') %]
}

########################################################################
# Request route to check user-provided CLI
# in:   $var(userprov_cli), $var(userprov_domain)
# out: $var(userprov_cli), $var(userprov_domain)
# uses helper route ROUTE_CHECK_CLI_ALLOWED
########################################################################
route[ROUTE_CHECK_USERPROV_CLI]
{
	[% debug_dump('start', 'ROUTE_CHECK_USERPROV_CLI') %]
	if($xavp(caller_real_prefs[0]=>extension_in_npn) == 1)
	{
		xlog("L_INFO", "Checking $var(ccli_desc) against subscriber aliases - [% logreq -%]\n");
		if(avp_check("$var(userprov_cli)", "fm/$avp(s:caller_cli_netprov)/g"))
		{
			xlog("L_INFO", "$var(ccli_desc) '$var(userprov_cli)' accepted - matches E.164 number '$avp(s:caller_cli_netprov)' - [% logreq -%]\n");
			$(avp(s:caller_cli_netprov)[*]) = $var(userprov_cli);
			#$(avp(s:caller_domain_netprov)[*]) = $avp(s:caller_domain_userprov);
		}
		else
		{
			avp_delete("$avp(s:caller_base_cli)/g");
			avp_db_query("select d.alias_username from dbaliases d, subscriber s where s.username = d.username and s.domain = d.domain and s.uuid='$avp(s:caller_uuid)' and d.alias_username like concat(left('$(var(userprov_cli){s.escape.common})', 7), '%') and instr('$(var(userprov_cli){s.escape.common})', d.alias_username)=1 order by length(d.alias_username) desc limit 1", "$avp(s:caller_base_cli)");
			if($avp(s:caller_base_cli) != $null)
			{
				xlog("L_INFO", "$var(ccli_desc) '$var(userprov_cli)' accepted - matches alias number '$avp(s:caller_base_cli)' - [% logreq -%]\n");
				$(avp(s:caller_cli_netprov)[*]) = $var(userprov_cli);
				#$(avp(s:caller_domain_netprov)[*]) = $avp(s:caller_domain_userprov);
			}
			else
			{
				route(ROUTE_CHECK_CLI_ALLOWED);
			}
		}
	}
	else
	{
		route(ROUTE_CHECK_CLI_ALLOWED);
	}
	[% debug_dump('end', 'ROUTE_CHECK_USERPROV_CLI') %]
}
########################################################################
# Request route 'invite-check-cli-allowed'
########################################################################
route[ROUTE_CHECK_CLI_ALLOWED]
{
	[% debug_dump('start', 'ROUTE_CHECK_CLI_ALLOWED') %]
	xlog("L_INFO", "Checking $var(ccli_desc) against allowed CLIs - [% logreq -%]\n");
	if(pv_isset("$xavp(caller_usr_prefs[0]=>allowed_clis_reject_policy)"))
	{
		$(avp(s:allowed_clis_reject_policy)[*]) = $xavp(caller_usr_prefs[0]=>allowed_clis_reject_policy);
	}
	else if(pv_isset("$xavp(caller_contract_prefs[0]=>allowed_clis_reject_policy)"))
	{
		$(avp(s:allowed_clis_reject_policy)[*]) = $xavp(caller_contract_prefs[0]=>allowed_clis_reject_policy);
	}
	else if(pv_isset("$xavp(caller_dom_prefs[0]=>allowed_clis_reject_policy)"))
	{
		$(avp(s:allowed_clis_reject_policy)[*]) = $xavp(caller_dom_prefs[0]=>allowed_clis_reject_policy);
	}
	if(avp_check("$var(userprov_cli)", "fm/$xavp(caller_real_prefs[0]=>allowed_clis[*])/g"))
	{
		xlog("L_NOTICE", "$var(ccli_desc) '$var(userprov_cli)' accepted (matched user preference) - [% logreq -%]\n");
	}
	else if(avp_check("$var(userprov_cli)", "fm/$xavp(caller_contract_prefs[0]=>allowed_clis[*])/g"))
	{
		xlog("L_NOTICE", "$var(ccli_desc) '$var(userprov_cli)' accepted (matched contract preference) - [% logreq -%]\n");
	}
	else if($avp(s:allowed_clis_reject_policy) == "reject")
	{
		xlog("L_NOTICE", "$var(ccli_desc) '$var(userprov_cli)' rejected, block call - [% logreq -%]\n");
		$(avp(s:announce_code)[*]) = 403;
		$(avp(s:announce_reason)[*]) = "Forbidden";
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_EARLY_REJECT);
		[% debug_dump('exit', 'ROUTE_CHECK_CLI_ALLOWED') %]
		exit;
	}
	else
	# if($avp(s:allowed_clis_reject_policy) == "override_by_usernpn" ||
	#	$avp(s:allowed_clis_reject_policy) == "override_by_clir")
	{
		if(pv_isset("$xavp(caller_real_prefs[0]=>user_cli)"))
		{
			xlog("L_NOTICE", "$var(ccli_desc) '$var(userprov_cli)' rejected, using provisioned user-provided CLI '$xavp(caller_real_prefs[0]=>user_cli)' - [% logreq -%]\n");
			$var(userprov_cli) = $xavp(caller_real_prefs[0]=>user_cli);
			$var(userprov_domain) = $avp(s:caller_domain_netprov);
		}
		else
		{
			xlog("L_NOTICE", "$var(ccli_desc) '$var(userprov_cli)' rejected, using network-provided CLI '$avp(s:caller_cli_netprov)' - [% logreq -%]\n");
			$var(userprov_cli) = $avp(s:caller_cli_netprov);
			$var(userprov_domain) = $avp(s:caller_domain_netprov);
		}
		if($avp(s:allowed_clis_reject_policy) == "override_by_clir")
		{
			$(avp(s:caller_clir)[*]) = 1;
			$(avp(s:override_caller_clir)[*]) = 1;
		}
	}
	[% debug_dump('end', 'ROUTE_CHECK_CLI_ALLOWED') %]
}

########################################################################
# Request route 'invite-find-caller'
########################################################################
route[ROUTE_FIND_CALLER]
{
	[% debug_dump('start', 'ROUTE_FIND_CALLER') %]
	$(avp(s:tmpfaxgw)[*]) = 0;
	if($fu == "sip:[% reminder.sip_fromuser %]@[% reminder.sip_fromdomain %]")
	{
		$(avp(s:tmpfaxgw)[*]) = 0; # reminder
	}
	else if($var(sendfax) == 1)
	{
		$(avp(s:tmpfaxgw)[*]) = 4; # faxserver
	}
	else
	{
		# only check for other faxserver if not coming from asterisk
		# do extra check in query that call doesn't come from sems/click2dial
		avp_db_query("select setid from dispatcher where setid=4 and destination='sip:$(avp(s:ip){s.escape.common}):$(avp(s:port){s.escape.common})'", "$avp(s:tmpfaxgw)");
	}
	$(avp(s:app_server_params)[*]) = $null;
	if($var(proxylu_dst_callee) == 1)
	{
		$(avp(s:caller_uuid)[*]) = "0";
		$(avp(s:caller_domain)[*]) = $fd;
		xlog("L_INFO", "Call from other proxy - [% logreq -%]\n");
		$var(no_auth) = 1;
		$xavp(caller_real_prefs=>from_other_proxy) = 1;

		$(avp(s:first_caller_cli_userprov)[*]) = $(hdr(P-First-Caller-UPN){uri.user});
		$(avp(s:first_caller_domain_userprov)[*]) = $(hdr(P-First-Caller-UPN){uri.domain});
		$(avp(s:first_caller_cli_netprov)[*]) = $(hdr(P-First-Caller-NPN){uri.user});
		$(avp(s:first_caller_domain_netprov)[*]) = $(hdr(P-First-Caller-NPN){uri.domain});
		$(avp(s:forwarder_cli_userprov)[*]) = $(hdr(P-First-Forwarder-UPN){uri.user});
		$(avp(s:forwarder_domain_userprov)[*]) = $(hdr(P-First-Forwarder-UPN){uri.domain});
		$(avp(s:caller_cli_userprov)[*]) = $(hdr(P-Caller-UPN){uri.user});
		$(avp(s:caller_domain_userprov)[*]) = $(hdr(P-Caller-UPN){uri.domain});
		$(avp(s:caller_cli_netprov)[*]) = $(hdr(P-Caller-NPN){uri.user});
		$(avp(s:caller_domain_netprov)[*]) = $(hdr(P-Caller-NPN){uri.domain});
		$(avp(s:first_caller_ipv46_for_rtpproxy)[*]) = $hdr(P-First-V46-RTP);
		$(avp(s:first_caller_use_rtpproxy)[*]) = $hdr(P-First-RTP);
		$(avp(s:first_caller_transport_protocol)[*]) = $hdr(P-First-RTP-Transport);
		$(avp(s:caller_clir)[*]) = $hdr(P-Caller-CLIR);
		$(avp(s:first_caller_ua_header_mode)[*]) = $hdr(P-First-Caller-UA-Mode);
		$(avp(s:first_caller_ua_header_replace)[*]) = $hdr(P-First-Caller-UA-Replace);
		$(avp(s:proxylu_from_pstn)[*]) = $hdr(P-Caller-From-PSTN);
		if($avp(s:proxylu_from_pstn) > 0)
		{
			xlog("L_INFO", "Call from PSTN via other proxy - [% logreq -%]\n");
			$(avp(s:lcr_flags)[*]) = $avp(s:proxylu_from_pstn);
			$(avp(s:from_pstn)[*]) = 1;
			route(ROUTE_CLEAR_PEER_IN_PREF);
			route(ROUTE_LOAD_PEER_IN_PREF);
		}

		$xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer) = $(hdr(P-Caller-PeerInfo){re.subst,/^([a-z]_).*$/\1/});
		if($xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer) == $hdr(P-Caller-PeerInfo))
		{
			pv_unset("$xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer)");
		}
		$xavp(caller_real_prefs[0]=>peer_auth_user) = $(hdr(P-Caller-PeerInfo){re.subst,/^[0-1](;([^;]+);.*)?$/\2/});
		if($xavp(caller_real_prefs[0]=>peer_auth_user) == $hdr(P-Caller-PeerInfo))
		{
			pv_unset("$xavp(caller_real_prefs[0]=>caller_peer_auth_user)");
		}
		$xavp(caller_real_prefs[0]=>peer_auth_realm) = $(hdr(P-Caller-PeerInfo){re.subst,/^[0-1](;[^;]+;([^;]+);.*)?$/\2/});
		if($xavp(caller_real_prefs[0]=>peer_auth_realm) == $hdr(P-Caller-PeerInfo))
		{
			pv_unset("$xavp(caller_real_prefs[0]=>caller_peer_auth_realm)");
		}
		$xavp(caller_real_prefs[0]=>peer_auth_pass) = $(hdr(P-Caller-PeerInfo){re.subst,/^[0-1](;[^;]+;[^;]+;([^;]+).*)?$/\2/});
		if($xavp(caller_real_prefs[0]=>peer_auth_pass) == $hdr(P-Caller-PeerInfo))
		{
			pv_unset("$xavp(caller_real_prefs[0]=>caller_peer_auth_pass)");
		}
		$xavp(caller_peer_prefs[0]=>find_subscriber_by_uuid) = $hdr(P-Peer-By-Uuid);

		route(ROUTE_CLEAR_PROXYLU_HEADERS);
	}
	#!ifdef ENABLE_PBX
	if(ds_is_from_list("5") && is_present_hf("P-To-Device"))
	{
		xlog("L_NOTICE", "Call from hosted PBX server - [% logreq -%]\n");

		if(is_present_hf("P-NGCP-Orig-Dialed"))
		{
			$(avp(s:acc_callee_dialed)[*]) = $hdr(P-NGCP-Orig-Dialed);
			remove_hf("P-NGCP-Orig-Dialed");
		}

		$(avp(s:from_pbx)[*]) = 1;

		if($hdr(P-To-Device) == "1")
		{
			$(avp(s:p_to_device)[*]) = 1;
			remove_hf("P-To-Device");

			xlog("L_INFO", "Skip accounting for call from PBX to device - [% logreq -%]\n");
			$var(no_acc) = 1;
			resetflag(FLAG_ACC_FAILED);
			resetflag(FLAG_ACC_DB);
		}
		else if($hdr(P-To-Group) == "1")
		{
			$(avp(s:p_to_group)[*]) = 1;
			remove_hf("P-To-Group");
			xlog("L_INFO", "Skip accounting for call from PBX to group member - [% logreq -%]\n");
			$var(no_acc) = 1;
			resetflag(FLAG_ACC_FAILED);
			resetflag(FLAG_ACC_DB);
			$var(group_uuid) = $hdr(P-Callee-UUID);

			if(is_present_hf("P-To-Group-Policy"))
			{
				$var(orig_policy) = $hdr(P-To-Group-Policy);
				if($var(orig_policy) == "circular")
				{
					xlog("L_INFO", "Increase circular group idx for group uuid '$var(group_uuid)' [% logreq -%]\n");
					# lua increases the internal index by one, so next call to the group will reorder group
					# list to start with next destination first
					if (!lua_run("ngcp_pbx_group_circular_incindex", "$var(group_uuid)"))
					{
						route(ROUTE_ADD_CALLINFO_REPLY);
						sl_send_reply("500", "Internal Error");
						[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
						exit;
					}
				}
			}
		}
		else if($hdr(P-From-AA) == "1")
		{
			$(avp(s:p_from_aa)[*]) = 1;
			remove_hf("P-From-AA");
			if(is_present_hf("P-AA-Account"))
			{
				$var(fU) = $(hdr(P-AA-Account){uri.user}{s.trim});
				$var(fd) = $(hdr(P-AA-Account){uri.domain}{s.trim});
				remove_hf("P-AA-Account");
			}
		}

		if(is_present_hf("Referred-By"))
		{
			$(avp(s:tmp)[*]) = $null;
			$(avp(s:tmp_domain)[*]) = $null;
			$(avp(s:caller_uuid)[*]) = $null;
			$var(tmprefby) = $hdr(Referred-By);
			remove_hf("Referred-By");
			$var(fU) = $(var(tmprefby){nameaddr.uri}{uri.user});
			$var(fd) = $(var(tmprefby){nameaddr.uri}{uri.host});
			xlog("L_NOTICE", "Use Referred-By URI '$var(fU)@$var(fd)' for blind transfer caller - [% logreq -%]");
			$var(blind_transfer) = 1;
			avp_db_query("select uuid, username, domain from subscriber where username='$(var(fU){s.escape.common})' and domain='$(var(fd){s.escape.common})'", "$avp(s:caller_uuid);$avp(s:tmp);$avp(s:tmp_domain)");
			if($avp(s:caller_uuid) != $null)
			{
				$(avp(s:acc_caller_user)[*]) = $avp(s:tmp);
				$(avp(s:acc_caller_domain)[*]) = $avp(s:tmp_domain);
				xlog("L_INFO", "Setting From info for PBX call to '$avp(s:tmp)@$avp(s:tmp_domain)' - [% logreq -%]\n");

				if(is_method("REFER"))
				{
					# clear transfer initiator's dialogs from the list
					$avp(s:refcid) = $ci;
					avp_subst("$avp(s:refcid)", "/_pbx\-1.*$//"); # remove suffix from callid
					xlog("L_INFO", "Remove dlg list for call-id '$avp(s:refcid)' and caller uuid '$avp(s:caller_uuid)' - [% logreq -%]\n");
					lua_run("pop_dlg_list", "$avp(s:refcid)", "callqueue:$avp(s:caller_uuid)");

					# find the huntgroup the transfer initiator belongs to and clear dialog from the list (for queue tracking)
					avp_db_query("select uuid,username from usr_preferences where attribute='cloud_pbx_hunt_group' and value='sip:$avp(s:tmp)@$avp(s:tmp_domain)'", "$avp(s:caller_hg_uuid);$avp(s:caller_hg_username)");
					while(pv_isset("$(avp(s:caller_hg_uuid)[0])") && pv_isset("$(avp(s:caller_hg_username)[0])"))
					{
						xlog("L_INFO", "Remove dlg list for call-id '$avp(s:refcid)' and huntgroup $avp(s:caller_hg_username) with uuid '$avp(s:caller_hg_uuid)' - [% logreq -%]\n");
						lua_run("pop_dlg_list", "$avp(s:refcid)", "callqueue:$avp(s:caller_hg_uuid)");
						pv_unset("$(avp(s:caller_hg_uuid)[0])");
						pv_unset("$(avp(s:caller_hg_username)[0])");
					}
				}
			}
			# we temporarily load prefs of referrer to get the rewrite rules
			if (!lua_run("ngcp_caller_usr_load", "$avp(s:caller_uuid)", "$var(fd)"))
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_FIND_CALLER') %]
				exit;
			}
			$var(referrer_callee_in_dpid) = $xavp(caller_real_prefs[0]=>rewrite_callee_in_dpid);
			$xavp(referrer_real_prefs=>ac) = $xavp(caller_real_prefs[0]=>ac);
			$xavp(referrer_real_prefs[0]=>cc) = $xavp(caller_real_prefs[0]=>cc);
			$xavp(referrer_real_prefs[0]=>emergency_prefix) = $xavp(caller_real_prefs[0]=>emergency_prefix);
			$xavp(referrer_real_prefs[0]=>emergency_suffix) = $xavp(caller_real_prefs[0]=>emergency_suffix);
			$xavp(referrer_real_prefs[0]=>emergency_cli) = $xavp(caller_real_prefs[0]=>emergency_cli);
			$xavp(referrer_real_prefs[0]=>cloud_pbx_base_cli) = $xavp(caller_real_prefs[0]=>cloud_pbx_base_cli);
			$xavp(referrer_real_prefs[0]=>cloud_pbx_ext) = $xavp(caller_real_prefs[0]=>cloud_pbx_ext);
			$xavp(referrer_real_prefs[0]=>cloud_pbx_account_cli_list) = $avp(s:caller_cloud_pbx_account_cli_list);
		}

		if(is_present_hf("P-Peer-ID"))
		{
			xlog("L_NOTICE", "Call from PSTN via PBX - [% logreq -%]\n");
			$(avp(s:lcr_flags)[*]) = $hdr(P-Peer-ID);
			remove_hf("P-Peer-ID");
			$(avp(s:from_pstn)[*]) = 1;

			#xlog("L_INFO", "Skip accounting for PBX blind transfer leg - [% logreq -%]\n");
			#$var(no_acc) = 1;
			#resetflag(FLAG_ACC_DB);
			#resetflag(FLAG_ACC_FAILED);
		}
		else if(is_present_hf("P-Faxserver-ID"))
		{
			xlog("L_NOTICE", "Call from Faxserver via PBX - [% logreq -%]\n");
			$(avp(s:tmpfaxgw)[*]) = $hdr(P-Faxserver-ID);
			remove_hf("P-Faxserver-ID");

			#xlog("L_INFO", "Skip accounting for PBX blind transfer leg - [% logreq -%]\n");
			#$var(no_acc) = 1;
			#resetflag(FLAG_ACC_DB);
			#resetflag(FLAG_ACC_FAILED);
		}
		else if(is_present_hf("P-Voicebox-ID"))
		{
			xlog("L_NOTICE", "Call from Voicebox via PBX - [% logreq -%]\n");
			$(avp(s:from_voicebox)[*]) = $hdr(P-Voicebox-ID);
			remove_hf("P-Voicebox-ID");

			#xlog("L_INFO", "Skip accounting for PBX blind transfer leg - [% logreq -%]\n");
			#$var(no_acc) = 1;
			#resetflag(FLAG_ACC_DB);
			#resetflag(FLAG_ACC_FAILED);
		}
		else
		{
			$(avp(s:tmp)[*]) = $null;
			$(avp(s:tmp_domain)[*]) = $null;
			$(avp(s:caller_uuid)[*]) = $null;

			if($avp(s:p_from_aa) != 1)
			{
				$var(fU) = $fU;
				$var(fd) = $fd;
			}

			xlog("L_INFO", "PBX caller is '$var(fU)@$var(fd)' - [% logreq -%]\n");
			avp_db_query("select s.uuid, s.username, s.domain from subscriber s, dbaliases d where d.alias_username like concat(left('$(var(fU){s.escape.common})', 7), '%') and instr('$(var(fU){s.escape.common})', d.alias_username)=1 and d.username = s.username and d.domain = s.domain order by length(alias_username) desc limit 1", "$avp(s:caller_uuid);$avp(s:tmp);$avp(s:tmp_domain)");
			if($avp(s:caller_uuid) != $null)
			{
				xlog("L_NOTICE", "Found aliased caller for call from PBX - [% logreq -%]\n");
				$(avp(s:acc_caller_user)[*]) = $avp(s:tmp);
				$(avp(s:acc_caller_domain)[*]) = $avp(s:tmp_domain);
				xlog("L_INFO", "Setting From info for PBX call to '$avp(s:tmp)@$avp(s:tmp_domain)' - [% logreq -%]\n");
			}
			else
			{
				xlog("L_NOTICE", "Found NO aliased caller for call from PBX, checking From/Referred-By '$var(fU)@$var(fd)' - [% logreq -%]\n");
				avp_db_query("select uuid, username, domain from subscriber where username='$(var(fU){s.escape.common})' and domain='$(var(fd){s.escape.common})'", "$avp(s:caller_uuid);$avp(s:tmp);$avp(s:tmp_domain)");
				if($avp(s:caller_uuid) != $null)
				{
					$(avp(s:acc_caller_user)[*]) = $fU;
					$(avp(s:acc_caller_domain)[*]) = $fd;
					xlog("L_INFO", "Setting From info for PBX call to '$avp(s:tmp)@$avp(s:tmp_domain)' - [% logreq -%]\n");
				}
				else
				{
					xlog("L_INFO", "Unknown caller in call from PBX - [% logreq -%]\n");
				}
			}
			$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
			$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
			if(is_present_hf("P-Caller-CLIR"))
			{
				$(avp(s:caller_clir)[*]) = $hdr(P-Caller-CLIR);
				remove_hf("P-Caller-CLIR");
			}
		}

		#Dialog handling for incoming request from cloud PBX server
		if (!lua_run("set_dlg_profile", "$ci", "total"))
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_FIND_CALLER') %]
			exit;
		}
		xlog("L_INFO", "Dialog set mark TOTAL - [% logreq -%]\n");

		# TODO: do we need to mark pbx calls here?
		#lua_run("set_dlg_profile", "$ci", "peer:pbx");
		#xlog("L_INFO", "Dialog set mark peer to pbx - [% logreq -%]\n");
	}
	#!endif
	if($avp(s:from_pstn) == 1 || from_any_gw($avp(s:ip), $avp(s:protoid)))
	{
		$(avp(s:caller_uuid)[*]) = "0";

		xlog("L_NOTICE", "Call from PSTN - [% logreq -%]\n");
		$var(no_auth) = 1;
		$(avp(s:from_pstn)[*]) = 1;
		if($avp(s:lcr_flags) != $null && $avp(s:lcr_flags) != 0)
		{
			route(ROUTE_CLEAR_PEER_IN_PREF);
			route(ROUTE_LOAD_PEER_IN_PREF);
		}
	}
	else if(ds_is_from_list("3") && is_present_hf("P-CF-Depth"))
	{
		xlog("L_NOTICE", "Internal CF loop - [% logreq -%]\n");
		$var(cf_loop) = 1;
		$(avp(s:caller_uuid)[*]) = $hdr(P-Caller-UUID);
		$(avp(s:first_caller_cli_userprov)[*]) = $hdr(P-First-Caller-UPN);
		$(avp(s:first_caller_cli_netprov)[*]) = $hdr(P-First-Caller-NPN);
		$(avp(s:first_caller_domain_userprov)[*]) = $hdr(P-First-Caller-UPD);
		$(avp(s:first_caller_domain_netprov)[*]) = $hdr(P-First-Caller-NPD);
		$(avp(s:acc_caller_user)[*]) = $hdr(P-Acc-Caller-User);
		$(avp(s:acc_caller_domain)[*]) = $hdr(P-Acc-Caller-Domain);
		$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
		$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
		$(avp(s:acc_state)[*]) = $hdr(P-Acc-State);
		$(avp(s:cf_from_pstn)[*]) = $hdr(P-From-Peer);
		$(avp(s:first_caller_ipv46_for_rtpproxy)[*]) = $hdr(P-First-V46-RTP);
		$(avp(s:first_caller_use_rtpproxy)[*]) = $hdr(P-First-RTP);
		$(avp(s:first_caller_transport_protocol)[*]) = $hdr(P-First-RTP-Transport);
		$(avp(s:first_caller_clir)[*]) = $hdr(P-First-Caller-CLIR);
		$(avp(s:cf_depth)[*]) = $hdr(P-CF-Depth);
		$(avp(s:first_caller_ua_header_mode)[*]) = $hdr(P-First-Caller-UA-Mode);
		$(avp(s:first_caller_ua_header_replace)[*]) = $hdr(P-First-Caller-UA-Replace);
		if($var(cf_loop) == 1 && is_present_hf("P-First-Caller-Cloud-PBX"))
		{
			$(avp(s:first_caller_pbx_account_id)[*]) = $hdr(P-First-Caller-Cloud-PBX);
		}
		if($hdr(P-CF-Loop-Count) != $null)
		{
			$(avp(s:cf_loop_counter)[*]) = $hdr(P-CF-Loop-Count);
		}
		if($hdr(P-HIH-Cause) != $null)
		{
			$(avp(s:hih_cause)[*]) = $hdr(P-HIH-Cause);
		}
		$(avp(s:orig_callee_dialed)[*]) = $hdr(P-Orig-Callee-Dialed);
		remove_hf("P-Orig-Callee-Dialed");
		remove_hf("P-Caller-UUID");
		remove_hf("P-First-Caller-UPN");
		remove_hf("P-First-Caller-NPN");
		remove_hf("P-First-Caller-UPD");
		remove_hf("P-First-Caller-NPD");
		remove_hf("P-Acc-Caller-User");
		remove_hf("P-Acc-Caller-Domain");
		remove_hf("P-Acc-State");
		remove_hf("P-From-Peer");
		remove_hf("P-First-V46-RTP");
		remove_hf("P-First-RTP");
		remove_hf("P-First-RTP-Transport");
		remove_hf("P-First-Caller-CLIR");
		remove_hf("P-CF-Depth");
		remove_hf("P-First-Caller-UA-Mode");
		remove_hf("P-First-Caller-UA-Replace");
		remove_hf("P-First-Caller-Cloud-PBX");
		remove_hf("P-CF-Loop-Count");
		remove_hf("P-HIH-Cause");
		if(is_present_hf("P-First-Caller-RTP-Interface"))
		{
			$(avp(s:first_caller_rtp_interface)[*]) = $hdr(P-First-Caller-RTP-Interface);
			remove_hf("P-First-Caller-RTP-Interface");
		}
		if(is_present_hf("P-First-Caller-RTP-Interface-Source"))
		{
			$(avp(s:first_caller_rtp_interface_source)[*]) = $hdr(P-First-Caller-RTP-Interface-Source);
			remove_hf("P-First-Caller-RTP-Interface-Source");
		}
		if($rd =~ "^.+\.local$")
		{
			# keep external and account ids on forward to fax2mail and voicemail
			# we fake loading account_id as callee preference
			$var(callee_ext_contract_id) = $hdr(P-Callee-Ext-Contr-ID);
			$var(callee_ext_subscriber_id) = $hdr(P-Callee-Ext-Subs-ID);
			$var(callee_account_id) = $hdr(P-Callee-Account-ID);
			remove_hf("P-Callee-Ext-Subs-ID");
			remove_hf("P-Callee-Ext-Contr-ID");
			remove_hf("P-Callee-Account-ID");
		}
	}
	else if($avp(s:tmpfaxgw) == 4)
	{
		xlog("L_NOTICE", "Call from Faxserver - [% logreq -%]\n");
		$var(no_auth) = 1;
		$(avp(s:from_faxserver)[*]) = 1;
		$var(from_local_endpoint) = 1;
		$(avp(s:tmp)[*]) = 0;
		$(avp(s:tmp_domain)[*]) = 0;

		if($var(sendfax) == 1)
		{
			# iaxmodem setup
			$var(fU) = $(fn{re.subst,/^\"?([^\"]*)\"?$/\1/});
		}
		else
		{
			# dialogic/patton setup
			$var(fU) = $(fU{re.subst,/^(\+|00)?(.+)$/\2/});
		}

		xlog("L_INFO", "Faxserver caller is '$var(fU)' - [% logreq -%]\n");
		avp_db_query("select s.uuid, s.username, s.domain from subscriber s, dbaliases d where d.alias_username like concat(left('$(var(fU){s.escape.common})', 7), '%') and instr('$(var(fU){s.escape.common})', d.alias_username)=1 and d.username = s.username and d.domain = s.domain order by length(alias_username) desc limit 1", "$avp(s:caller_uuid);$avp(s:tmp);$avp(s:tmp_domain)");
		if($avp(s:caller_uuid) == $null)
		{
			xlog("L_WARN", "Unknown caller in call from Faxserver - [% logreq -%]\n");
			$(avp(s:announce_code)[*]) = 403;
			$(avp(s:announce_reason)[*]) = "Unknown Faxserver caller";
			$(avp(s:acc_state)[*]) = "call";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_ADD_CALLINFO_REPLY);
			t_newtran();
			t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
			[% debug_dump('exit', 'ROUTE_FIND_CALLER') %]
			exit;
		}
		else
		{
			$(avp(s:acc_caller_user)[*]) = $avp(s:tmp);
			$(avp(s:acc_caller_domain)[*]) = $avp(s:tmp_domain);
			$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
			$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
			$rd = $avp(s:acc_caller_domain);
			xlog("L_INFO", "Setting From info for Faxserver call to '$avp(s:tmp)@$avp(s:tmp_domain)' - [% logreq -%]\n");
		}

		#Dialog handling for incoming request from Faxserver
		dlg_manage();
		if (!lua_run("set_dlg_profile", "$ci", "total"))
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_FIND_CALLER') %]
			exit;
		}
		xlog("L_INFO", "Dialog set mark TOTAL - [% logreq -%]\n");
		lua_run("set_dlg_profile", "$ci", "peer:faxserver");
		xlog("L_INFO", "Dialog set mark peer to faxserver - [% logreq -%]\n");
	}
	else if($avp(s:from_voicebox) == 1 || ds_is_from_list("2"))
	{
		xlog("L_NOTICE", "Call from Voicebox - [% logreq -%]\n");
		$var(no_auth) = 1;
		$(avp(s:from_voicebox)[*]) = 1;
		$var(from_local_endpoint) = 1;
		if(subst_uri('/^sip:(.+)__AT__(.+)@.+$/sip:\1@\2/'))
		{
			xlog("L_INFO", "Replaced reminder uri and to - [% logreq -%]\n");
		}
		$(avp(s:tmp)[*]) = 0;
		$var(fU) = $fU;
		xlog("L_INFO", "Voicebox caller is '$var(fU)' - [% logreq -%]\n");
		avp_db_query("select s.uuid, d.alias_username from subscriber s, dbaliases d where d.alias_username like concat(left('$(var(fU){s.escape.common})', 7), '%') and instr('$(var(fU){s.escape.common})', d.alias_username)=1 and d.username = s.username and d.domain = s.domain order by length(alias_username) desc limit 1", "$avp(s:caller_uuid);$avp(s:tmp)");
		if($avp(s:caller_uuid) == $null)
		{
			xlog("L_INFO", "Unknown caller in call from Voicebox - [% logreq -%]\n");
			$(avp(s:caller_uuid)[*]) = "0";
		}
		#Dialog handling for incoming request from Voicemail server
		dlg_manage();
		if (!lua_run("set_dlg_profile", "$ci", "total"))
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_FIND_CALLER') %]
			exit;
		}
		xlog("L_INFO", "Dialog set mark TOTAL - [% logreq -%]\n");
		lua_run("set_dlg_profile", "$ci", "peer:voicebox");
		xlog("L_INFO", "Dialog set mark peer to voicebox - [% logreq -%]\n");
	}
	
	else if($avp(s:from_pbx) != 1)
	{
		if(allow_trusted("$avp(s:ip)", "$avp(s:proto)"))
		{
			if(is_avp_set("$avp(s:peer_uuid)/s"))
			{
				# use tag-column from trusted-table as uuid for this caller
				avp_copy("$avp(s:peer_uuid)", "$avp(s:caller_uuid)/d");
				avp_db_query("select domain from subscriber where uuid='$avp(s:caller_uuid)' limit 1", "$avp(s:caller_domain)");
			}
			else
			{
				# if no uuid is set, use "0" as default uuid
				$avp(s:caller_uuid) = "0";
			}
			
			xlog("L_NOTICE", "Call from trusted peer with uuid '$avp(s:caller_uuid)' - [% logreq -%]\n");
			if(!is_domain_local("$rd"))
			{
				xlog("L_NOTICE", "Rejecting peering attempt with non-local request domain - [% logreq -%]\n");

				$var(announce_handle) = "relaying_denied";
				$var(announce_set) = $avp(s:caller_sound_set);
				$(avp(s:announce_code)[*]) = 403;
				$(avp(s:announce_reason)[*]) = "Relaying Denied";
				$(avp(s:acc_state)[*]) = "call";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}

			$var(noauth) = 1;
			$var(from_trusted) = 1;
		}
		else
		{
			#!ifdef PROXY_LOOKUP
			if(!is_present_hf("Proxy-Authorization") && $var(proxylu_dst_caller) != 1)
			{
				$var(proxylu_target) = "caller";
				$var(proxylu_user) = $(fU{s.escape.common});
				$var(proxylu_domain) = $(fd{s.escape.common});
				$var(proxylu_cache_user) = $var(proxylu_user);
				$var(proxylu_cache_domain) = $var(proxylu_domain);
				route(ROUTE_PERFORM_PROXYLU);
			}
			#!endif
			route(ROUTE_AUTH);
			#!ifdef ENABLE_AUTHCHECK
			sl_send_reply("101", "Connecting");
			#!endif
		}
	}
	if(is_present_hf("History-Info") && $var(cf_loop) == 1)
	{
		if($(hdr(History-Info)[-1]{s.select,-1,,}{param.value,index}) != '')
		{
			$(avp(s:hih_caller_index)[*]) = $(hdr(History-Info)[-1]{s.select,-1,,}{param.value,index});
			$var(hih_user) = $(hdr(History-Info)[-1]{s.select,-1,,}{nameaddr.uri}{uri.user});
			xlog("L_INFO", "History-Info received index='$(hdr(History-Info)[-1]{s.select,-1,,}{param.value,index})', user='$var(hih_user)' - [% logreq -%]\n");
		}
	}
	[% debug_dump('end', 'ROUTE_FIND_CALLER') %]
}

########################################################################
# Request route 'emergency'
########################################################################
route[ROUTE_EMERGENCY]
{
	[% debug_dump('start', 'ROUTE_EMERGENCY') %]
	xlog("L_NOTICE", "Emergency call detected - [% logreq -%]\n");

	if($xavp(caller_real_prefs[0]=>reject_emergency) == 1)
	{
		$var(announce_handle) = "emergency_unsupported";
		$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
		$(avp(s:announce_code)[*]) = 403;
		$(avp(s:announce_reason)[*]) = "Emergency Calls Not Supported";
		route(ROUTE_EARLY_REJECT);
	}

	$(avp(s:em_call)[*]) = 1;
	$(avp(s:callee_uuid)[*]) = 0;
	$(avp(s:caller_clir)[*]) = 0;

	# always use network-provided CLI for emergency calls
	# TODO: make it configurable via usr-prefs once we have multi-selects
	$(avp(s:caller_cli_userprov)[*]) = $avp(s:caller_cli_netprov);
	$(avp(s:caller_domain_userprov)[*]) = $avp(s:caller_domain_netprov);
	$(avp(s:first_caller_cli_userprov)[*]) = $avp(s:caller_cli_userprov);
	$(avp(s:first_caller_domain_userprov)[*]) = $avp(s:caller_domain_userprov);

	$(avp(s:acc_callee_user_in)[*]) = $rU;
	$(avp(s:callee_user)[*]) = $avp(s:acc_callee_user_in);
	$(avp(s:acc_callee_user)[*]) = $rU;
	$(avp(s:acc_callee_domain)[*]) = $rd;
	$(avp(s:acc_callee_domain_in)[*]) = $rd;
	$(avp(s:callee_uuid)[*]) = 0;

	# Dialog handling for emergency call
	lua_run("set_dlg_profile", "$ci", "emergency");
	xlog("L_INFO", "Dialog set mark emergency - [% logreq -%]\n");

	if(pv_isset("$xavp(caller_real_prefs[0]=>emergency_location_object)"))
	{
		set_body_multipart();
		msg_apply_changes();
		append_body_part("$xavp(caller_real_prefs[0]=>emergency_location_object)\r\n", "application/vnd.cirpack.isdn-ext", "signal;handling=required");
		msg_apply_changes();
	}
	route(ROUTE_PSTN);
	[% debug_dump('exit', 'ROUTE_EMERGENCY') %]
	exit;
}

########################################################################
# Request route 'route-check-pbx'
########################################################################
route[ROUTE_CHECK_PBX]
{
	[% debug_dump('start', 'ROUTE_CHECK_PBX') %]
	#!ifdef ENABLE_PBX
	if($xavp(caller_real_prefs[0]=>cloud_pbx) == 1 && $avp(s:from_pbx) != 1 && $var(cf_loop) != 1)
	{
		xlog("L_INFO", "Set next hop to pbx because caller is a PBX user - [% logreq -%]\n");
		$var(to_pbx) = 1;
		$var(no_sbc) = 1;
		$var(pbx_app_name) = "sbc";

		$var(from_pbx_initial) = 1;

		append_hf("P-NGCP-Orig-User: $avp(s:acc_callee_user_in)\r\n");
		append_hf("P-NGCP-Orig-Domain: $avp(s:acc_callee_domain_in)\r\n");
		append_hf("P-NGCP-Orig-Dialed: $avp(s:acc_callee_dialed)\r\n");
		append_hf("P-NGCP-BlockOut-Override: $var(block_override)\r\n");
		append_hf("P-NGCP-AdmBlockOut-Override: $var(adm_block_override)\r\n");
		append_hf("P-NGCP-ContBlockOut-Override: $var(contract_block_override)\r\n");
		append_hf("P-NGCP-ContAdmBlockOut-Override: $var(contract_adm_block_override)\r\n");
		append_hf("P-Caller-CLIR: $avp(s:caller_clir)\r\n");

		# pass the caller IP source info through pbx
		append_hf("P-NGCP-Src-Ip: $avp(s:ip)\r\n");
		append_hf("P-NGCP-Src-Port: $avp(s:port)\r\n");
		append_hf("P-NGCP-Src-Proto: $avp(s:proto)\r\n");
		append_hf("P-NGCP-Src-Af: $avp(s:af)\r\n");
		append_hf("P-NGCP-Src-Nat: $avp(s:nat)\r\n");

		if(!pv_isset("$avp(s:acc_callee_user_in)"))
		{
			$(avp(s:acc_callee_user_in)[*]) = $rU;
		}
		if(!pv_isset("$avp(s:acc_callee_domain_in)"))
		{
			$(avp(s:acc_callee_domain_in)[*]) = $rd;
		}
		if(!pv_isset("$avp(s:callee_uuid)"))
		{
			$(avp(s:callee_uuid)[*]) = 0;
		}
		$(avp(s:lbrtp_dispatcher_id_callee)[*]) = $avp(s:lbrtp_dispatcher_id_caller);
		xlog("L_INFO", "Setting caller did '$avp(s:lbrtp_dispatcher_id_caller)' as callee did for initial loop to PBX - [% logreq -%]\n");

		t_on_failure("FAILURE_ROUTE_LOCAL");
		route(ROUTE_OUTBOUND);
	}
	#!endif
	[% debug_dump('return', 'ROUTE_CHECK_PBX') %]
	return;
}
	
########################################################################
# Request route 'invite-find-callee'
########################################################################
route[ROUTE_FIND_CALLEE]
{
	[% debug_dump('start', 'ROUTE_FIND_CALLEE') %]
	xlog("L_INFO", "Searching for callee - [% logreq -%]\n");
	# make sure to init it to 0 again if we come from a failure-route also
	$var(loose_routed) = 0;
	if($var(forward) == 1) # TODO: also for cf_loop?
	{
		xlog("L_INFO", "Setting network-provided info as user-provided info for call-forward - [% logreq -%]\n");
		$(avp(s:caller_domain_userprov)[*]) = $avp(s:caller_domain_netprov);
		$(avp(s:caller_cli_userprov)[*]) = $avp(s:caller_cli_netprov);

		avp_delete("$avp(s:acc_callee_dialed)/g");
		$(avp(s:acc_callee_dialed)[*]) = $rU;
		$var(no_auth) = 0;
	}

	if($var(no_auth) == 0 && uri =~ "^sip:\*[0-9]@" && $var(cf_loop) != 1)
	{
		if(sd_lookup("speed_dial"))
		{
			xlog("L_NOTICE", "Speed-Dial translation done - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Speed-Dial slot not found - [% logreq -%]\n");
			$(avp(s:acc_callee_user)[*]) = $rU;
			$(avp(s:acc_callee_domain)[*]) = $rd;
			$(avp(s:acc_callee_user_in)[*]) = $rU;
			$(avp(s:acc_callee_domain_in)[*]) = $rd;
			$(avp(s:callee_uuid)[*]) = 0;

			$var(announce_handle) = "invalid_speeddial";
			$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 484;
			$(avp(s:announce_reason)[*]) = "Speed-Dial slot empty";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}

	# Dialog count caller peer concurrent_max
	if($avp(s:from_pstn) == 1 &&
	   pv_isset("$xavp(caller_peer_prefs[0]=>concurrent_max)") &&
	   $xavp(caller_peer_prefs[0]=>concurrent_max) != 0)
	{
		if(lua_run("get_profile_size","peer:$avp(s:lcr_flags)","size"))
		{
			if ($avp(s:size) > $xavp(caller_peer_prefs[0]=>concurrent_max))
			{
				xlog("L_NOTICE", "Concurrent_max calls exceeded for peer '$avp(s:lcr_flags)' - [% logreq -%]\n");
				$(avp(s:acc_callee_user_in)[*]) = $rU;
				$(avp(s:acc_callee_domain_in)[*]) = $rd;

				$var(announce_handle) = "max_calls_peer";
				$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
				$(avp(s:announce_code)[*]) = 403;
				$(avp(s:announce_reason)[*]) = "Maximum parallel calls exceeded";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
		}
		else
		{
			route(ROUTE_ADD_CALLINFO_REPLY);
			sl_send_reply("500", "Internal Error");
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}
	}

	# NOTE: we explicitely do rewrite forwards if caught by 3xx

	# TODO: this block can be removed with new ossbss number normalization, keep it now for backwards compatibility.
	if(($var(forward) == 1 || 
	    $var(cf_loop) == 1) && 
	   $var(redirected_forward) != 1 && 
	   $rU =~ "^\+[1-9][0-9]+$")
	{
		strip(1);
		xlog("L_INFO", "Stripping leading '+' for forwarded call - [% logreq -%]\n");
	}
	else if(($var(forward) == 0 ||
		 $var(redirected_forward) == 1 ||
		 $var(blind_transfer) == 1) &&
		$var(cf_loop) != 1 &&
		$avp(s:from_pstn) == 1 &&
		$avp(s:p_to_device) != 1)
	{
		if($var(referrer_callee_in_dpid) != 0)
 		{
			xlog("L_NOTICE", "Using referrer dpid '$var(referrer_callee_in_dpid)' for blind transfer - [% logreq -%]\n");
			$var(dpid) = $var(referrer_callee_in_dpid);

			$(avp(s:caller_ac)[*]) = $xavp(referrer_real_prefs[0]=>ac);
			$(avp(s:caller_cc)[*]) = $xavp(referrer_real_prefs[0]=>cc);
			$(avp(s:caller_cloud_pbx_base_cli)[*]) = $xavp(referrer_real_prefs[0]=>cloud_pbx_base_cli);
			$(avp(s:caller_cloud_pbx_ext)[*]) = $xavp(referrer_real_prefs[0]=>cloud_pbx_ext);
			$(avp(s:caller_cloud_pbx_account_cli_list)[*]) = $xavp(referrer_real_prefs[0]=>cloud_pbx_account_cli_list);
			$(avp(s:caller_emergency_prefix)[*]) = $xavp(referrer_real_prefs[0]=>emergency_prefix);
			$(avp(s:caller_emergency_suffix)[*]) = $xavp(referrer_real_prefs[0]=>emergency_suffix);
			$(avp(s:caller_emergency_cli)[*]) = $xavp(referrer_real_prefs[0]=>emergency_cli);	
		}
		else if(pv_isset("$xavp(caller_peer_prefs[0]=>rewrite_callee_in_dpid)"))
		{
			$var(dpid) = $xavp(caller_peer_prefs[0]=>rewrite_callee_in_dpid);
		}

		if($var(dpid) != 0)
		{
			$var(dp_input) = $rU;
			$var(dp_input_desc) = "called party";
			$var(dpid_desc) = "callee-in peer";
			if(route(ROUTE_APPLY_REWRITE_RULE))
			{
				$rU = $var(dp_user);
			}
		}
	}
	else if(($var(forward) == 0 ||
		 $var(redirected_forward) == 1 ||
		 $var(blind_transfer) == 1) &&
		$var(cf_loop) != 1 &&
		$avp(s:from_pstn) != 1 &&
		$avp(s:p_to_device) != 1)
	{
		if($var(referrer_callee_in_dpid) != 0)
		{
			xlog("L_NOTICE", "Using referrer dpid '$var(referrer_callee_in_dpid)' for blind transfer - [% logreq -%]\n");
			$var(dpid) = $var(referrer_callee_in_dpid);
			
			$(avp(s:caller_ac)[*]) = $xavp(referrer_real_prefs[0]=>ac);
			$(avp(s:caller_cc)[*]) = $xavp(referrer_real_prefs[0]=>cc);
			$(avp(s:caller_cloud_pbx_base_cli)[*]) = $xavp(referrer_real_prefs[0]=>cloud_pbx_base_cli);
			$(avp(s:caller_cloud_pbx_ext)[*]) = $xavp(referrer_real_prefs[0]=>cloud_pbx_ext);
			$(avp(s:caller_cloud_pbx_account_cli_list)[*]) = $xavp(referrer_real_prefs[0]=>cloud_pbx_account_cli_list);
			$(avp(s:caller_emergency_prefix)[*]) = $xavp(referrer_real_prefs[0]=>emergency_prefix);
			$(avp(s:caller_emergency_suffix)[*]) = $xavp(referrer_real_prefs[0]=>emergency_suffix);
			$(avp(s:caller_emergency_cli)[*]) = $xavp(referrer_real_prefs[0]=>emergency_cli);	
		}
		else if(pv_isset("$xavp(caller_real_prefs[0]=>rewrite_callee_in_dpid)"))
		{
			$var(dpid) = $xavp(caller_real_prefs[0]=>rewrite_callee_in_dpid);
		}

		if($xavp(caller_real_prefs[0]=>cloud_pbx)) {
			# if we're coming from a 30x, these are still set and cause failure
			# to do blind transfer, so explicitly unset them
			pv_unset("$avp(s:callee_user)");
			pv_unset("$avp(s:callee_domain)");

			avp_db_query("select vs.username,vd.domain from provisioning.voip_subscribers vs left join provisioning.voip_domains vd on vs.domain_id = vd.id  where vs.account_id='$xavp(caller_real_prefs[0]=>account_id)' and pbx_extension='$(rU{s.escape.common})'", "$avp(s:callee_user);$avp(s:callee_domain)");
			if($avp(s:callee_user) != $null && $avp(s:callee_domain) != $null)
			{
				xlog("L_NOTICE", "Found callee '$avp(s:callee_user)@$avp(s:callee_domain)' by PBX extension lookup using '$rU' - [% logreq -%]\n");
				$rU = $avp(s:callee_user);
				$rd = $avp(s:callee_domain);
				$var(dpid) = 0;
			}
		}

		if($var(dpid) != 0)
 		{
			$var(dp_input) = $rU;
			$var(dp_input_desc) = "called party";
			$var(dpid_desc) = "callee-in usr/domain";
			if(route(ROUTE_APPLY_REWRITE_RULE))
			{
				$rU = $var(dp_user);
			}
		}
	}
	if($var(forward) != 1 && $var(redirected_forward) != 1)
	{
		# needs to be called before ROUTE_LOAD_CALLEE_PREF and ROUTE_BLOCK_IN
		route(ROUTE_CLIR);
	}

	if(uri =~ "^sip:emergency_")
	{
		route(ROUTE_CHECK_PBX);
		route(ROUTE_EMERGENCY);
		[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
		exit;
	}
	if($var(no_auth) == 1 && $var(forward) != 1 && $var(cf_loop) != 1)
	{
		xlog("L_INFO", "Skipping internal services for unauthenticated call - [% logreq -%]\n");
	}
	else
	{
		#apogrebennyk: forwarding to voicebox, conference and fax2mail should work even if the subscriber is locked for outgoing calls.
		if((avp_check("$xavp(caller_real_prefs[0]=>lock)", "eq/s:2") ||
			avp_check("$xavp(caller_real_prefs[0]=>lock)", "eq/s:3") ||
			avp_check("$xavp(caller_real_prefs[0]=>lock)", "eq/s:4")) &&
			$var(forward) != 1 && !($rd =~ "^.+\.local$" && $var(cf_loop) == 1))
		{
			xlog("L_NOTICE", "Caller locked for outgoing with mode '$xavp(caller_real_prefs[0]=>lock)' - [% logreq -%]\n");
			if($avp(s:callee_uuid) == $null)
			{
				$(avp(s:callee_uuid)[*]) = "0";
			}
			if($avp(s:callee_user) == $null)
			{
				$(avp(s:callee_user)[*]) = $rU;
			}
			if($avp(s:callee_domain) == $null)
			{
				$(avp(s:callee_domain)[*]) = $rd;
			}

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);
			$(avp(s:acc_callee_user_in)[*]) = $rU;
			$(avp(s:acc_callee_domain_in)[*]) = $rd;


			$var(announce_handle) = "locked_out";
			$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 403;
			$(avp(s:announce_reason)[*]) = "Caller locked";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}

		if($rU == "playbalance")
		{
			route(ROUTE_CHECK_PBX);
			xlog("L_NOTICE", "Balance check request - [% logreq -%]\n");
			if(is_present_hf("P-App-Name"))
			{
				remove_hf("P-App-Name");
			}
			append_hf("P-App-Name:  playbalance\r\n");

			$var(playbalance_params) = ";uuid=" + $avp(s:caller_uuid);
			$var(playbalance_params) = $var(playbalance_params) + ";sound_set_id=" + $xavp(caller_real_prefs[0]=>sound_set);
			$var(playbalance_params) = $var(playbalance_params) + ";fr_code=603;fr_reason=Declined"; 
			xlog("L_INFO", "Writing balance check parameters '$var(playbalance_params)' - [% logreq -%]\n");

			if(is_present_hf("P-App-Param"))
			{
				remove_hf("P-App-Param");
			}
			append_hf("P-App-Param: $var(playbalance_params)\r\n");
			t_on_failure("FAILURE_ROUTE_APPSRV");
			route(ROUTE_TO_APPSRV);
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}

		if($rU == "voucher")
		{
			route(ROUTE_CHECK_PBX);
			xlog("L_NOTICE", "Voucher recharge request - [% logreq -%]\n");
			if(is_present_hf("P-App-Name"))
			{
				remove_hf("P-App-Name");
			}
			append_hf("P-App-Name:  voucher\r\n");

			$var(voucher_params) = ";uuid=" + $avp(s:caller_uuid);
			$var(voucher_params) = $var(voucher_params) + ";account_id=" + $xavp(caller_real_prefs[0]=>account_id);
			$var(voucher_params) = $var(voucher_params) + ";sound_set_id=" + $xavp(caller_real_prefs[0]=>sound_set);
			xlog("L_INFO", "Writing voucher parameters '$var(voucher_params)' - [% logreq -%]\n");

			if(is_present_hf("P-App-Param"))
			{
				remove_hf("P-App-Param");
			}
			append_hf("P-App-Param: $var(voucher_params)\r\n");
			t_on_failure("FAILURE_ROUTE_APPSRV");
			route(ROUTE_TO_APPSRV);
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}

		#!ifdef ENABLE_VSC
		if(uri =~ "^sip:\*[% sems.vsc.unpark_code %]\*.+@")
		{
			strip(4);
			$var(tmp) = $rU;
			$ru = "sip:pickup@" + $rd + ";orbit=" + $var(tmp);
			xlog("L_NOTICE", "Rewriting VSC unpark request for orbit '$var(tmp)' to cisco style '$ru' - [% logreq -%]\n");
		} 
		else if((uri =~ "^sip:\*[0-9][0-9]\*.*@" || uri =~ "^sip:\%23[0-9][0-9](\%23)?.*@") && !uri =~ "^sip:\*[% sems.vsc.directed_pickup_code %]\*.+@")
		{
			xlog("L_NOTICE", "VSC request - [% logreq -%]\n");
			$rd="vsc.local";
			if(is_present_hf("P-App-Name"))
			{
				remove_hf("P-App-Name");
			}
			append_hf("P-App-Name: sw_vsc\r\n");
			t_on_failure("FAILURE_ROUTE_APPSRV");
			xlog("L_INFO", "Set VSC language '$xavp(caller_real_prefs[0]=>language)' - [% logreq -%]\n");
			if(is_present_hf("P-Language"))
			{
				remove_hf("P-Language");
			}
			append_hf("P-Language: $xavp(caller_real_prefs[0]=>language)\r\n");
			route(ROUTE_TO_APPSRV);
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}
		#!endif

		#!ifdef ENABLE_CONFERENCE
		if(uri =~ "@conference\.local$")
		{
			route(ROUTE_CHECK_PBX);
			xlog("L_NOTICE", "Conference PIN request - [% logreq -%]\n");
			if(!pv_isset("$xavp(caller_real_prefs[0]=>conference_pin)"))
			{
				$xavp(caller_real_prefs[0]=>conference_pin) = "";
			}
			if(is_present_hf("P-App-Name"))
			{
				remove_hf("P-App-Name");
			}
			# rfc4240 room name
			$var(room) = $avp(s:caller_cli_netprov) + "_" + $xavp(caller_real_prefs[0]=>conference_pin);
			append_hf("P-App-Name:  confpin\r\n");
			$(avp(s:app_server_params)[*]) = ";sound_set_id=" + $xavp(caller_real_prefs[0]=>sound_set) +
							 ";room=" + $var(room) + ";roompin=" + $xavp(caller_real_prefs[0]=>conference_pin);
			if(pv_isset("$xavp(caller_contract_prefs[0]=>conference_max_participants)"))
			{
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";max_participants=" + $xavp(caller_contract_prefs[0]=>conference_max_participants);
			}
			append_hf("P-App-Param: $avp(s:app_server_params)\r\n");
			t_on_failure("FAILURE_ROUTE_APPSRV");
			route(ROUTE_TO_APPSRV);
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}
		#!endif

		#!ifdef ENABLE_VOICEMAIL
		if(uri =~ "@voicebox\.local$")
		{
			route(ROUTE_CHECK_PBX);
			route(ROUTE_VOICEBOX);
		}
		#!endif
		if(uri =~ "@fax2mail\.local$")
		{
			route(ROUTE_CHECK_PBX);
			route(ROUTE_FAXSERVER);
		}
		#!ifdef ENABLE_VOICEMAIL
		if($rU == "voicebox" || $rU == "[% sems.vsc.voicemail_number %]")
		{
			route(ROUTE_CHECK_PBX);
			if(!pv_isset("$xavp(caller_real_prefs[0]=>cli)"))
			{
				$rU = $avp(s:caller_uuid);
			}
			else
			{
				$rU = $xavp(caller_real_prefs[0]=>cli);
			}
			$rd = 'voicebox.local';
			prefix("abc");
			route(ROUTE_VOICEBOX);
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}
		#!endif
		else if(uri =~ "^sip:callthrough@app\.local$")
		{
			route(ROUTE_CHECK_PBX);
			xlog("L_NOTICE", "Call-through request - [% logreq -%]\n");
			t_on_failure("FAILURE_ROUTE_APPSRV");
			$var(count_dlg) = 1;
			route(ROUTE_TO_CCSRV);
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}
		else if(uri =~ "^sip:callingcard@app\.local$")
		{
			route(ROUTE_CHECK_PBX);
			xlog("L_NOTICE", "Calling card request - [% logreq -%]\n");
			t_on_failure("FAILURE_ROUTE_APPSRV");
			$var(count_dlg) = 1;
			route(ROUTE_TO_CCSRV);
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}
		#!ifdef ENABLE_PBX
		else if($avp(s:from_pbx) != 1 && (uri =~ "^sip:auto-attendant@app\.local$" 
			|| uri =~ "^sip:office-hours@app\.local$"))
		{
			xlog("L_NOTICE", "Hosted PBX request for AA/OH- [% logreq -%]\n");
			$var(to_pbx) = 1;
			$var(no_sbc) = 1;
			if(!pv_isset("$xavp(caller_real_prefs[0]=>contract_sound_set)"))
			{
				# TODO: agranig: reject if there is no sound set?
				$xavp(caller_real_prefs[0]=>contract_sound_set) = "0";
			}
			# shall not be cleared until branch route where it is added as header
			$(avp(s:app_server_params)[*]) = "uuid=" + $avp(s:caller_uuid) +
							";sound_set_id=" + $xavp(caller_real_prefs[0]=>contract_sound_set) +
							";aa_account_uri=sip:" + $avp(s:caller_cli_netprov) + "@" + $avp(s:acc_caller_domain) +
							";first_caller_uri=sip:" + $avp(s:first_caller_cli_userprov) + "@" + $avp(s:first_caller_domain_userprov);

			route(ROUTE_CHECK_PBX);
			t_on_failure("FAILURE_ROUTE_PBXSRV");
			$var(count_dlg) = 1;
			route(ROUTE_TO_PBXSRV);
			[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
			exit;
		}
		else if(uri =~ "^sip:pickup@.+;orbit=")
		{
			xlog("L_INFO", "Skip accounting for PBX unpark request - [% logreq -%]\n");
			$var(no_acc) = 1;
			resetflag(FLAG_ACC_DB);
			resetflag(FLAG_ACC_FAILED);
		}

		#!endif
	}
	#!ifdef ENABLE_VOICEMAIL
	if(uri =~ "^sip:voiceboxpass@")
	{
		route(ROUTE_CHECK_PBX);
		$rd = 'voicebox.local';
		prefix("bcd");
		route(ROUTE_VOICEBOX);
		[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
		exit;
	}
	#!endif

	$(avp(s:callee_cli)[*]) = $rU;

	# TODO: agranig: check about serial/parallel hunting here once it's working?
	if(!isflagset(FLAG_IN_FALLBACK) && ($avp(s:from_pbx) != 1 || $avp(s:from_pbx) == 1 && $avp(s:p_to_device) == 0))
	{
		$(avp(s:acc_callee_user_in)[*]) = $rU;
		$(avp(s:acc_callee_domain_in)[*]) = $rd;
	}
	else if($avp(s:from_pbx) == 1)
	{
		$(avp(s:acc_callee_user_in)[*]) = $hdr(P-NGCP-Orig-User);
		$(avp(s:acc_callee_domain_in)[*]) = $hdr(P-NGCP-Orig-Domain);
		$var(block_override) = $hdr(P-NGCP-BlockOut-Override);
		$var(adm_block_override) = $hdr(P-NGCP-AdmBlockOut-Override);
		$var(contract_block_override) = $hdr(P-NGCP-ContBlockOut-Override);
		$var(contract_adm_block_override) = $hdr(P-NGCP-ContAdmBlockOut-Override);
		remove_hf("P-NGCP-Orig-User");
		remove_hf("P-NGCP-Orig-Domain");
		remove_hf("P-NGCP-BlockOut-Override");
		remove_hf("P-NGCP-AdmBlockOut-Override");
		remove_hf("P-NGCP-ContBlockOut-Override");
		remove_hf("P-NGCP-ContAdmBlockOut-Override");
	}

	avp_delete("$avp(s:has_extension)/g");
	avp_delete("$avp(s:callee_user)/g");
	avp_delete("$avp(s:callee_base_user)/g");
	avp_delete("$avp(s:callee_domain)/g");
	avp_delete("$avp(s:is_primary)/g");
	avp_db_query("select username,domain,alias_username,is_primary from dbaliases where alias_username like concat(left('$(rU{s.escape.common})', 7), '%') and instr('$(rU{s.escape.common})', alias_username)=1 order by length(alias_username) desc limit 1", "$avp(s:callee_user);$avp(s:callee_domain);$avp(s:callee_base_user);$avp(s:is_primary)");
	if($avp(s:callee_user) != $null && $avp(s:callee_domain) != $null)
	{
		$rU = $avp(s:callee_user);
		$rd = $avp(s:callee_domain);
		if($avp(s:acc_callee_user_in) != $null && $avp(s:acc_callee_user_in) != $avp(s:callee_base_user))
		{
			$(avp(s:has_extension)[*]) = 1;
			xlog("L_NOTICE", "Callee was aliased with extension '$avp(s:callee_base_user)' - [% logreq -%]\n");
		}
		else
		{
			xlog("L_NOTICE", "Callee was aliased with base '$avp(s:callee_base_user)' - [% logreq -%]\n");
		}
	}
	else if ($xavp(caller_peer_prefs[0]=>find_subscriber_by_uuid) == 1)
	{
		avp_delete("$avp(s:has_extension)/g");
		avp_delete("$avp(s:callee_user)/g");
		avp_delete("$avp(s:callee_base_user)/g");
		avp_delete("$avp(s:callee_domain)/g");

		if($(ru{uri.param,uuid}) != $null)
		{
			$var(tmpuuid) = $(ru{uri.param,uuid});
			xlog("L_INFO", "Using ruri-uuid-param '$var(tmpuuid)' as uuid for subscriber lookup - [% logreq -%]\n");
		}
		else
		{
			$var(tmpuuid) = $rU;
			xlog("L_INFO", "Using ruri-user '$var(tmpuuid)' as uuid for subscriber lookup - [% logreq -%]\n");
		}
		avp_db_query("select username, domain from usr_preferences where uuid='$(var(tmpuuid){s.escape.common})' limit 1", "$avp(s:callee_user);$avp(s:callee_domain)");
		if($avp(s:callee_user) != $null && $avp(s:callee_domain) != $null)
		{
			$rU = $avp(s:callee_user);
			$rd = $avp(s:callee_domain);
			xlog("L_NOTICE", "Callee was found using uuid - [% logreq -%]\n");
		}
		else
		{
			$(avp(s:callee_user)[*]) = $rU;
			$(avp(s:callee_domain)[*]) = $rd;
		}
	}
	else
	{
		$(avp(s:callee_user)[*]) = $rU;
		$(avp(s:callee_domain)[*]) = $rd;
	}

	route(ROUTE_CLEAR_CALLEE_PREF);
	if($var(no_auth) == 0 && !is_domain_local("$rd"))
	{
		#TODO Handle dialog marks for foreign domains
		$var(external_domain) = 1;
		$(avp(s:callee_uuid)[*]) = "0";

		if($var(contract_adm_block_override) == 1)
		{
			xlog("L_INFO", "Administrative Contract NCOS overridden, skip - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Check Administrative Contract NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_contract_prefs[0]=>adm_ncos_id);
			route(ROUTE_NCOS);
		}

		if($var(adm_block_override) == 1)
		{
			xlog("L_INFO", "Administrative NCOS overridden, skip - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Check Administrative NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>adm_ncos_id);
			route(ROUTE_NCOS);
		}

		if($var(contract_block_override) == 1)
		{
			xlog("L_INFO", "Contract NCOS overridden, skip - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Check Contract NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_contract_prefs[0]=>ncos_id);
			route(ROUTE_NCOS);
		}

		if($var(block_override) == 1)
		{
			xlog("L_INFO", "NCOS overridden, skip - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Check User NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>ncos_id);
			route(ROUTE_NCOS);
		}

		if($var(cf_loop) == 1)
		{
			xlog("L_INFO", "Check Administrative CF NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>adm_cf_ncos_id);
			route(ROUTE_NCOS);
		}

		route(ROUTE_BLOCK_OUT);
		route(ROUTE_CHECK_PBX);
		$var(count_dlg) = 1;
		route(ROUTE_INVITE_TO_EXT);
	}
	avp_delete("$avp(s:callee_uuid)");
	[%  IF kamailio.proxy.ignore_auth_realm == "yes" %]
	avp_db_query("select uuid from subscriber where username = '$(rU{s.escape.common})'", "$avp(s:callee_uuid)");
	[% ELSE %]
	avp_db_query("select uuid from subscriber where username = '$(rU{s.escape.common})' and domain = '$(rd{s.escape.common})'", "$avp(s:callee_uuid)");
	[% END %]
	if($avp(s:callee_uuid) != $null)
	{
		xlog("L_NOTICE", "Callee is local, uuid='$avp(s:callee_uuid)' - [% logreq -%]\n");
		append_to_reply("P-Callee-Uuid: $avp(s:callee_uuid)\r\n");
		if($var(cf_loop) == 1 && $avp(s:caller_uuid) == $avp(s:callee_uuid))
		{
			xlog("L_WARN", "Callee is forwarding to itself, reject call - [% logreq -%]\n");
			$var(announce_handle) = "cf_loop";
			$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 480;
			$(avp(s:announce_reason)[*]) = "Unavailable";

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		if($avp(s:from_pbx) == 1)
		{
			xlog("L_NOTICE", "Skip NCOS level and block_out list check for call loop from PBX - [% logreq -%]\n");
		}
		else
		{
			if($var(contract_adm_block_override) == 1)
			{
				xlog("L_INFO", "Administrative Contract NCOS overridden, skip - [% logreq -%]\n");
			}
			else
			{
				xlog("L_INFO", "Check Administrative Contract NCOS level - [% logreq -%]\n");
				$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_contract_prefs[0]=>adm_ncos_id);
				route(ROUTE_NCOS);
			}

			if($var(adm_block_override) == 1)
			{
				xlog("L_INFO", "Administrative NCOS overridden, skip - [% logreq -%]\n");
			}
			else
			{
				xlog("L_INFO", "Check Administrative NCOS level - [% logreq -%]\n");
				$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>adm_ncos_id);
				route(ROUTE_NCOS);
			}

			if($var(contract_block_override) == 1)
			{
				xlog("L_INFO", "Contract NCOS overridden, skip - [% logreq -%]\n");
			}
			else
			{
				xlog("L_INFO", "Check Contract NCOS level - [% logreq -%]\n");
				$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_contract_prefs[0]=>ncos_id);
				route(ROUTE_NCOS);
			}

			if($var(block_override) == 1)
			{
				xlog("L_INFO", "NCOS overridden, skip - [% logreq -%]\n");
			}
			else
			{
				xlog("L_INFO", "Check User NCOS level - [% logreq -%]\n");
				$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>ncos_id);
				route(ROUTE_NCOS);
			}

			if($var(cf_loop) == 1)
			{
				xlog("L_INFO", "Check Administrative CF NCOS level - [% logreq -%]\n");
				$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>adm_cf_ncos_id);
				route(ROUTE_NCOS);
			}

			# check block-out-list
			route(ROUTE_BLOCK_OUT);
		}
		if($xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer) == "force" ||
		   $xavp(caller_peer_prefs[0]=>force_outbound_calls_to_peer) == "force")
		{
			if($var(from_local_endpoint) == 0 && $avp(s:from_faxserver) == 0 && $avp(s:from_voicebox) == 0)
			{
				xlog("L_NOTICE", "Force on-net call to peer by caller's preference - [% logreq -%]\n");
				if($avp(s:callee_base_user) != $null)
				{
					$rU = $avp(s:callee_base_user);
				}
				else if($avp(s:acc_callee_user_in) != $null)
				{
					$rU = $avp(s:acc_callee_user_in);
				}
				route(ROUTE_LOAD_CALLEE_PREF);
				route(ROUTE_CHECK_PBX);
				route(ROUTE_INVITE_TO_EXT);
			}
			else
			{
				xlog("L_INFO", "Keep call from local endpoint on-net, ignore caller's preference  - [% logreq -%]\n");
				route(ROUTE_LOAD_CALLEE_PREF);
				route(ROUTE_CHECK_PBX);
				route(ROUTE_INVITE_TO_INT);
			}
		}
		else
		{
			route(ROUTE_LOAD_CALLEE_PREF);
			route(ROUTE_CHECK_PBX);
			route(ROUTE_INVITE_TO_INT);
		}
	}
	else
	{
		$(avp(s:callee_uuid)[*]) = "0";
		xlog("L_NOTICE", "Callee is not local - [% logreq -%]\n");

		#!ifdef PROXY_LOOKUP
		xlog("L_INFO", "Performing proxy lookup for callee - [% logreq -%]\n");
		if($xavp(caller_peer_prefs[0]=>find_subscriber_by_uuid) == 1)
		{
			$var(proxylu_uuid) = $var(tmpuuid);
		}
		$var(proxylu_target) = "callee";
		$var(proxylu_user) = $(rU{s.escape.common});
		$var(proxylu_domain) = $(rd{s.escape.common});
		$var(proxylu_cache_user) =  $var(proxylu_user);
		$var(proxylu_cache_domain) = $var(proxylu_domain);
		# TODO: set cache_uuid as well and do lookup on lb?

		route(ROUTE_PERFORM_PROXYLU);
		#!endif

		if($var(contract_adm_block_override) == 1)
		{
			xlog("L_INFO", "Administrative Contract NCOS overridden, skip - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Check Administrative Contract NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_contract_prefs[0]=>adm_ncos_id);
			route(ROUTE_NCOS);
		}

		if($var(adm_block_override) == 1)
		{
			xlog("L_INFO", "Administrative NCOS overridden, skip - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Check Administrative NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>adm_ncos_id);
			route(ROUTE_NCOS);
		}

		if($var(contract_block_override) == 1)
		{
			xlog("L_INFO", "Contract NCOS overridden, skip - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Check Contract NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_contract_prefs[0]=>ncos_id);
			route(ROUTE_NCOS);
		}

		if($var(block_override) == 1)
		{
			xlog("L_INFO", "NCOS overridden, skip - [% logreq -%]\n");
		}
		else
		{
			xlog("L_INFO", "Check User NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>ncos_id);
			route(ROUTE_NCOS);
		}

		if($var(cf_loop) == 1)
		{
			xlog("L_INFO", "Check Administrative CF NCOS level - [% logreq -%]\n");
			$(avp(s:tmp_ncos_id)[*]) = $xavp(caller_real_prefs[0]=>adm_cf_ncos_id);
			route(ROUTE_NCOS);
		}

		# check block-out-list
		route(ROUTE_BLOCK_OUT);

		$var(count_dlg) = 1;
		route(ROUTE_CHECK_PBX);

		route(ROUTE_INVITE_TO_EXT);
	}
	[% debug_dump('exit', 'ROUTE_FIND_CALLEE') %]
	exit;
}

########################################################################
# Request route 'invite-to-internal'
########################################################################
route[ROUTE_INVITE_TO_INT]
{
	[% debug_dump('start', 'ROUTE_INVITE_TO_INT') %]
	if(pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") && $xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
	   pv_isset("$avp(s:first_caller_pbx_account_id)") &&
	   $avp(s:first_caller_pbx_account_id) == $xavp(callee_real_prefs[0]=>account_id) &&
	   $avp(s:caller_clir) == 1 && $avp(s:override_caller_clir) == 0)
	{
		if(pv_isset("$xavp(caller_real_prefs[0]=>clir_intrapbx)") && $xavp(caller_real_prefs[0]=>clir_intrapbx) == 1)
		{
			xlog("L_NOTICE", "Anonymous call within the same hosted PBX - [% logreq -%]\n");
		}
		else
		{
			xlog("L_NOTICE", "Caller requested to ignore CLIR for call within the same hosted PBX - [% logreq -%]\n");
			$(avp(s:caller_clir_ignore)[*]) = 1;
		}
	}
	if($xavp(callee_real_prefs[0]=>force_inbound_calls_to_peer) == 1)
	{
		xlog("L_NOTICE", "Callee forced to outbound peer by preference - [% logreq -%]\n");
		if($avp(s:callee_base_user) != $null)
		{
			# load peers based on the main E.164 number of subscriber and not SIP username
			$rU = $avp(s:callee_base_user);
		}
		route(ROUTE_INVITE_TO_EXT);
		[% debug_dump('exit', 'ROUTE_INVITE_TO_INT') %]
		exit;
	}
	else if(($xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer) == "force_interpbx" ||
		 $xavp(caller_contract_prefs[0]=>force_outbound_calls_to_peer) == "force_interpbx") &&
		pv_isset("$xavp(caller_real_prefs[0]=>account_id)") && pv_isset("$xavp(callee_real_prefs[0]=>account_id)") &&
		$xavp(caller_real_prefs[0]=>account_id) != $xavp(callee_real_prefs[0]=>account_id))
	{
		if($var(from_local_endpoint) == 0 && $avp(s:from_faxserver) == 0 && $avp(s:from_voicebox) == 0)
		{
			xlog("L_NOTICE", "Force on-net call to peer by caller's preference - [% logreq -%]\n");
			if($avp(s:callee_base_user) != $null)
			{
				$rU = $avp(s:callee_base_user);
			}
			else if($avp(s:acc_callee_user_in) != $null)
			{
				$rU = $avp(s:acc_callee_user_in);
			}
			route(ROUTE_CHECK_PBX);
			route(ROUTE_INVITE_TO_EXT);
		}
		else
		{
			xlog("L_INFO", "Keep call from local endpoint on-net, ignore caller's preference  - [% logreq -%]\n");
			route(ROUTE_CHECK_PBX);
			route(ROUTE_INVITE_TO_INT);
		}
	}

	#!ifdef ENABLE_PBX
	if($xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
		pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_callqueue)") &&
		$xavp(callee_real_prefs[0]=>cloud_pbx_callqueue) == 1 &&
		$hdr(P-NGCP-From-CallQueue) != 1 && $avp(s:p_to_group) != 1)
	{
		xlog("L_INFO", "Send PBX call to the queue - [% logreq -%]\n");

		while(pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0])"))
		{
			if(registered("location", "$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0])"))
			{
				$var(cloud_pbx_hg_members) = $var(cloud_pbx_hg_members) + 1;
			}
			pv_unset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0])");
		}
		xlog("L_INFO", "Call to hunt group with '$var(cloud_pbx_hg_members)' members - [% logreq -%]\n");
		# only do this if the caller isn't pbx user already, otherwise it's already done
		if($xavp(caller_real_prefs[0]=>cloud_pbx) != 1)
		{
			append_hf("P-NGCP-Orig-User: $avp(s:acc_callee_user_in)\r\n");
			append_hf("P-NGCP-Orig-Domain: $avp(s:acc_callee_domain_in)\r\n");
			append_hf("P-NGCP-Orig-Dialed: $avp(s:acc_callee_dialed)\r\n");
		}
		if(is_present_hf("P-Caller-CLIR"))
		{
			remove_hf("P-Caller-CLIR");
		}
		append_hf("P-Caller-CLIR: $avp(s:caller_clir)\r\n");

		$var(to_pbx) = 1;
		$var(no_sbc) = 1;
		$var(to_local_endpoint) = 1;
		$var(pbx_app_name) = "callqueues";
		route(ROUTE_OUTBOUND);
	}
	if($xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
		!pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0])") &&
		!($avp(s:from_pbx) == 1 &&
		 ($avp(s:p_to_device) == 1 || $avp(s:p_to_group) == 1)))
	{
		xlog("L_INFO", "Set next hop to pbx because callee is a PBX user - [% logreq -%]\n");

		# only do this if the caller isn't pbx user already, otherwise it's already done
		if($xavp(caller_real_prefs[0]=>cloud_pbx) != 1)
		{
			append_hf("P-NGCP-Orig-User: $avp(s:acc_callee_user_in)\r\n");
			append_hf("P-NGCP-Orig-Domain: $avp(s:acc_callee_domain_in)\r\n");
			append_hf("P-NGCP-Orig-Dialed: $avp(s:acc_callee_dialed)\r\n");
		}

		$var(to_pbx) = 1;
		$var(no_sbc) = 1;
		$var(pbx_app_name) = "sbc";
		setflag(FLAG_SET_RUSER);
		t_on_failure("FAILURE_ROUTE_LOCAL");
		route(ROUTE_OUTBOUND);
	}
	#!endif

	if($avp(s:nohunt) == 1)
	{
		pv_unset("$xavp(callee_real_prefs[0]=>cfu[*])");
	}
	if(pv_isset("$xavp(callee_real_prefs[0]=>cfu[0])") && $avp(s:p_to_group) == 1 &&
	   pv_isset("$xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting)") &&
	   $xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting) == 1)
	{
		xlog("L_NOTICE", "Disregard CFU for callee when called within a hunt group - [% logreq -%]\n");
		pv_unset("$xavp(callee_real_prefs[0]=>cfu[*])");
	}
	while(pv_isset("$xavp(callee_real_prefs[0]=>cfu[0])"))
	{
		$var(cf_id) = $xavp(callee_real_prefs[0]=>cfu[0]);
		xlog("L_NOTICE", "CFU to CF map id '$var(cf_id)' found - [% logreq -%]\n");
		route(ROUTE_LOAD_CF_MAP);
		while($avp(s:p_to_group) == 1 && $avp(s:cf_destinations) != $null &&
		 $(avp(s:cf_destinations)[0]) =~ "^sip:.+@.+\.local$")
		{
			xlog("L_INFO", "Local endpoint '$(avp(s:cf_destinations)[0])' skipped for group hunting - [% logreq -%]\n");
			$(avp(s:cf_timeouts)[0]) = $null;
			$(avp(s:cf_destinations)[0]) = $null;
		}
		if($avp(s:cf_destinations) == $null)
		{
			if($avp(s:p_to_group) == 1)
			{
				xlog("L_NOTICE", "Callee can't receive this call due to forward configuration - [% logreq -%]\n");
				$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
				$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);
				$(avp(s:announce_code)[*]) = 480;
				$(avp(s:announce_reason)[*]) = "Unavailable";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
			else
			{
				xlog("L_NOTICE", "CFU skipped due to forward destinations definitions - [% logreq -%]\n");
			}
		}
		else
		{
			route(ROUTE_CHECK_CF_PERIOD);
			if($rc == 1)
			{
				$ru = $(avp(s:cf_destinations)[0]);
				if($ru =~ "^sip:localuser@.+\.local$")
				{
					t_reset_fr();
					$(avp(s:cf_destinations)[*]) = $null;
					$(avp(s:cf_timeouts)[*]) = $null;
					$(avp(s:cf_periods)[*]) = $null;
					pv_unset("$xavp(callee_real_prefs[0]=>cfu[*])");
					$ru = "sip:" + $avp(s:acc_callee_user) + "@" + $avp(s:acc_callee_domain);
					xlog("L_NOTICE", "Stop hunting for CFU to own subscriber - [% logreq -%]\n");
					break;
				}

				xlog("L_NOTICE", "CFU to destination '$(avp(s:cf_destinations)[0])' with timeout '$(avp(s:cf_timeouts)[0])' activated - [% logreq -%]\n");
				$(avp(s:cf_destinations)[0]) = $null;
				$(avp(s:callee_fr_inv_timer)[*]) = $(avp(s:cf_timeouts)[0]) * 1000;
				t_set_fr("$avp(s:callee_fr_inv_timer)");
				$(avp(s:cf_timeouts)[0]) = $null;
				$(avp(s:cf_depth)[*]) = $(avp(s:cf_depth){s.int}) + 1;
				route(ROUTE_ACC_CF);
				$(avp(s:acc_state)[*]) = "cfu";
				$(avp(s:hih_cause)[*]) = "302";
				$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
				$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
				$(avp(s:acc_caller_user)[*]) = $avp(s:acc_callee_user);
				$(avp(s:acc_caller_domain)[*]) = $avp(s:acc_callee_domain);
				route(ROUTE_EXECUTE_CF_LOOP);
				[% debug_dump('exit', 'ROUTE_INVITE_TO_INT') %]
				exit;
			}
			else
			{
				xlog("L_NOTICE", "CFU skipped due to time period definitions - [% logreq -%]\n");
			}
		}
		pv_unset("$xavp(callee_real_prefs[0]=>cfu[0])");
	}

	#!ifdef ENABLE_PBX
	if(pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy)") &&
	   pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0])"))
	{
		xlog("L_NOTICE", "Call to hunt group - [% logreq -%]\n");
		if(is_present_hf("P-To-Group"))
		{
			remove_hf("P-To-Group");
		}
		append_hf("P-To-Group: 1\r\n");

		if(is_present_hf("P-To-Group-Policy"))
		{
			remove_hf("P-To-Group-Policy");
		}
		append_hf("P-To-Group-Policy: $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy)\r\n");

		if(is_present_hf("P-Caller-CLIR"))
		{
			remove_hf("P-Caller-CLIR");
		}
		append_hf("P-Caller-CLIR: $avp(s:caller_clir)\r\n");

		$var(to_pbx) = 1;
		$var(no_sbc) = 1;

		if($xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy) == "random")
		{
			# lua takes $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group), 
			# randomize it and sets $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy)
			# to serial for sems to use
			if (!lua_run("ngcp_pbx_group_random"))
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				t_newtran();
				t_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
				exit;
			}
		}
		else if($xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy) == "circular")
		{
			xlog("L_INFO", "Circular splice hunt group with uuid '$avp(s:callee_uuid)' [% logreq -%]\n");

			# lua looks up index of last used member in group and reorders the
			# $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group) to start with the
			# next one in the list, and sets
			# $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy) to serial for sems
			# to handle as usual.
			# Further on top, we then take care of incrementing the index for each
			# call going to this hunt group
			if (!lua_run("ngcp_pbx_group_circular"))
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				t_newtran();
				t_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_LOAD_CALLEE_PREF') %]
				exit;
			}
		}

		while(pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0])"))
		{
			if($xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0]) == $fu)
			{
				xlog("L_INFO", "Discard caller URI from hunt group - [% logreq -%]\n");
			}
			else if($var(rgroup_uris) == 0)
			{
				$var(rgroup_uris) = $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0]);
			}
			else
			{
				$var(rgroup_uris) = $var(rgroup_uris) + "," + $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0]);
			}
			pv_unset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_group[0])");
		}
		# $var(rgroup_uris) shall not be cleared until branch route where it is added as header

		xlog("L_NOTICE", "Hunt group destinations list: '$var(rgroup_uris)' - [% logreq -%]\n");

		t_on_failure("FAILURE_ROUTE_LOCAL");
		$(avp(s:to_huntgroup_initial)[*]) = 1;
		route(ROUTE_TO_PBXSRV);
		[% debug_dump('exit', 'ROUTE_INVITE_TO_INT') %]
		exit;
	}
	#!endif
	#Dialog handle: Mark call type
	#FIXME: Should this go after looku(location) block and avoid marks in case we have CF or EARLY_REJECT?
	if($avp(s:from_pstn) == 1)
	{
		lua_run("set_dlg_profile", "$ci", "incoming");
		xlog("L_INFO", "Dialog set mark type to incoming - [% logreq -%]\n");
	}
	else
	{
		lua_run("set_dlg_profile", "$ci", "local");
		xlog("L_INFO", "Dialog set mark type to local - [% logreq -%]\n");
	}

	if(!lookup("location"))
	{
		xlog("L_NOTICE", "Local user offline - [% logreq -%]\n");
		if(pv_isset("$xavp(callee_real_prefs[0]=>cfna[0])") && $avp(s:p_to_group) == 1 &&
		   pv_isset("$xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting)") &&
		   $xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting) == 1)
		{
			xlog("L_NOTICE", "Disregard CFNA for callee when called within a hunt group - [% logreq -%]\n");
			pv_unset("$xavp(callee_real_prefs[0]=>cfna[*])");
		}
		while(pv_isset("$xavp(callee_real_prefs[0]=>cfna[0])"))
		{
			$var(cf_id) = $xavp(callee_real_prefs[0]=>cfna[0]);
			xlog("L_NOTICE", "CFNA to CF map id '$var(cf_id)' found - [% logreq -%]\n");
			route(ROUTE_LOAD_CF_MAP);
			while($avp(s:cf_destinations) != $null && $(avp(s:cf_destinations)[0]) =~ "^sip:localuser@.+\.local$")
			{
				xlog("L_INFO", "CFNA breakout to local user skipped - [% logreq -%]\n");
				$(avp(s:cf_timeouts)[0]) = $null;
				$(avp(s:cf_destinations)[0]) = $null;
			}
			while($avp(s:p_to_group) == 1 && $avp(s:cf_destinations) != $null &&
			 $(avp(s:cf_destinations)[0]) =~ "^sip:.+@.+\.local$")
			{
				xlog("L_INFO", "Local endpoint '$(avp(s:cf_destinations)[0])' skipped for group hunting - [% logreq -%]\n");
				$(avp(s:cf_timeouts)[0]) = $null;
				$(avp(s:cf_destinations)[0]) = $null;
			}
			if($avp(s:cf_destinations) == $null)
			{
				xlog("L_INFO", "CFNA skipped due to forward destinations definitions - [% logreq -%]\n");
			}
			else
			{
				route(ROUTE_CHECK_CF_PERIOD);
				if($rc == 1)
				{

					xlog("L_NOTICE", "CFNA to destination '$(avp(s:cf_destinations)[0])' with timeout '$(avp(s:cf_timeouts)[0])' activated - [% logreq -%]\n");
					$ru = $(avp(s:cf_destinations)[0]);
					$(avp(s:cf_destinations)[0]) = $null;
					$(avp(s:callee_fr_inv_timer)[*]) = $(avp(s:cf_timeouts)[0]) * 1000;
					t_set_fr("$avp(s:callee_fr_inv_timer)");
					$(avp(s:cf_timeouts)[0]) = $null;
					$(avp(s:cf_depth)[*]) = $(avp(s:cf_depth){s.int}) + 1;
					route(ROUTE_ACC_CF);
					$(avp(s:acc_state)[*]) = "cfna";
					$(avp(s:hih_cause)[*]) = "404";
					$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
					$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
					$(avp(s:acc_caller_user)[*]) = $avp(s:acc_callee_user);
					$(avp(s:acc_caller_domain)[*]) = $avp(s:acc_callee_domain);
					route(ROUTE_EXECUTE_CF_LOOP);
					[% debug_dump('exit', 'ROUTE_INVITE_TO_INT') %]
					exit;
				}
				else
				{
					xlog("L_NOTICE", "CFNA skipped due to time period definitions - [% logreq -%]\n");
				}
			}
			pv_unset("$xavp(callee_real_prefs[0]=>cfna[0])");
		}
		if($xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer) == "force_offline" ||
		   $xavp(caller_peer_prefs[0]=>force_outbound_calls_to_peer) == "force_offline")
		{
			xlog("L_NOTICE", "Force on-net call to peer by caller's preference - [% logreq -%]\n");
			if($avp(s:callee_base_user) != $null)
			{
				$rU = $avp(s:callee_base_user);
				xlog("L_NOTICE", "Local user is being relayed by caller, using alias as user - [% logreq -%]\n");
			}
			else if($avp(s:acc_callee_user_in) != $null)
			{
				$rU = $avp(s:acc_callee_user_in);
				xlog("L_NOTICE", "Local user is being relayed by caller, using alias as user - [% logreq -%]\n");
			}
			route(ROUTE_CHECK_PBX);
			route(ROUTE_INVITE_TO_EXT);
		}
		else if($avp(s:is_primary) == 0 &&
		  ($xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer) == "force_offline_alias" ||
		   $xavp(caller_peer_prefs[0]=>force_outbound_calls_to_peer) == "force_offline_alias"))
		{
			xlog("L_NOTICE", "Force on-net call to offline alias to peer by caller's preference - [% logreq -%]\n");
			if($avp(s:callee_base_user) != $null)
			{
				$rU = $avp(s:callee_base_user);
				xlog("L_NOTICE", "Local user is being relayed by caller, using alias as user - [% logreq -%]\n");
			}
			else if($avp(s:acc_callee_user_in) != $null)
			{
				$rU = $avp(s:acc_callee_user_in);
				xlog("L_NOTICE", "Local user is being relayed by caller, using alias as user - [% logreq -%]\n");
			}
			route(ROUTE_CHECK_PBX);
			route(ROUTE_INVITE_TO_EXT);
		}
		else if($avp(s:is_primary) == 1 &&
		  ($xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer) == "force_offline_primary" ||
		   $xavp(caller_peer_prefs[0]=>force_outbound_calls_to_peer) == "force_offline_primary"))
		{
			xlog("L_NOTICE", "Force on-net call to offline primary number to peer by caller's preference - [% logreq -%]\n");
			if($avp(s:callee_base_user) != $null)
			{
				$rU = $avp(s:callee_base_user);
				xlog("L_NOTICE", "Local user is being relayed by caller, using alias as user - [% logreq -%]\n");
			}
			else if($avp(s:acc_callee_user_in) != $null)
			{
				$rU = $avp(s:acc_callee_user_in);
				xlog("L_NOTICE", "Local user is being relayed by caller, using alias as user - [% logreq -%]\n");
			}
			route(ROUTE_CHECK_PBX);
			route(ROUTE_INVITE_TO_EXT);
		}
		#!ifdef ENABLE_PRESENCE
		if($xavp(callee_real_prefs[0]=>mobile_push_enable) == 1)
		{
			if($var(from_push_server) == 1)
			{
				xlog("L_NOTICE", "User is not registered after push, something went wrong - [% logreq -%]\n");
			}
			else
			{
				t_on_failure("FAILURE_ROUTE_APPSRV");
				route(ROUTE_TO_PUSHSRV);
				[% debug_dump('exit', 'ROUTE_INVITE_TO_INT') %]
				exit;
			}
		}
		#!endif
		$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
		$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);
		if($avp(s:p_to_group) != 1 && $avp(hih_cause) == 0 && $avp(s:from_pbx) != 1)
		{
			$var(announce_handle) = "callee_offline";
			$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
		}
		else
		{
			$var(announce_handle) = "";
			$var(announce_set) = 0;
		}
		$(avp(s:announce_code)[*]) = 480;
		$(avp(s:announce_reason)[*]) = "Offline";
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_EARLY_REJECT);
	}
	else
	{
		if($xavp(callee_real_prefs[0]=>serial_forking_by_q_value) == 1)
		{
			if(t_load_contacts())
			{
				if(t_next_contacts())
				{
					setflag(FLAG_SET_RUSER);
					t_on_failure("FAILURE_ROUTE_LOCAL");
					t_on_branch_failure("redirect");
					route(ROUTE_OUTBOUND);
				}
				else
				{
					# t_next_contacts() returns -2 if contacts_avp is empty, e.g. serial
					# forking is enabled but there is only one contact
					setflag(FLAG_SET_RUSER);
					t_on_failure("FAILURE_ROUTE_LOCAL");
					t_on_branch_failure("redirect");
					route(ROUTE_OUTBOUND);
				}
			}
		}
		else
		{
			setflag(FLAG_SET_RUSER);
			t_on_failure("FAILURE_ROUTE_LOCAL");
			t_on_branch_failure("redirect");
			route(ROUTE_OUTBOUND);
		}
	}
	[% debug_dump('exit', 'ROUTE_INVITE_TO_INT') %]
	exit;
}

########################################################################
# Handle special $rU assignments for calls to extensions/aliases
########################################################################
route[ROUTE_SET_RUSER]
{
	[% debug_dump('start', 'ROUTE_SET_RUSER') %]
	if($avp(s:has_extension) == 1)
	{
		if($xavp(callee_real_prefs[0]=>extended_dialing_mode) == "extended_send_dialed" && $avp(s:acc_callee_user_in) != $null)
		{
			# if there's an extension, first send dialed number; on 404, send real user
			$rU = $avp(s:acc_callee_user_in);
			xlog("L_NOTICE", "Using full extensioned alias as user - [% logreq -%]\n");
		}
		else
		# if($xavp(callee_real_prefs[0]=>extended_dialing_mode) == "extended_send_base")
		{
			#$rU = $avp(s:callee_base_user);
			xlog("L_INFO", "Keep existing username/ base number as user - [% logreq -%]\n");
		}
	}
	else if($xavp(callee_real_prefs[0]=>e164_to_ruri) == 1 && !isflagset(FLAG_IN_FALLBACK) && $xavp(caller_peer_prefs[0]=>find_subscriber_by_uuid) != 1)
	{
		# send the dialed alias; on 404 send real user
		if($avp(s:callee_base_user) != $null)
		{
			$rU = $avp(s:callee_base_user);
			xlog("L_NOTICE", "Local user online, using alias as user - [% logreq -%]\n");
		}
		else if($avp(s:acc_callee_user_in) != $null)
		{
			$rU = $avp(s:acc_callee_user_in);
			xlog("L_NOTICE", "Local user online, using acc_callee_user_in as user - [% logreq -%]\n");
		}
	}
	else if($xavp(callee_real_prefs[0]=>force_inbound_calls_to_peer) == 1)
	{
		if($avp(s:callee_base_user) != $null)
		{
			$rU = $avp(s:callee_base_user);
			xlog("L_NOTICE", "Local user is being relayed by callee, using alias as user - [% logreq -%]\n");
		}
	}
	else if($avp(s:callee_uuid) != "0")
	{
		xlog("L_INFO", "Local user online, using registered contact as user - [% logreq -%]\n");
	}
	[% debug_dump('end', 'ROUTE_SET_RUSER') %]
}

########################################################################
# Request route 'invite-to-external'
########################################################################
route[ROUTE_INVITE_TO_EXT]
{
	[% debug_dump('start', 'ROUTE_INVITE_TO_EXT') %]
	if($avp(s:from_pstn) != 1 && $avp(s:from_faxserver) != 1)
	{
		if($var(no_auth) == 1)
		{
			xlog("L_NOTICE", "Call to unknown local user from unauthenticated foreign domain - [% logreq -%]\n");
			$(avp(s:acc_callee_user)[*]) = $rU;
			$(avp(s:acc_callee_domain)[*]) = $rd;

			$var(announce_handle) = "callee_unknown";
			$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 404;
			$(avp(s:announce_reason)[*]) = "Not Found";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}

		if($var(external_domain) == 1)
		{
			xlog("L_NOTICE", "Call to foreign domain - [% logreq -%]\n");
			$var(to_pstn) = 1;

			#Dialog handle call type to foreign domain
			lua_run("set_dlg_profile", "$ci", "outgoing");
			xlog("L_INFO", "Dialog set mark type to outgoing - [% logreq -%]\n");

			#!ifdef FOREIGN_DOMAIN_VIA_PEER
			route(ROUTE_PSTN);
			#!else
			route(ROUTE_OUTBOUND);
			#!endif
		}
	}

	#!ifdef USE_ENUM
	route(ROUTE_LOOKUP_ENUM);
	#!endif
	setflag(FLAG_SET_RUSER);
	if($avp(s:from_pstn) != 1 || $var(forward) == 1 || $var(cf_loop) == 1 || 
	   $xavp(caller_peer_prefs[0]=>force_outbound_calls_to_peer) =~ "^force" ||
	   $xavp(caller_peer_prefs[0]=>force_outbound_calls_to_peer) =~ "^force_nonlocal")
	{
		route(ROUTE_PSTN);
	}

	#!ifdef PEER_RELAY
	if ($avp(s:from_pstn) == 1)
	{
		xlog("L_NOTICE", "Performing peer relay - [% logreq -%]\n");
		route(ROUTE_PSTN);
	}
	#!endif


	xlog("L_NOTICE", "Call to unknown user - [% logreq -%]\n");
	$(avp(s:acc_callee_user)[*]) = $rU;
	$(avp(s:acc_callee_domain)[*]) = $rd;

	$var(announce_handle) = "callee_unknown";
	$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
	$(avp(s:announce_code)[*]) = 404;
	$(avp(s:announce_reason)[*]) = "Not Found";
	route(ROUTE_ACC_FAILURE);
	route(ROUTE_EARLY_REJECT);
	[% debug_dump('end', 'ROUTE_INVITE_TO_EXT') %]
}

########################################################################
# Request route to prepare headers for CF loop
########################################################################
route[ROUTE_EXECUTE_CF_LOOP]
{
	[% debug_dump('start', 'ROUTE_EXECUTE_CF_LOOP') %]
	if(!t_is_failure_route())
	{
		record_route();
		route(ROUTE_SET_CALLER_DIALOG);
	}
	$var(count_dlg) = 0;
	$du = "sip:[% sip_int_ips.0 %]:[% kamailio.proxy.port %]";
	xlog("L_INFO", "Trigger CF loop to '$du' for call to '$ru' - [% logreq -%]\n");
	t_on_failure("FAILURE_ROUTE_HUNT");
	t_on_branch("BRANCH_ROUTE_FWD_LOOP");
	t_relay_to("0x01");
	[% debug_dump('exit', 'ROUTE_EXECUTE_CF_LOOP') %]
	exit;
}

#!ifdef USE_ENUM
########################################################################
# Request route 'lookup-enum'
########################################################################
route[ROUTE_LOOKUP_ENUM]
{
	[% debug_dump('start', 'ROUTE_LOOKUP_ENUM') %]
	if(uri =~ "^sip:[1-9][0-9]+@")
	{
		$var(tmpuri) = $ru;
		prefix("+");
		if(enum_query("[% kamailio.proxy.enum_suffix %]"))
		{
			xlog("L_NOTICE", "ENUM query succeeded - [% logreq -%]\n");
			if(avp_check("$xavp(caller_real_prefs[0]=>lock)", "eq/s:1"))
			{
				xlog("L_NOTICE", "Caller locked for offnet with mode '$xavp(caller_real_prefs[0]=>lock)' - [% logreq -%]\n");
				$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
				$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

				$var(announce_handle) = "locked_out";
				$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
				$(avp(s:announce_code)[*]) = 403;
				$(avp(s:announce_reason)[*]) = "Caller locked";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}

			$(avp(s:callee_user)[*]) = $rU;
			$(avp(s:callee_domain)[*]) = $rd;
			$var(to_pstn) = 1;
			#!ifdef FOREIGN_DOMAIN_VIA_PEER
			route(ROUTE_PSTN);
			#!else
			route(ROUTE_OUTBOUND);
			#!endif
			[% debug_dump('exit', 'ROUTE_LOOKUP_ENUM') %]
			exit;
		}
		else
		{
			xlog("L_NOTICE", "ENUM query failed - [% logreq -%]\n");
			# ENUM query failed, revert $rU
			$ru = $var(tmpuri);
		}
	}
	[% debug_dump('end', 'ROUTE_LOOKUP_ENUM') %]
}
#!endif

########################################################################
# Request route 'base-route-local'
########################################################################
route[ROUTE_LOCAL]
{
	[% debug_dump('start', 'ROUTE_LOCAL') %]
	t_on_reply("REPLY_ROUTE_STD");
	if(t_check_trans())
	{
		xlog("L_NOTICE", "Request leaving server via local route - [% logreq -%]\n");
		if(!t_relay())
		{
			sl_reply_error();
		}
	}
	else
	{
		xlog("L_NOTICE", "Dropping mis-routed request - [% logreq -%]\n");
	}
	[% debug_dump('exit', 'ROUTE_LOCAL') %]
	exit;
}

########################################################################
# Request route 'base-route-generic'
########################################################################
route[ROUTE_NOT_SUPPORTED]
{
	[% debug_dump('start', 'ROUTE_NOT_SUPPORTED') %]
	xlog("L_NOTICE", "Method not supported - [% logreq -%]\n");
	sl_send_reply("501", "Method Not Supported Here");
	[% debug_dump('exit', 'ROUTE_NOT_SUPPORTED') %]
	exit;
}

########################################################################
# Request route 'base-filter-failover'
########################################################################
route[ROUTE_FILTER_FAILOVER]
{
	[% debug_dump('start', 'ROUTE_FILTER_FAILOVER') %]
	xlog("L_INFO", "Filter reply code - [% logreq -%]\n");
	if(!t_check_status("408|500|503"))
	{
		xlog("L_NOTICE", "No failover routing needed for this response code - [% logreq -%]\n");
		route(ROUTE_STOP_RTPPROXY_BRANCH);
		#!ifdef ENABLE_PBX
		if(pv_isset("$avp(s:sca_active)"))
		{
			sca_call_info_update();
		}
		#!endif
		[% debug_dump('exit', 'ROUTE_FILTER_FAILOVER') %]
		exit;
	}
	[% debug_dump('end', 'ROUTE_FILTER_FAILOVER') %]
}


########################################################################
# Load sound file id for music-on-hold
########################################################################
route[ROUTE_PREPARE_MOH_PBX]
{
	[% debug_dump('start', 'ROUTE_PREPARE_MOH_PBX') %]
	$(avp(s:moh_loop)[*]) = $null;
	$var(tmpsetid) = 0;
	if($var(from_pbx_initial) == 1 && 
	   $xavp(caller_real_prefs[0]=>music_on_hold) == 1 &&
	   pv_isset("$xavp(caller_real_prefs[0]=>contract_sound_set)"))
	{
		$var(tmpsetid) = $xavp(caller_real_prefs[0]=>contract_sound_set);
	}
	if($var(tmpsetid) != 0)
	{
		avp_db_query("select vsf.loopplay from provisioning.voip_sound_files vsf, provisioning.voip_sound_sets vss, provisioning.voip_sound_handles vfh where vfh.name='music_on_hold' and vss.id=$var(tmpsetid) and vsf.handle_id=vfh.id and vsf.set_id=vss.id","$avp(s:moh_loop)");

		if($avp(s:moh_loop) == 1)
		{
			$(avp(s:moh_loop)[*]) = "yes";
		}
		else
		{
			$(avp(s:moh_loop)[*]) = "no";
		}
		$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";pbx_moh_b=yes;pbx_moh_b_id=" + $var(tmpsetid) + ";pbx_moh_b_loop=" + $avp(s:moh_loop);
	}

	$(avp(s:moh_loop)[*]) = $null;
	$var(tmpsetid) = 0;
	if($xavp(callee_real_prefs[0]=>music_on_hold) == 1 &&
	   pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") && pv_isset("$xavp(callee_real_prefs[0]=>contract_sound_set)"))
	{
		$var(tmpsetid) = $xavp(callee_real_prefs[0]=>contract_sound_set);
		xlog("L_NOTICE", "Setting callee contract_sound_set id '$var(tmpsetid)' for PBX MoH - [% logreq -%]\n");
	}
	if($var(tmpsetid) != 0)
	{
		avp_db_query("select vsf.loopplay from provisioning.voip_sound_files vsf, provisioning.voip_sound_sets vss, provisioning.voip_sound_handles vfh where vfh.name='music_on_hold' and vss.id=$var(tmpsetid) and vsf.handle_id=vfh.id and vsf.set_id=vss.id","$avp(s:moh_loop)");

		if($avp(s:moh_loop) == 1)
		{
			$(avp(s:moh_loop)[*]) = "yes";
		}
		else
		{
			$(avp(s:moh_loop)[*]) = "no";
		}
		$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";pbx_moh_a=yes;pbx_moh_a_id=" + $var(tmpsetid) + ";pbx_moh_a_loop=" + $avp(s:moh_loop);
	}
	[% debug_dump('end', 'ROUTE_PREPARE_MOH_PBX') %]
}

########################################################################
# Load sound file id for music-on-hold
########################################################################
route[ROUTE_PREPARE_MOH]
{
	[% debug_dump('start', 'ROUTE_PREPARE_MOH') %]
	$(avp(s:moh_id)[*]) = $null;
	$(avp(s:moh_loop)[*]) = $null;
	if((pv_isset("$xavp(caller_real_prefs[0]=>cloud_pbx)") &&
	    $xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
	    $xavp(caller_real_prefs[0]=>music_on_hold) == 1 &&
	    pv_isset("$xavp(caller_real_prefs[0]=>sound_set)")) ||
	   (!pv_isset("$xavp(caller_real_prefs[0]=>cloud_pbx)") &&
	    pv_isset("$xavp(caller_real_prefs[0]=>sound_set)")))
	{
		avp_db_query("select vsf.id, vsf.loopplay from provisioning.voip_sound_files vsf, provisioning.voip_sound_sets vss, provisioning.voip_sound_handles vfh where vfh.name='music_on_hold' and vss.id=$xavp(caller_real_prefs[0]=>sound_set) and vsf.handle_id=vfh.id and vsf.set_id=vss.id","$avp(s:moh_id);$avp(s:moh_loop)");

		if($avp(s:moh_id) != $null)
		{
			if($avp(s:moh_loop) == 1)
			{
				$(avp(s:moh_loop)[*]) = "yes";
			}
			else
			{
				$(avp(s:moh_loop)[*]) = "no";
			}
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";moh_b=yes;moh_b_id=" + $avp(s:moh_id) + ";moh_b_loop=" + $avp(s:moh_loop);
		}
	}

	$(avp(s:moh_id)[*]) = $null;
	$(avp(s:moh_loop)[*]) = $null;
	if((pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") &&
	    $xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
	    $xavp(callee_real_prefs[0]=>music_on_hold) == 1 &&
	    pv_isset("$xavp(callee_real_prefs[0]=>sound_set)")) ||
	   (!pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") &&
	    pv_isset("$xavp(callee_real_prefs[0]=>sound_set)")))
	{
		avp_db_query("select vsf.id, vsf.loopplay from provisioning.voip_sound_files vsf, provisioning.voip_sound_sets vss, provisioning.voip_sound_handles vfh where vfh.name='music_on_hold' and vss.id=$xavp(callee_real_prefs[0]=>sound_set) and vsf.handle_id=vfh.id and vsf.set_id=vss.id","$avp(s:moh_id);$avp(s:moh_loop)");

		if($avp(s:moh_id) != $null)
		{
			if($avp(s:moh_loop) == 1)
			{
				$(avp(s:moh_loop)[*]) = "yes";
			}
			else
			{
				$(avp(s:moh_loop)[*]) = "no";
			}
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";moh_a=yes;moh_a_id=" + $avp(s:moh_id) + ";moh_a_loop=" + $avp(s:moh_loop);
		}
	}
	[% debug_dump('end', 'ROUTE_PREPARE_MOH') %]
}


########################################################################
# Load sound file id for early media announcement and send to media srv
# Requires: $var(announce_handle), $var(announce_set),
#	   $avp(s:announce_code), $avp(s:announce_reason)
# Returns: never
########################################################################
route[ROUTE_EARLY_REJECT]
{
	[% debug_dump('start', 'ROUTE_EARLY_REJECT') %]
	if(!t_is_failure_route() && !t_check_trans())
	{
		t_newtran();
	}
	if($var(announce_set) == 0)
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
		[% debug_dump('exit', 'ROUTE_EARLY_REJECT') %]
		exit;
	}

	$(avp(s:announce_file_id)[*]) = $null;
	$(avp(s:announce_loop)[*]) = $null;

	avp_db_query("select vsf.id, vsf.loopplay from provisioning.voip_sound_files vsf, provisioning.voip_sound_sets vss, provisioning.voip_sound_handles vfh where vfh.name='$var(announce_handle)' and vss.id=$var(announce_set) and vsf.handle_id=vfh.id and vsf.set_id=vss.id","$avp(s:announce_file_id);$avp(s:announce_loop)");

	if($avp(s:announce_file_id) == $null)
	{
		xlog("L_INFO", "No audio file for sound set id '$var(announce_set)' and handle '$var(announce_handle)' found - [% logreq -%]\n");
		route(ROUTE_ADD_CALLINFO_REPLY);
		t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
		[% debug_dump('exit', 'ROUTE_EARLY_REJECT') %]
		exit;
	}

	if($avp(s:announce_loop) == 1)
	{
		$(avp(s:announce_loop)[*]) = "yes";
	}
	else
	{
		$(avp(s:announce_loop)[*]) = "no";
	}

	if(is_present_hf("P-App-Param"))
	{
		remove_hf("P-App-Param");
	}
	append_hf("P-App-Param: audio_id=$avp(s:announce_file_id);play_looped=$avp(s:announce_loop);fr_code=$avp(s:announce_code);fr_reason=\"$avp(s:announce_reason)\"\r\n");
	if(is_present_hf("P-App-Name"))
	{
		remove_hf("P-App-Name");
	}
	append_hf("P-App-Name: early_dbprompt\r\n");
	$rU = "earlyannounce";
	xlog("L_INFO", "Relaying request to media server with params 'audio_id=$avp(s:announce_file_id);play_looped=$avp(s:announce_loop);fr_code=$avp(s:announce_code);fr_reason=\"$avp(s:announce_reason)\"' - [% logreq -%]\n");

	t_on_failure("FAILURE_ROUTE_EARLY_REJECT");
	route(ROUTE_TO_APPSRV);
	[% debug_dump('exit', 'ROUTE_EARLY_REJECT') %]
	exit;
}



########################################################################
# Check outgoing block list
########################################################################
route[ROUTE_BLOCK_OUT]
{
	[% debug_dump('start', 'ROUTE_BLOCK_OUT') %]
	# TODO: set correct sip code or reason for accounting

	$var(announce_handle) = "block_out";
	$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
	$(avp(s:announce_code)[*]) = 403;

	$var(blockuri) = "sip:" + $rU + "@" + $rd;

	if($var(contract_adm_block_override) == 1)
	{
		xlog("L_INFO", "Administrative Contract Block Out overridden, skip - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_BLOCK_OUT') %]
		return;
	}

	xlog("L_INFO", "Checking URI '$var(blockuri)' and CLI '$avp(s:callee_cli)' against admin contract block out lists - [% logreq -%]\n");
	if($xavp(caller_contract_prefs[0]=>adm_block_out_mode) == 1)
	{
		xlog("L_INFO", "Admin Contract caller block mode is 'whitelist' - [% logreq -%]\n");
		if(!avp_check("$var(blockuri)", "fm/$xavp(caller_contract_prefs[0]=>adm_block_out_list[*])/g") &&
		   !avp_check("$avp(s:callee_cli)", "fm/$xavp(caller_contract_prefs[0]=>adm_block_out_list[*])/g"))
		{
			xlog("L_NOTICE", "Callee blocked by Admin Contract in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}

	}
	else
	{
		xlog("L_INFO", "Admin Contract caller block mode is 'blacklist' - [% logreq -%]\n");
		if(avp_check("$var(blockuri)", "fm/$xavp(caller_contract_prefs[0]=>adm_block_out_list[*])/g") ||
		   avp_check("$avp(s:callee_cli)", "fm/$xavp(caller_contract_prefs[0]=>adm_block_out_list[*])/g"))
		{
			xlog("L_NOTICE", "Callee blocked by Admin Contract in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}

	if($var(adm_block_override) == 1)
	{
		xlog("L_INFO", "Administrative Block Out overridden, skip - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_BLOCK_OUT') %]
		return;
	}

	xlog("L_INFO", "Checking URI '$var(blockuri)' and CLI '$avp(s:callee_cli)' against block out lists - [% logreq -%]\n");
	if($xavp(caller_real_prefs[0]=>adm_block_out_mode) == 1)
	{
		xlog("L_INFO", "Admin caller block mode is 'whitelist' - [% logreq -%]\n");
		if(!avp_check("$var(blockuri)", "fm/$xavp(caller_real_prefs[0]=>adm_block_out_list[*])/g") &&
		   !avp_check("$avp(s:callee_cli)", "fm/$xavp(caller_real_prefs[0]=>adm_block_out_list[*])/g"))
		{
			xlog("L_NOTICE", "Callee blocked by Admin in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}

	}
	else
	{
		xlog("L_INFO", "Admin caller block mode is 'blacklist' - [% logreq -%]\n");
		if(avp_check("$var(blockuri)", "fm/$xavp(caller_real_prefs[0]=>adm_block_out_list[*])/g") ||
		   avp_check("$avp(s:callee_cli)", "fm/$xavp(caller_real_prefs[0]=>adm_block_out_list[*])/g"))
		{
			xlog("L_NOTICE", "Callee blocked by Admin in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}

	if($var(contract_block_override) == 1)
	{
		xlog("L_INFO", "Contract Block Out overridden, skip - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_BLOCK_OUT') %]
		return;
	}

	xlog("L_INFO", "Checking URI '$var(blockuri)' and CLI '$avp(s:callee_cli)' against contract block out lists - [% logreq -%]\n");
	if($xavp(caller_contract_prefs[0]=>block_out_mode) == 1)
	{
		xlog("L_INFO", "Contract caller block mode is 'whitelist' - [% logreq -%]\n");
		if(!avp_check("$var(blockuri)", "fm/$xavp(caller_contract_prefs[0]=>block_out_list[*])/g") &&
		   !avp_check("$avp(s:callee_cli)", "fm/$xavp(caller_contract_prefs[0]=>block_out_list[*])/g"))
		{
			xlog("L_NOTICE", "Callee blocked by Contract in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Contract";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}

	}
	else
	{
		xlog("L_INFO", "Contract caller block mode is 'blacklist' - [% logreq -%]\n");
		if(avp_check("$var(blockuri)", "fm/$xavp(caller_contract_prefs[0]=>block_out_list[*])/g") ||
		   avp_check("$avp(s:callee_cli)", "fm/$xavp(caller_contract_prefs[0]=>block_out_list[*])/g"))
		{
			xlog("L_NOTICE", "Callee blocked by Contract in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Contract";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}

	if($var(block_override) == 1)
	{
		xlog("L_INFO", "Block Out overridden, skip - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_BLOCK_OUT') %]
		return;
	}

	if($xavp(caller_real_prefs[0]=>block_out_mode) == 1)
	{
		xlog("L_INFO", "Caller block mode is 'whitelist' - [% logreq -%]\n");
		if(!avp_check("$var(blockuri)", "fm/$xavp(caller_real_prefs[0]=>block_out_list[*])/g") &&
		   !avp_check("$avp(s:callee_cli)", "fm/$xavp(caller_real_prefs[0]=>block_out_list[*])/g"))
		{
			xlog("L_NOTICE", "Callee blocked by caller in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Caller";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}

	}
	else
	{
		xlog("L_INFO", "Caller block mode is 'blacklist' - [% logreq -%]\n");
		if(avp_check("$var(blockuri)", "fm/$xavp(caller_real_prefs[0]=>block_out_list[*])/g") ||
		   avp_check("$avp(s:callee_cli)", "fm/$xavp(caller_real_prefs[0]=>block_out_list[*])/g"))
		{
			xlog("L_NOTICE", "Callee blocked by caller in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Caller";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}
	[% debug_dump('end', 'ROUTE_BLOCK_OUT') %]
}

########################################################################
# Check incoming block list
########################################################################
route[ROUTE_BLOCK_IN]
{
	[% debug_dump('start', 'ROUTE_BLOCK_IN') %]
	# TODO: set correct sip code or reason for accounting
	if($avp(s:from_faxserver) == 1 || $avp(s:from_voicebox) == 1)
	{
		[% debug_dump('return', 'ROUTE_BLOCK_IN') %]
		return;
	}

	$var(announce_handle) = "block_in";
	$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
	$(avp(s:announce_code)[*]) = 403;

	xlog("L_INFO", "Checking UPN '$avp(s:caller_cli_userprov)' and NPN '$avp(s:caller_cli_netprov)' against block in lists - [% logreq -%]\n");
	if(pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") && $xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
	   pv_isset("$avp(s:first_caller_pbx_account_id)") &&
	   $avp(s:first_caller_pbx_account_id) == $xavp(callee_real_prefs[0]=>account_id) && $avp(s:caller_clir) == 1)
	{
		xlog("L_INFO", "Anonymous caller allowed within the same hosted PBX - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_BLOCK_IN') %]
		return;
	}
	if($xavp(callee_contract_prefs[0]=>adm_block_in_mode) == 1)
	{
		xlog("L_INFO", "Admin Contract callee block mode is 'whitelist' - [% logreq -%]\n");
		if($avp(s:caller_clir) == 1 && $xavp(callee_contract_prefs[0]=>adm_block_in_clir) == 0)
		{
			# also block CLIR in whitelist-mode if block_in_clir is unset
			xlog("L_NOTICE", "Anonymous caller blocked by Admin Contract in 'whitelist' mode - [% logreq -%]\n");
			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else if(!avp_check("$avp(s:caller_cli_userprov)", "fm/$xavp(callee_contract_prefs[0]=>adm_block_in_list[*])/g") &&
		   !avp_check("$avp(s:caller_cli_netprov)", "fm/$xavp(callee_contract_prefs[0]=>adm_block_in_list[*])/g") &&
		   $avp(s:caller_clir) != 1) # allow anonymous calls that passed callee_block_in_clir check
		{
			xlog("L_NOTICE", "Caller blocked by Admin Contract in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}
	else
	{
		xlog("L_INFO", "Admin Contract callee block mode is 'blacklist' - [% logreq -%]\n");
		if($avp(s:caller_clir) != 1 &&
		  (avp_check("$avp(s:caller_cli_userprov)", "fm/$xavp(callee_contract_prefs[0]=>adm_block_in_list[*])/g") ||
		   avp_check("$avp(s:caller_cli_netprov)", "fm/$xavp(callee_contract_prefs[0]=>adm_block_in_list[*])/g")))
		{
			xlog("L_NOTICE", "Caller blocked by Admin Contract in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else if($avp(s:caller_clir) == 1 && $xavp(callee_contract_prefs[0]=>adm_block_in_clir) == 1)
		{
			xlog("L_NOTICE", "Anonymous caller blocked by Admin Contract in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}

	if($xavp(callee_real_prefs[0]=>adm_block_in_mode) == 1)
	{
		xlog("L_INFO", "Admin callee block mode is 'whitelist' - [% logreq -%]\n");
		if($avp(s:caller_clir) == 1 && $xavp(callee_real_prefs[0]=>adm_block_in_clir) == 0)
		{
			# also block CLIR in whitelist-mode if block_in_clir is unset
			xlog("L_NOTICE", "Anonymous caller blocked by Admin in 'whitelist' mode - [% logreq -%]\n");
			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else if(!avp_check("$avp(s:caller_cli_userprov)", "fm/$xavp(callee_real_prefs[0]=>adm_block_in_list[*])/g") &&
		   !avp_check("$avp(s:caller_cli_netprov)", "fm/$xavp(callee_real_prefs[0]=>adm_block_in_list[*])/g") &&
		   $avp(s:caller_clir) != 1) # allow anonymous calls that passed callee_block_in_clir check
		{
			xlog("L_NOTICE", "Caller blocked by Admin in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}
	else
	{
		xlog("L_INFO", "Admin callee block mode is 'blacklist' - [% logreq -%]\n");
		if($avp(s:caller_clir) != 1 &&
		  (avp_check("$avp(s:caller_cli_userprov)", "fm/$xavp(callee_real_prefs[0]=>adm_block_in_list[*])/g") ||
		   avp_check("$avp(s:caller_cli_netprov)", "fm/$xavp(callee_real_prefs[0]=>adm_block_in_list[*])/g")))
		{
			xlog("L_NOTICE", "Caller blocked by Admin in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else if($avp(s:caller_clir) == 1 && $xavp(callee_real_prefs[0]=>adm_block_in_clir) == 1)
		{
			xlog("L_NOTICE", "Anonymous caller blocked by Admin in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Admin";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}

	if($xavp(callee_contract_prefs[0]=>block_in_mode) == 1)
	{
		xlog("L_INFO", "Contract callee block mode is 'whitelist' - [% logreq -%]\n");
		if($avp(s:caller_clir) == 1 && $xavp(callee_contract_prefs[0]=>block_in_clir) == 0)
		{
			# also block CLIR in whitelist-mode if block_in_clir is unset
			xlog("L_NOTICE", "Anonymous caller blocked by Contract in 'whitelist' mode - [% logreq -%]\n");
			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Contract";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else if(!avp_check("$avp(s:caller_cli_userprov)", "fm/$xavp(callee_contract_prefs[0]=>block_in_list[*])/g") &&
		   !avp_check("$avp(s:caller_cli_netprov)", "fm/$xavp(callee_contract_prefs[0]=>block_in_list[*])/g") &&
		   $avp(s:caller_clir) != 1) # allow anonymous calls that passed callee_block_in_clir check
		{
			xlog("L_NOTICE", "Caller blocked by Contract in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Contract";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}
	else
	{
		xlog("L_INFO", "Contract callee block mode is 'blacklist' - [% logreq -%]\n");
		if($avp(s:caller_clir) != 1 &&
		  (avp_check("$avp(s:caller_cli_userprov)", "fm/$xavp(callee_contract_prefs[0]=>block_in_list[*])/g") ||
		   avp_check("$avp(s:caller_cli_netprov)", "fm/$xavp(callee_contract_prefs[0]=>block_in_list[*])/g")))
		{
			xlog("L_NOTICE", "Caller blocked by Contract in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Contract";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else if($avp(s:caller_clir) == 1 && $xavp(callee_contract_prefs[0]=>block_in_clir) == 1)
		{
			xlog("L_NOTICE", "Anonymous caller blocked by Contract in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Contract";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}

	if($xavp(callee_real_prefs[0]=>block_in_mode) == 1)
	{
		xlog("L_INFO", "Callee block mode is 'whitelist' - [% logreq -%]\n");
		if($avp(s:caller_clir) == 1 && $xavp(callee_real_prefs[0]=>block_in_clir) == 0)
		{
			# also block CLIR in whitelist-mode if block_in_clir is unset
			xlog("L_NOTICE", "Anonymous caller blocked by callee in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Callee";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else if(!avp_check("$avp(s:caller_cli_userprov)", "fm/$xavp(callee_real_prefs[0]=>block_in_list[*])/g") &&
		   !avp_check("$avp(s:caller_cli_netprov)", "fm/$xavp(callee_real_prefs[0]=>block_in_list[*])/g") &&
		   $avp(s:caller_clir) != 1) # allow anonymous calls that passed callee_block_in_clir check
		{
			xlog("L_NOTICE", "Caller blocked by callee in 'whitelist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Callee";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}
	else
	{
		xlog("L_INFO", "Callee block mode is 'blacklist' - [% logreq -%]\n");
		if($avp(s:caller_clir) != 1 &&
		  (avp_check("$avp(s:caller_cli_userprov)", "fm/$xavp(callee_real_prefs[0]=>block_in_list[*])/g") ||
		   avp_check("$avp(s:caller_cli_netprov)", "fm/$xavp(callee_real_prefs[0]=>block_in_list[*])/g")))
		{
			xlog("L_NOTICE", "Caller blocked by callee in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Callee";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else if($avp(s:caller_clir) == 1 && $xavp(callee_real_prefs[0]=>block_in_clir) == 1)
		{
			xlog("L_NOTICE", "Anonymous caller blocked by callee in 'blacklist' mode - [% logreq -%]\n");

			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by Callee";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
	}
	[% debug_dump('end', 'ROUTE_BLOCK_IN') %]
}

########################################################################
# Check NCOS levels
########################################################################
route[ROUTE_NCOS]
{
	[% debug_dump('start', 'ROUTE_NCOS') %]
	if($avp(s:tmp_ncos_id) != $null)
	{
		$var(announce_handle) = "block_ncos";
		$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
		$(avp(s:announce_code)[*]) = 403;

		xlog("L_INFO", "Check NCOS level id '$avp(s:tmp_ncos_id)' against callee '$avp(s:callee_cli)' - [% logreq -%]\n");

		$(avp(s:ncos_local_ac)[*]) = $null;
		$(avp(s:ncos_mode)[*]) = $null;
		$(avp(s:ncos_result)[*]) = $null;
		$(avp(s:tmp)[*]) = $avp(s:caller_cc) + $avp(s:caller_ac) + "*";

		avp_db_query("select nl.local_ac, nl.mode, convert(if(nl.mode = 'whitelist', max('$(avp(s:callee_cli){s.escape.common})' regexp(nlp.pattern)), min('$(avp(s:callee_cli){s.escape.common})' not regexp(nlp.pattern))), char(255)) as result from billing.ncos_levels nl left join billing.ncos_pattern_list nlp on nlp.ncos_level_id = nl.id where nl.id = $avp(s:tmp_ncos_id) group by nl.local_ac","$avp(s:ncos_local_ac);$avp(s:ncos_mode);$avp(s:ncos_result)");

		xlog("L_INFO", "NCOS level results: mode='$avp(s:ncos_mode)', result='$avp(s:ncos_result)', local_ac='$avp(s:ncos_local_ac)' - [% logreq -%]\n");
		if($avp(s:ncos_mode) == 'whitelist')
		{
			# empty whitelist should block the call
			if($avp(s:ncos_result) == $null)
			{
				$(avp(s:ncos_result)[*]) = "0";
			}
			if($avp(s:ncos_result) == "1")
			{
				xlog("L_INFO", "NCOS result check ok, pass call - [% logreq -%]\n");
				[% debug_dump('return', 'ROUTE_NCOS') %]
				return;
			}
			if($avp(s:ncos_local_ac) == 1 && avp_check("$avp(s:callee_cli)", "fm/$avp(s:tmp)/g"))
			{
				xlog("L_INFO", "NCOS local ac check ok, pass call - [% logreq -%]\n");
				[% debug_dump('return', 'ROUTE_NCOS') %]
				return;
			}
			[% IF ossbss.provisioning.lnp_enable == "yes" %]
			route(ROUTE_NCOS_LNP_CHECK);
			if($rc == 1)
			{
				xlog("L_INFO", "NCOS LNP check ok, pass call - [% logreq -%]\n");
				[% debug_dump('return', 'ROUTE_NCOS') %]
				return;
			}
			[% END %]
			xlog("L_NOTICE", "NCOS check failed, reject call - [% logreq -%]\n");
			$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
			$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

			$(avp(s:announce_reason)[*]) = "Blocked by NCOS level";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		else
		{
			# empty blacklist should allow the call
			if($avp(s:ncos_result) == $null)
			{
				$(avp(s:ncos_result)[*]) = "1";
			}
			if($avp(s:ncos_result) == "0")
			{
				xlog("L_NOTICE", "NCOS result check failed, reject call - [% logreq -%]\n");
				$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
				$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

				$(avp(s:announce_reason)[*]) = "Blocked by NCOS level";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
			if($avp(s:ncos_local_ac) == 1 && avp_check("$avp(s:callee_cli)", "fm/$avp(s:tmp)/g"))
			{
				xlog("L_NOTICE", "NCOS local ac check failed, reject call - [% logreq -%]\n");
				$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
				$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

				$(avp(s:announce_reason)[*]) = "Blocked by NCOS level";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
			[% IF ossbss.provisioning.lnp_enable == "yes" %]
			route(ROUTE_NCOS_LNP_CHECK);
			if($rc == -1)
			{
				xlog("L_NOTICE", "NCOS LNP check failed, reject call - [% logreq -%]\n");
				$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
				$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

				$(avp(s:announce_reason)[*]) = "Blocked by NCOS level";
				route(ROUTE_ACC_FAILURE);
				route(ROUTE_EARLY_REJECT);
			}
			[% END %]
			xlog("L_INFO", "NCOS check ok, pass call - [% logreq -%]\n");
		}
	}
	[% debug_dump('end', 'ROUTE_NCOS') %]
}
[% IF ossbss.provisioning.lnp_enable == "yes" %]
########################################################################
# Check for LNP in NCOS lists (-1 if blocked, 1 if passed)
########################################################################
route[ROUTE_NCOS_LNP_CHECK]
{
	[% debug_dump('start', 'ROUTE_NCOS_LNP_CHECK') %]
	$(avp(s:ncos_lnp_provider_id)[*]) = $null;
	$(avp(s:ncos_lnp_result)[*]) = $null;
	avp_db_query("select ln.lnp_provider_id from billing.lnp_numbers ln where ln.number like concat(left('$(avp(s:callee_cli){s.escape.common})', 4), '%') and instr('$(avp(s:callee_cli){s.escape.common})', ln.number) = 1 and (ln.start <= now() or ln.start is null) and (ln.end > now() or ln.end is null) order by length(ln.number) desc, ln.lnp_provider_id desc limit 1","$avp(s:ncos_lnp_provider_id)");
	xlog("L_INFO", "NCOS LNP provider id is '$avp(s:ncos_lnp_provider_id)' - [% logreq -%]\n");
	if($avp(s:ncos_lnp_provider_id) == $null)
	{
		if($avp(s:ncos_mode) == 'whitelist')
		{
			xlog("L_INFO", "NCOS LNP check blocked for missing provider id in whitelist mode - [% logreq -%]\n");
			[% debug_dump('return', 'ROUTE_NCOS_LNP_CHECK') %]
			return(-1);
		}
		else
		{
			xlog("L_INFO", "NCOS LNP check passed for missing provider id in blacklist mode - [% logreq -%]\n");
			[% debug_dump('return', 'ROUTE_NCOS_LNP_CHECK') %]
			return(1);
		}
	}
	avp_db_query("select if(nl.mode = 'whitelist', count(*), not count(*)) as result from billing.ncos_lnp_list nll, billing.ncos_levels nl where nll.lnp_provider_id=$avp(s:ncos_lnp_provider_id) and nl.id=$avp(s:tmp_ncos_id) and nll.ncos_level_id = nl.id","$avp(s:ncos_lnp_result)");
	xlog("L_INFO", "NCOS LNP result is '$avp(s:ncos_lnp_result)' - [% logreq -%]\n");
	if($avp(s:ncos_lnp_result) == 0)
	{
		xlog("L_NOTICE", "NCOS LNP check blocked - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_NCOS_LNP_CHECK') %]
		return(-1);
	}
	else
	{
		xlog("L_INFO", "NCOS LNP check passed - [% logreq -%]\n");
		[% debug_dump('return', 'ROUTE_NCOS_LNP_CHECK') %]
		return(1);
	}
}
[% END %]
########################################################################
# Route to PSTN
########################################################################
route[ROUTE_PSTN]
{
	[% debug_dump('start', 'ROUTE_PSTN') %]
	$var(allow_peer)=0;
	if($avp(s:em_call) != 1 && avp_check("$xavp(caller_real_prefs[0]=>lock)", "eq/s:1"))
	{
		xlog("L_NOTICE", "Caller locked for offnet with mode '$xavp(caller_real_prefs[0]=>lock)' - [% logreq -%]\n");
		$(avp(s:acc_callee_user)[*]) = $avp(s:callee_user);
		$(avp(s:acc_callee_domain)[*]) = $avp(s:callee_domain);

		$var(announce_handle) = "locked_out";
		$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
		$(avp(s:announce_code)[*]) = 403;
		$(avp(s:announce_reason)[*]) = "Caller locked";
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_EARLY_REJECT);
	}

	xlog("L_NOTICE", "Call to SIP Peering - [% logreq -%]\n");

	setbflag(FLB_NATB);
	$var(to_pstn) = 1;

	$var(lcr_match_content) = "sip:" + $avp(s:first_caller_cli_userprov) + "@" + $avp(s:caller_domain_netprov);
	xlog("L_NOTICE", "Load gws matching calling part '$var(lcr_match_content)' and called user '$rU' and called part '$ru' - [% logreq -%]\n");
	if(!load_gws("1", $rU, $var(lcr_match_content)))
	{
		xlog("L_ERR", "Error loading PSTN gateways - [% logreq -%]\n");
		$var(announce_handle) = "peering_unavailable";
		$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
		$(avp(s:announce_code)[*]) = 503;
		$(avp(s:announce_reason)[*]) = "PSTN Termination Currently Unavailable";
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_EARLY_REJECT);
	}

	#!ifdef ENABLE_PEER_LCR
	# re-order lcr list based on costs per peer-group
	lcr_rate("$avp(s:caller_cli_userprov)@$avp(s:acc_caller_domain)", "$rU@$rd");
	#!endif

	#Dialog handle call type to pstn

	#!ifdef PEER_RELAY
	if ($avp(s:from_pstn) != 1)
	{
		lua_run("set_dlg_profile", "$ci", "outgoing");
		xlog("L_INFO", "Dialog set mark type to outgoing - [% logreq -%]\n");
	}
	else
	{
		#FIXME: We also have relay capabilities by using the preferences. Handle them or delete this one.
		lua_run("set_dlg_profile", "$ci", "relay");
		xlog("L_INFO", "Dialog set mark type to relay - [% logreq -%]\n");
	}
	#!else
		lua_run("set_dlg_profile", "$ci", "outgoing");
		xlog("L_INFO", "Dialog set mark type to outgoing - [% logreq -%]\n");
	#!endif

	while ($var(allow_peer) != 1)
	{
		$var(allow_peer) = 1;
		if(!next_gw())
		{
			xlog("L_ERR", "No PSTN gateways available - [% logreq -%]\n");

			$var(announce_handle) = "peering_unavailable";
			$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 503;
			$(avp(s:announce_reason)[*]) = "PSTN Termination Currently Unavailable";
			route(ROUTE_ACC_FAILURE);
			route(ROUTE_EARLY_REJECT);
		}
		$(avp(s:callee_domain)[*]) = $rd;

		if($avp(s:lcr_flags) != $null && $avp(s:lcr_flags) != 0)
		{
			route(ROUTE_CLEAR_PEER_OUT_PREF);
			route(ROUTE_LOAD_PEER_OUT_PREF);
		}
		if($var(cf_loop) == 1 && pv_isset("$avp(s:first_caller_clir)") && $avp(s:first_caller_clir) != 0)
		{
			if(($xavp(callee_peer_prefs[0]=>outbound_from_user) =~ "^uprn" || $xavp(callee_peer_prefs[0]=>outbound_from_display) =~ "^uprn") &&
			    pv_isset("$avp(s:forwarder_cli_userprov)") && $avp(s:forwarder_cli_userprov) != 0)
			# first caller is anonymous but the callee choose to see forwarder's UPRN => ignore first caller CLIR
			{
				xlog("L_INFO", "Ignore first caller CLIR because UPRN is selected by callee peer preference - [% logreq -%]\n");
				$(avp(s:caller_clir_ignore)[*]) = 1;
			}
			else
			{
				xlog("L_INFO", "Use first caller CLIR as caller CLIR - [% logreq -%]\n");
				$(avp(s:caller_clir)[*]) = $avp(s:first_caller_clir);
			}
		}
		else if($var(cf_loop) == 1 && pv_isset("$avp(s:caller_clir)") && $avp(s:caller_clir) != 0)
		{
			if(!($xavp(callee_peer_prefs[0]=>outbound_from_user) =~ "^uprn" || $xavp(callee_peer_prefs[0]=>outbound_from_display) =~ "^uprn") &&
			    pv_isset("$avp(s:forwarder_cli_userprov)") && $avp(s:forwarder_cli_userprov) != 0)
			# caller is anonymous but the callee choose to see first/original caller => unset caller CLIR
			{
				xlog("L_INFO", "Unset forwarder's CLIR because first CLI is selected by callee peer preference - [% logreq -%]\n");
				$(avp(s:caller_clir)[*]) = $null;
			}
		}

		# Dialog handle callee peer concurrent_max
		if(pv_isset("$xavp(callee_peer_prefs[0]=>concurrent_max)") &&
		   $xavp(callee_peer_prefs[0]=>concurrent_max) != 0 &&
		   $avp(s:em_call) != 1)
		{
			if(lua_run("get_profile_size","peer:$avp(s:lcr_flags)","size"))
			{
				# check greater or equal because the callee peer hasn't been marked yet
				if($avp(s:size) >= $xavp(callee_peer_prefs[0]=>concurrent_max))
				{
					xlog("L_NOTICE", "Concurrent_max calls exceeded for peer '$avp(s:lcr_flags)' - [% logreq -%]\n");
					$var(allow_peer) = 0;
					$du = $null;
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_PSTN') %]
				exit;
			}
		}
		# Dialog handle callee peer concurrent_max_out
		if(pv_isset("$xavp(callee_peer_prefs[0]=>concurrent_max_out)") &&
		   $xavp(callee_peer_prefs[0]=>concurrent_max_out) != 0 &&
		   $avp(s:em_call) != 1)
		{
			if(lua_run("get_profile_size","peerout:$avp(s:lcr_flags)","size"))
			{
				# check greater or equal because the callee peerout hasn't been marked yet
				if($avp(s:size) >= $xavp(callee_peer_prefs[0]=>concurrent_max_out))
				{
					xlog("L_NOTICE", "Concurrent_max_out calls exceeded for peer '$avp(s:lcr_flags)' - [% logreq -%]\n");
					$var(allow_peer) = 0;
					$du = $null;
				}
			}
			else
			{
				route(ROUTE_ADD_CALLINFO_REPLY);
				sl_send_reply("500", "Internal Error");
				[% debug_dump('exit', 'ROUTE_PSTN') %]
				exit;
			}
		}
	}
	if($avp(s:em_call) != 1)
	{
		$(avp(s:callee_user)[*]) = $rU;
	}

	#Dialog handle: Now that we know the peer to use mark call for this peer
	if(!lua_run("set_dlg_profile_peer", "$ci"))
	{
		route(ROUTE_ADD_CALLINFO_REPLY);
		sl_send_reply("500", "Internal Error");
		[% debug_dump('exit', 'ROUTE_PSTN') %]
		exit;
	}
	xlog("L_INFO", "Dialog set mark peer and peerout to '$avp(s:lcr_flags)' - [% logreq -%]\n");

	resetbflag(FLB_CALLEE_IPV6);
	if($rd =~ "^\[[a-fA-F0-9\:\.]+\]$")
	{
		setbflag(FLB_CALLEE_IPV6);
	}

	t_on_failure("FAILURE_ROUTE_PSTN");
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'ROUTE_PSTN') %]
}

########################################################################
# Route to voicebox
########################################################################
route[ROUTE_VOICEBOX]
{
	[% debug_dump('start', 'ROUTE_VOICEBOX') %]
	xlog("L_NOTICE", "Call to VoiceBox - [% logreq -%]\n");

	$(avp(s:acc_callee_user_in)[*]) = $rU;
	$(avp(s:acc_callee_domain_in)[*]) = $rd;
	$(avp(s:to_voicebox)[*]) = 1;
	$(avp(s:callee_user)[*]) = $rU;
	$rd = "voicebox.local";
	$(avp(s:callee_domain)[*]) = $rd;
	if($var(cf_loop) == 1 && pv_isset("$avp(s:first_caller_clir)") && $avp(s:first_caller_clir) != 0)
	{
		$(avp(s:caller_clir)[*]) = $avp(s:first_caller_clir);
	}
	else
	{
		$(avp(s:caller_clir)[*]) = 0;
	}

	$(avp(s:callee_uuid)[*]) = $avp(s:caller_uuid);
	$du = "sip:[% sip_int_ips.0 %]:[% asterisk.sip.bindport %]";
	if(uri =~ "^sip:abc" || uri =~ "^sip:bcd" || uri =~ "^sip:vmu" || uri =~ "^sip:vmb")
	{
		xlog("L_INFO", "Set VoiceBox language '$xavp(caller_real_prefs[0]=>language)' - [% logreq -%]\n");
		append_hf("X-Voicemail-Language: $xavp(caller_real_prefs[0]=>language)\r\n");
	}

	#Dialog handle for calls to voicebox
	lua_run("set_dlg_profile", "$ci", "local");
	xlog("L_INFO", "Dialog set mark type to local - [% logreq -%]\n");
	lua_run("set_dlg_profile", "$ci", "peer:voicebox");
	xlog("L_INFO", "Dialog set mark peer to voicebox - [% logreq -%]\n");

	setbflag(FLB_NATB);
	$var(to_local_endpoint) = 1;
	$var(no_sbc) = 1;
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'ROUTE_VOICEBOX') %]
}

########################################################################
# Route to Faxserver
########################################################################
route[ROUTE_FAXSERVER]
{
	[% debug_dump('start', 'ROUTE_FAXSERVER') %]
	xlog("L_NOTICE", "Call to Faxserver - [% logreq -%]\n");

	$(avp(s:to_faxserver)[*]) = 1;

	$(avp(s:callee_user)[*]) = $rU;
	$(avp(s:callee_domain)[*]) = $rd;
	$(avp(s:callee_uuid)[*]) = $avp(s:caller_uuid);

	$(avp(s:acc_callee_user_in)[*]) = $rU;
	$(avp(s:acc_callee_domain_in)[*]) = $rd;
	$(avp(s:caller_clir)[*]) = $avp(s:first_caller_clir);

	[% IF faxserver.fax_gateways.size == 1 -%]
	# only one fax gateway, use static routing
	$du = "[% faxserver.fax_gateways.0 -%]";
	[% ELSE -%]
	# more than one fax gateways, use dispatcher
	$(avp(s:lcr_dsp)[*]) = 4;
	if(!ds_select_dst("$avp(s:lcr_dsp)", "4"))
	{
		xlog("L_ERR", "Error loading Faxserver gateways - [% logreq -%]\n");
		$(avp(s:announce_code)[*]) = 503;
		$(avp(s:announce_reason)[*]) = "Faxserver Currently Unavailable";
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_ADD_CALLINFO_REPLY);
		t_newtran();
		t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
		[% debug_dump('exit', 'ROUTE_FAXSERVER') %]
		exit;
	}
	t_on_failure("FAILURE_ROUTE_FAXSERVER");
	[% END -%]

	#Dialog handle for calls to faxserver
	lua_run("set_dlg_profile", "$ci", "local");
	xlog("L_INFO", "Dialog set mark type to local - [% logreq -%]\n");
	lua_run("set_dlg_profile", "$ci", "peer:faxserver");
	xlog("L_INFO", "Dialog set mark peer to faxserver - [% logreq -%]\n");

	setbflag(FLB_NATB);
	$var(to_local_endpoint) = 1;

	if([% FOREACH ip IN sip_proxy_ips -%]$dd == "[% ip %]"[% IF sip_proxy_ips.last != ip -%] || [% END -%][% END -%])
	{
		$var(no_sbc) = 1;
	}
	else
	{
		$var(callee_is_hwfax) = 1;
		$var(no_sbc) = 0;
	}

	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'ROUTE_FAXSERVER') %]
}


########################################################################
# Route to Application Server
########################################################################
route[ROUTE_TO_APPSRV]
{
	[% debug_dump('start', 'ROUTE_TO_APPSRV') %]
	xlog("L_NOTICE", "Call to Application Server - [% logreq -%]\n");

	$(avp(s:acc_callee_user_in)[*]) = $rU;
	$(avp(s:acc_callee_domain_in)[*]) = $rd;
	$rd = "app.local";
	$(avp(s:callee_uuid)[*]) = $avp(s:caller_uuid);
	$(avp(s:callee_user)[*]) = $rU;
	$(avp(s:callee_domain)[*]) = $rd;
	$(avp(s:caller_clir)[*]) = $avp(s:first_caller_clir);

	route(ROUTE_LOAD_APPSRV);
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'ROUTE_TO_APPSRV') %]
}
########################################################################
# Route to Calling Card Server
########################################################################
route[ROUTE_TO_CCSRV]
{
	[% debug_dump('start', 'ROUTE_TO_CCSRV') %]
	xlog("L_NOTICE", "Call to Calling Card Server - [% logreq -%]\n");

	$(avp(s:acc_callee_user_in)[*]) = $rU;
	$(avp(s:acc_callee_domain_in)[*]) = $rd;
	$rd = "app.local";
	$(avp(s:callee_uuid)[*]) = $avp(s:caller_uuid);
	$(avp(s:callee_user)[*]) = $rU;
	$(avp(s:callee_domain)[*]) = $rd;
	$(avp(s:caller_clir)[*]) = $avp(s:first_caller_clir);

	if(!pv_isset("$xavp(caller_real_prefs[0]=>sound_set)"))
	{
		$xavp(caller_real_prefs[0]=>sound_set) = "0";
	}

	if(is_present_hf("P-App-Name"))
	{
		remove_hf("P-App-Name");
	}
	if($rU=="callingcard")
	{
		append_hf("P-App-Name: callingcard\r\n");
		$var(outgoing_cli) = $(avp(s:first_caller_cli_userprov)[0]);
	}
	else if($rU=="callthrough")
	{
		append_hf("P-App-Name: callthrough\r\n");
		$var(outgoing_cli) = $(avp(s:caller_cli_userprov)[0]);
	}
	$var(cc_params) = ";lng=en;currency=euro";
	$var(cc_params) = $var(cc_params) + ";uuid=" + $avp(s:caller_uuid);
	$var(cc_params) = $var(cc_params) + ";srcnumber=" + $avp(s:first_caller_cli_netprov);
	$var(cc_params) = $var(cc_params) + ";outgoing_cli=" + $var(outgoing_cli);
	$var(cc_params) = $var(cc_params) + ";sound_set_id=" + $xavp(caller_real_prefs[0]=>sound_set);
	xlog("L_INFO", "Writing call-control parameters '$var(cc_params)' - [% logreq -%]\n");

	if(is_present_hf("P-App-Param"))
	{
		remove_hf("P-App-Param");
	}
	append_hf("P-App-Param: $var(cc_params)\r\n");
	route(ROUTE_LOAD_APPSRV);
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'ROUTE_TO_CCSRV') %]
}

#!ifdef ENABLE_PRESENCE
########################################################################
# Route to Mobile Push Server
########################################################################
route[ROUTE_TO_PUSHSRV]
{
	[% debug_dump('start', 'ROUTE_TO_PUSHSRV') %]
	xlog("L_NOTICE", "Call to Mobile Push Server - [% logreq -%]\n");

	$(avp(s:acc_callee_user_in)[*]) = $rU;
	$(avp(s:acc_callee_domain_in)[*]) = $rd;
	$rU = "mobilepush";
	$rd = "app.local";
	$(avp(s:caller_clir)[*]) = $avp(s:first_caller_clir);

	$(avp(s:rbt_file_id)[*]) = $null;
	$(avp(s:rbt_loop)[*]) = $null;
	if(pv_isset("$xavp(callee_real_prefs[0]=>sound_set)"))
	{
		avp_db_query("select vsf.id, vsf.loopplay from provisioning.voip_sound_files vsf, provisioning.voip_sound_sets vss, provisioning.voip_sound_handles vfh where vfh.name='push_connecting' and vss.id=$xavp(callee_real_prefs[0]=>sound_set) and vsf.handle_id=vfh.id and vsf.set_id=vss.id","$avp(s:rbt_file_id);$avp(s:rbt_loop)");
	}

	if($avp(s:rbt_file_id) == $null)
	{
		xlog("L_INFO", "No audio file for sound set id '$xavp(callee_real_prefs[0]=>sound_set)' and handle 'push_connecting' found - [% logreq -%]\n");
	}
	route(ROUTE_LOAD_APPSRV);
	$var(no_acc) = 1;
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'ROUTE_TO_PUSHSRV') %]
}
#!endif

#!ifdef ENABLE_PBX
########################################################################
# Route to Cloud PBX Server
########################################################################
route[ROUTE_TO_PBXSRV]
{
	[% debug_dump('start', 'ROUTE_TO_PBXSRV') %]
	xlog("L_NOTICE", "Call to Cloud PBX Server - [% logreq -%]\n");

	$(avp(s:acc_callee_user_in)[*]) = $rU;
	$(avp(s:acc_callee_domain_in)[*]) = $rd;
	$rd = "app.local";
	if(!pv_isset("$avp(s:callee_uuid)"))
	{
		$(avp(s:callee_uuid)[*]) = 0;
	}
	$(avp(s:callee_user)[*]) = $rU;
	$(avp(s:callee_domain)[*]) = $rd;
	$(avp(s:caller_clir)[*]) = $avp(s:first_caller_clir);

	# Dialog handle for calls to appsrv
	lua_run("set_dlg_profile", "$ci", "local");
	xlog("L_INFO", "Dialog set mark type to local - [% logreq -%]\n");
	lua_run("set_dlg_profile", "$ci", "peer:pbxsrv");
	xlog("L_INFO", "Dialog set mark peer to pbxsrv - [% logreq -%]\n");

	route(ROUTE_LOAD_PBXSRV);
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'ROUTE_TO_PBXSRV') %]
}

########################################################################
# Load PBX server from the dispatcher table
########################################################################
route[ROUTE_LOAD_PBXSRV]
{
	[% debug_dump('start', 'ROUTE_LOAD_PBXSRV') %]
	$(avp(s:lcr_dsp)[*]) = 5;
	if(!ds_select_dst("$avp(s:lcr_dsp)", "3"))
	{
		xlog("L_ERR", "Error loading PBX Server - [% logreq -%]\n");
		if(!pv_isset("$avp(s:announce_code)") || !pv_isset("$avp(s:announce_reason)"))
		{
			$(avp(s:announce_code)[*]) = 503;
			$(avp(s:announce_reason)[*]) = "Application Server Currently Unavailable";
		}
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_ADD_CALLINFO_REPLY);
		t_newtran();
		t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
		[% debug_dump('exit', 'ROUTE_LOAD_PBXSRV') %]
		exit;
	}

	setbflag(FLB_NATB);
	$var(to_local_endpoint) = 1;
	$var(no_sbc) = 1;
[% debug_dump('end', 'ROUTE_LOAD_PBXSRV') %]
}
#!endif

########################################################################
# Load application server from the dispatcher table
########################################################################
route[ROUTE_LOAD_APPSRV]
{
	[% debug_dump('start', 'ROUTE_LOAD_APPSRV') %]
	$(avp(s:lcr_dsp)[*]) = 3;
	if(!ds_select_dst("$avp(s:lcr_dsp)", "3"))
	{
		xlog("L_ERR", "Error loading Application Server - [% logreq -%]\n");
		if(!pv_isset("$avp(s:announce_code)") || !pv_isset("$avp(s:announce_reason)"))
		{
			$(avp(s:announce_code)[*]) = 503;
			$(avp(s:announce_reason)[*]) = "Application Server Currently Unavailable";
		}
		route(ROUTE_ACC_FAILURE);
		route(ROUTE_ADD_CALLINFO_REPLY);
		t_newtran();
		t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
		[% debug_dump('exit', 'ROUTE_LOAD_APPSRV') %]
		exit;
	}

	#Dialog handle for calls to appsrv
	lua_run("set_dlg_profile", "$ci", "local");
	xlog("L_INFO", "Dialog set mark type to local - [% logreq -%]\n");
	lua_run("set_dlg_profile", "$ci", "peer:appsrv");
	xlog("L_INFO", "Dialog set mark peer to appsrv - [% logreq -%]\n");
	
	setbflag(FLB_NATB);
	$var(to_local_endpoint) = 1;
	$var(no_sbc) = 1;
	[% debug_dump('end', 'ROUTE_LOAD_APPSRV') %]
}

########################################################################
# Remove any headers used for proxy lookup routing
########################################################################
route[ROUTE_CLEAR_PROXYLU_HEADERS]
{
	[% debug_dump('start', 'ROUTE_CLEAR_PROXYLU_HEADERS') %]

	remove_hf("P-First-Caller-UPN");
	remove_hf("P-First-Caller-NPN");
	remove_hf("P-First-Forwarder-UPN");
	remove_hf("P-Caller-UPN");
	remove_hf("P-Caller-NPN");
	remove_hf("P-First-V46-RTP");
	remove_hf("P-First-RTP");
	remove_hf("P-Caller-CLIR");
	remove_hf("P-Caller-PeerInfo");
	remove_hf("P-Peer-By-Uuid");
	remove_hf("P-Caller-From-PSTN");
	remove_hf("P-First-Caller-UA-Mode");
	remove_hf("P-First-Caller-UA-Replace");
	[% debug_dump('end', 'ROUTE_CLEAR_PROXYLU_HEADERS') %]
}

########################################################################
# Set CLI from branch route
########################################################################
route[ROUTE_SET_CALLEE]
{
	[% debug_dump('start', 'ROUTE_SET_CALLEE') %]
	# denormalize
	if($var(to_pstn) == 1)
	{
		if(pv_isset("$xavp(callee_peer_prefs[0]=>rewrite_callee_out_dpid)"))
		{
			$var(dp_input) = $rU;
			$var(dp_input_desc) = "called party";
			$var(dpid) = $xavp(callee_peer_prefs[0]=>rewrite_callee_out_dpid);
			$var(dpid_desc) = "callee-out peer";
			if(route(ROUTE_APPLY_REWRITE_RULE))
			{
				$rU = $var(dp_user);
			}
		}
		if($xavp(callee_peer_prefs[0]=>outbound_to_user_is_phone) == 1)
		{
			if(is_tel_number("$rU"))
			{
				xlog("L_INFO", "R-URI user '$rU' is a tel number, add user=phone - [% logreq -%]\n");
				add_uri_param("user=phone");
			}
		}
	}
	else
	{
		if(pv_isset("$xavp(callee_real_prefs[0]=>rewrite_callee_out_dpid)"))
		{
			$var(dp_input) = $rU;
			$var(dp_input_desc) = "called party";
			$var(dpid) = $xavp(callee_real_prefs[0]=>rewrite_callee_out_dpid);
			$var(dpid_desc) = "callee-out usr/domain";
			if(route(ROUTE_APPLY_REWRITE_RULE))
			{
				$rU = $var(dp_user);
			}
		}
		if($xavp(callee_real_prefs[0]=>outbound_to_user_is_phone) == 1)
		{
			if(is_tel_number("$rU"))
			{
				xlog("L_INFO", "R-URI user '$rU' is a tel number, add user=phone - [% logreq -%]\n");
				add_uri_param("user=phone");
			}
		}
	}
	[% debug_dump('end', 'ROUTE_SET_CALLEE') %]
}

########################################################################
# Prepare header elements for caller cli
# in:  $var(ccli_selector)
# out: $var(ccli_user), $var(ccli_domain)
########################################################################
route[ROUTE_PREPARE_CALLER_CLI]
{
	[% debug_dump('start', 'ROUTE_PREPARE_CALLER_CLI') %]
	if($var(ccli_selector) == 0)
	{
		$var(ccli_selector) = "";
	}
	if($var(ccli_selector) =~ "^uprn$")
	{
		$var(ccli_user) = $avp(s:forwarder_cli_userprov);
		$var(ccli_domain) = $avp(s:forwarder_domain_userprov);
		if($var(ccli_user) != 0)
		{
			xlog("L_NOTICE", "Setting forwarder_cli_userprov/forwarder_domain_userprov '$var(ccli_user)@$var(ccli_domain)' for uprn - [% logreq -%]\n");
		}
		else
		{
			$var(ccli_user) = 0;
			$var(ccli_domain) = 0;
			xlog("L_INFO", "No selector set, not setting CLI - [% logreq -%]\n");
		}
		[% debug_dump('return', 'ROUTE_PREPARE_CALLER_CLI') %]
		return;
	}
	else if($var(ccli_selector) =~ "^uprn/")
	{
		if(pv_isset("$avp(s:forwarder_cli_userprov)") && $avp(s:forwarder_cli_userprov) != 0)
		{
			$var(ccli_user) = $avp(s:forwarder_cli_userprov);
			$var(ccli_domain) = $avp(s:forwarder_domain_userprov);
			if($var(ccli_user) != 0)
			{
				xlog("L_NOTICE", "Setting forwarder_cli_userprov/forwarder_domain_userprov '$var(ccli_user)@$var(ccli_domain)' for uprn - [% logreq -%]\n");
			}
			else
			{
				$var(ccli_user) = 0;
				$var(ccli_domain) = 0;
				xlog("L_INFO", "No selector set, not setting CLI - [% logreq -%]\n");
			}
			[% debug_dump('return', 'ROUTE_PREPARE_CALLER_CLI') %]
			return;
		}
		else
		{
			# fallback to second selector
			$var(ccli_selector) = $(var(ccli_selector){s.select,1,/});
		}
	}
	if($var(ccli_selector) == "npn")
	{
		$var(ccli_user) = $var(caller_cli_netprov);
		$var(ccli_domain) = $var(caller_domain_netprov);
		xlog("L_NOTICE", "Setting caller_cli_netprov/caller_domain_netprov '$var(ccli_user)@$var(ccli_domain)' for npn - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "upn")
	{
		$var(ccli_user) = $var(caller_cli_userprov);
		$var(ccli_domain) = $var(caller_domain_userprov);
		xlog("L_NOTICE", "Setting caller_cli_userprov/caller_domain_userprov '$var(ccli_user)@$var(ccli_domain)' for upn - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "rcv_display" && $fn != $null && $(fn{s.len}) > 0)
	{
		$var(ccli_user) = $fn;
		# strip optional double-quotes
		if($var(ccli_user) =~ "^\".+\"$")
		{
			#$var(ccli_user) = $(var(ccli_user){s.select,1,"});
			# TODO: the above seems to break in unpredictable cases, use old/safe way for now
			$var(ccli_user) = $(var(ccli_user){re.subst,/^\"?([^\"]*)\"?$/\1/});
		}
		$var(ccli_domain) = $var(caller_domain_userprov);
		xlog("L_NOTICE", "Setting display-name/caller_domain_userprov '$var(ccli_user)@$var(ccli_domain)' for rcv_display - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "np_display" && pv_isset("$xavp(caller_real_prefs[0]=>display_name)"))
	{
		$var(ccli_user) = $xavp(caller_real_prefs[0]=>display_name);
		$var(ccli_domain) = $var(caller_domain_userprov);
		xlog("L_NOTICE", "Setting display-name/caller_domain_userprov '$var(ccli_user)@$var(ccli_domain)' for np_display - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "auth_user" && $au != $null)
	{
		$var(ccli_user) = $au;
		$var(ccli_domain) = $var(caller_domain_userprov);
		xlog("L_NOTICE", "Setting auth_user/caller_domain_userprov '$var(ccli_user)@$var(ccli_domain)' for auth_user - [% logreq -%]\n");
	}
	else if($var(ccli_selector) == "peer_auth_user")
	{
		if(pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_user)") && pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_realm)"))
		{
			$var(ccli_user) = $xavp(caller_real_prefs[0]=>peer_auth_user);
			$var(ccli_domain) = $xavp(caller_real_prefs[0]=>peer_auth_realm);
			xlog("L_NOTICE", "Setting caller peer_auth_user/peer_auth_realm '$var(ccli_user)@$var(ccli_domain)' for peer_auth_user - [% logreq -%]\n");
		}
		else if(pv_isset("$xavp(callee_peer_prefs[0]=>peer_auth_user)") && pv_isset("$xavp(callee_peer_prefs[0]=>peer_auth_realm)"))
		{
			$var(ccli_user) = $xavp(callee_peer_prefs[0]=>peer_auth_user);
			$var(ccli_domain) = $xavp(callee_peer_prefs[0]=>peer_auth_realm);
			xlog("L_NOTICE", "Setting peer-callee peer_auth_user/peer_auth_realm '$var(ccli_user)@$var(ccli_domain)' for peer_auth_user - [% logreq -%]\n");
		}
		else
		{
			$var(ccli_user) = 0;
			$var(ccli_domain) = 0;
			xlog("L_INFO", "No selector set, not setting CLI - [% logreq -%]\n");
			[% debug_dump('return', 'ROUTE_PREPARE_CALLER_CLI') %]
			return;
		}
	}
	else
	{
		$var(ccli_user) = 0;
		$var(ccli_domain) = 0;
		xlog("L_INFO", "No selector set, not setting CLI - [% logreq -%]\n");
	}
	[% debug_dump('end', 'ROUTE_PREPARE_CALLER_CLI') %]
}

########################################################################
# Set CLI from branch route
########################################################################
route[ROUTE_SET_CALLER_CLI]
{
	[% debug_dump('start', 'ROUTE_SET_CALLER_CLI') %]
	$var(caller_cli_userprov) = $avp(s:first_caller_cli_userprov);
	$var(caller_cli_netprov) = $avp(s:first_caller_cli_netprov);
	$var(caller_domain_netprov) = $avp(s:first_caller_domain_netprov);

	# Onnet, to local subscriber
	if($var(to_pstn) != 1 && $var(to_local_endpoint) != 1)
	{
		if(!($avp(s:caller_clir) == 1 && $avp(s:caller_clir_ignore) != 1) && pv_isset("$xavp(callee_real_prefs[0]=>rewrite_caller_out_dpid)"))
		{
			$var(dpid) = $xavp(callee_real_prefs[0]=>rewrite_caller_out_dpid);
			$var(dpid_desc) = "caller-out usr/domain";
			route(ROUTE_APPLY_CALLER_RWR_FIRST);
		}

		xlog("L_INFO", "Setting userprovided caller domain - [% logreq -%]\n");
		if($avp(s:from_pstn) == 1 || $avp(s:cf_from_pstn) == 1)
		{
			$var(caller_domain_userprov) = $avp(s:acc_callee_domain);
			$var(caller_domain_netprov) = $avp(s:acc_callee_domain);
			xlog("L_INFO", "Call from peer, use callee domain '$avp(s:acc_callee_domain)' - [% logreq -%]\n");
		}
		else
		{
			$var(caller_domain_userprov) = $avp(s:first_caller_domain_userprov);
			xlog("L_INFO", "Use first userprov caller domain '$avp(s:first_caller_domain_userprov)' - [% logreq -%]\n");
		}

	}

	# Offnet or local endpoint
	else if($var(to_pstn) == 1 || $var(to_local_endpoint) == 1)
	{
		if(pv_isset("$xavp(callee_peer_prefs[0]=>rewrite_caller_out_dpid)") && $var(to_local_endpoint) != 1)
		{
			$var(dpid) = $xavp(callee_peer_prefs[0]=>rewrite_caller_out_dpid);
			$var(dpid_desc) = "caller-out peer";
			route(ROUTE_APPLY_CALLER_RWR_FIRST);
		}

		$var(caller_domain_userprov) = $avp(s:first_caller_domain_userprov);
	}

	# set the From header
	if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
	{
		$var(ccli_selector) = $xavp(callee_peer_prefs[0]=>outbound_from_display);
	}
	else
	{
		$var(ccli_selector) = $xavp(callee_real_prefs[0]=>outbound_from_display);
	}
	xlog("L_INFO", "Prepare From display-name setting - [% logreq -%]\n");
	route(ROUTE_PREPARE_CALLER_CLI);
	$var(out_from_display) = $var(ccli_user);
	#!ifdef ENABLE_PBX
	if($var(out_from_display) != 0 && $avp(s:p_to_group) == 1)
	{
		$var(out_from_display) = "[% kamailio.proxy.pbx.hunt_display_indicator %] " + $var(out_from_display);
	}
	#!endif
	if($var(to_pstn) == 1 && isbflagset(FLB_PEERAUTH) && pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_user)"))
	{
		$var(caller_uri) = "sip:" + $xavp(caller_real_prefs[0]=>peer_auth_user) + "@" + $xavp(caller_real_prefs[0]=>peer_auth_realm);
	}
	else
	{
		if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
		{
			$var(ccli_selector) = $xavp(callee_peer_prefs[0]=>outbound_from_user);
		}
		else
		{
			$var(ccli_selector) = $xavp(callee_real_prefs[0]=>outbound_from_user);
		}
		xlog("L_INFO", "Prepare From username setting - [% logreq -%]\n");
		route(ROUTE_PREPARE_CALLER_CLI);
		if($var(ccli_user) == 0)
		{
			$var(ccli_user) = $var(caller_cli_netprov);
			$var(ccli_domain) = $var(caller_domain_netprov);
		}
		$var(caller_uri) = "sip:" + $var(ccli_user) + "@" + $var(ccli_domain);
	}
	if($avp(s:caller_clir) == 1 && $avp(s:caller_clir_ignore) != 1) # override previous settings in case of CLIR
	{
		if($var(to_pstn) != 1 && $var(cf_loop) == 1 &&
		 ( $ru =~ "^sip:auto-attendant@app\.local$" || $ru =~ "^sip:office-hours@app\.local$" ) )
		{
			xlog("L_NOTICE", "Skip Anonymizing for CF to auto-attendant or office-hours - [% logreq -%]\n");
		}
		else
		{
			if($var(to_pstn) != 1)
			{
				xlog("L_NOTICE", "Anonymizing From username - [% logreq -%]\n");
				$var(caller_uri) = "sip:anonymous@anonymous.invalid";
			}
			if($var(to_pstn) == 1 && $var(cf_loop) == 1 && $xavp(callee_peer_prefs[0]=>outbound_history_info) != 0)
			{
				xlog("L_INFO", "Skip Privacy header for anonymous callforward to NGN carrier (using HIH privacy) - [% logreq -%]\n");
			}
			else
			{
				xlog("L_NOTICE", "Anonymizing From display-name - [% logreq -%]\n");
				$var(out_from_display) = "Anonymous";
				#!ifdef ENABLE_PBX
				if($var(out_from_display) != 0 && $avp(s:p_to_group) == 1)
				{
					$var(out_from_display) = "[% kamailio.proxy.pbx.hunt_display_indicator %] " + $var(out_from_display);
				}
				#!endif
				append_hf("Privacy: id\r\n");
			}
		}
	}
	if(($var(to_pstn) == 1 && $xavp(callee_peer_prefs[0]=>outbound_from_user_is_phone) == 1) ||
	   ($var(to_pstn) == 0 && $xavp(callee_real_prefs[0]=>outbound_from_user_is_phone) == 1))
	{
		if(is_tel_number("$(var(caller_uri){uri.user})"))
		{
			xlog("L_INFO", "From user '$(var(caller_uri){uri.user})' is a tel number, add user=phone - [% logreq -%]\n");
			$var(caller_uri) = $var(caller_uri) + ";user=phone";
		}
		else
		{
			xlog("L_INFO", "From user '$(var(caller_uri){uri.user})' is NOT a tel number, skip user=phone - [% logreq -%]\n");
		}
	}
	if($var(out_from_display) == 0)
	{
		xlog("L_NOTICE", "Setting From to '<$var(caller_uri)>' - [% logreq -%]\n");
		uac_replace_from("", "$var(caller_uri)");
	}
	else
	{
		xlog("L_NOTICE", "Setting From to '$var(out_from_display) <$var(caller_uri)>' - [% logreq -%]\n");
		uac_replace_from("\"$var(out_from_display)\"", "$var(caller_uri)");
	}

	#Don't add PAI nor PPI if the callee is local and CLIR is set.
	if(!($avp(s:caller_clir) == 1 && $avp(s:caller_clir_ignore) != 1) || $var(to_pstn) == 1)
	{
		# set the PAI header
		if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
		{
			$var(ccli_selector) = $xavp(callee_peer_prefs[0]=>outbound_pai_user);
		}
		else
		{
			$var(ccli_selector) = $xavp(callee_real_prefs[0]=>outbound_pai_user);
		}
		xlog("L_INFO", "Prepare PAI username setting - [% logreq -%]\n");
		route(ROUTE_PREPARE_CALLER_CLI);
		if($var(ccli_user) != 0)
		{
			$var(caller_uri) = "sip:" + $var(ccli_user) + "@" + $var(ccli_domain);
			if(($var(to_pstn) == 1 && $xavp(callee_peer_prefs[0]=>outbound_from_user_is_phone) == 1) ||
			   ($var(to_pstn) == 0 && $xavp(callee_real_prefs[0]=>outbound_from_user_is_phone) == 1))
			{
				if(is_tel_number("$(var(caller_uri){uri.user})"))
				{
					xlog("L_INFO", "PAI user '$(var(caller_uri){uri.user})' is a tel number, add user=phone - [% logreq -%]\n");
					$var(caller_uri) = $var(caller_uri) + ";user=phone";
				}
				else
				{
					xlog("L_INFO", "PAI user '$(var(caller_uri){uri.user})' is NOT a tel number, skip user=phone - [% logreq -%]\n");
				}
			}
			xlog("L_NOTICE", "Setting PAI to '<$var(caller_uri)>' - [% logreq -%]\n");
			append_hf("P-Asserted-Identity: <$var(caller_uri)>\r\n");
		}

		# set the PPI header
		if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
		{
			$var(ccli_selector) = $xavp(callee_peer_prefs[0]=>outbound_ppi_user);
		}
		else
		{
			$var(ccli_selector) = $xavp(callee_real_prefs[0]=>outbound_ppi_user);
		}
		xlog("L_INFO", "Prepare PPI username setting - [% logreq -%]\n");
		route(ROUTE_PREPARE_CALLER_CLI);
		if($var(ccli_user) != 0)
		{
			$var(caller_uri) = "sip:" + $var(ccli_user) + "@" + $var(ccli_domain);
			xlog("L_NOTICE", "Setting PPI to '<$var(caller_uri)>' - [% logreq -%]\n");
			append_hf("P-Preferred-Identity: <$var(caller_uri)>\r\n");
		}
	}
	else
	{
		xlog("L_INFO", "PAI and PPI skipped for onnet clir calls - [% logreq -%]\n");
	}

	# apogrebennyk: comment out check for FLAG in order to forward Diversion also when clir=1
	if(!($avp(s:caller_clir) == 1 && $avp(s:caller_clir_ignore) != 1))
	{
		# set the Diversion header
		if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
		{
			$var(ccli_selector) = $xavp(callee_peer_prefs[0]=>outbound_diversion);
		}
		else
		{
			$var(ccli_selector) = $xavp(callee_real_prefs[0]=>outbound_diversion);
		}
		xlog("L_INFO", "Prepare Diversion setting - [% logreq -%]\n");
		route(ROUTE_PREPARE_CALLER_CLI);
		if($var(ccli_user) != 0)
		{
			$var(diversion_uri) = "sip:" + $var(ccli_user) + "@" + $var(ccli_domain);
			xlog("L_NOTICE", "Setting Diversion to '<$var(diversion_uri)>' - [% logreq -%]\n");
			#append_hf("Diversion: <$var(diversion_uri)>;reason=unknown\r\n");
			add_diversion("unknown", "$var(diversion_uri)");
		}
	}
	# set the History-Info header
	if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
	{
		$var(ccli_selector) = $xavp(callee_peer_prefs[0]=>outbound_history_info);
	}
	else
	{
		$var(ccli_selector) = $xavp(callee_real_prefs[0]=>outbound_history_info);
	}
	if($var(ccli_selector) != "" && $var(ccli_selector) != 0)
	{
		if($var(cf_loop) == 1)
		{
			if(!($avp(s:acc_callee_dialed) =~ "^\+"))
				$var(new_hih_user) = "+" + $avp(s:acc_callee_dialed);
			else
				$var(new_hih_user) = $avp(s:acc_callee_dialed);

			if($avp(s:our_hih_user) == $avp(s:acc_callee_dialed))
				xlog("L_NOTICE", "Skip History-Info setting, received History-Info '$hdr(History-Info)' is our user '$var(new_hih_user)' - [% logreq -%]\n");
			else
			{
				xlog("L_INFO", "Prepare History-Info setting, rcv_index='$avp(s:hih_caller_index)', loop_count='$avp(s:cf_loop_counter)' - [% logreq -%]\n");
				if($avp(s:cf_loop_counter) != 0)
				{
					if($T_branch_idx == 0)
					{
						$(avp(s:hih_caller_index)[*]) = $_s($avp(s:hih_caller_index).$avp(s:cf_loop_counter));
					}
				}
				xlog("L_INFO", "++++++++++ History-Info: new index='$avp(s:hih_caller_index)' - [% logreq -%]\n");
				##############################
				# add cause
				##############################
				$var(hih_uri) = $_s(sip:$var(new_hih_user)@$avp(s:callee_domain):5060);
				if($avp(s:hih_cause) != 0 && $var(cf_loop) == 1)
				{
					$var(hih_uri) = $var(hih_uri) + ";cause=" + $avp(s:hih_cause);
				}
				##############################
				# append History-Info
				##############################
				$var(history_info) = $_s(<$var(hih_uri);user=phone>;index=$avp(s:hih_caller_index));
				xlog("L_NOTICE", "Setting History-Info (ROUTE_SET_CALLER_CLI) to '$var(history_info)' - [% logreq -%]\n");
				append_hf("History-Info: $var(history_info)\r\n");
			}
		}
	}
	[% debug_dump('end', 'ROUTE_SET_CALLER_CLI') %]
}

########################################################################
# Process incoming History-Info, applying anonymization as requested
########################################################################
route[ROUTE_PROCESS_INCOMING_HIH]
{
	$var(hih_loop_idx) = 0;
	$var(allhih) = 0;
	$var(hih_rewrite) = 0;
	$var(allhih) = $(hdr(History-Info)[-1]);
	avp_delete("$avp(s:hih_new)/g");
	while($var(allhih) != 0 && $(var(allhih){s.select,$var(hih_loop_idx),,}) != '')
	{
		$var(hih_cur) = $(var(allhih){s.select,$var(hih_loop_idx),,});
		$var(hih_user) = $(var(hih_cur){nameaddr.uri}{uri.user});
		if($var(hih_user) =~ "^\+[1-9][0-9]+$")
		{
			# strip leading '+' for matching in dbaliases
			$var(hih_user) = $(var(hih_user){s.strip,1});
		}
		if($var(hih_user) == $avp(s:callee_base_user))
		{
			$(avp(s:our_hih_user)[*]) = $var(hih_user);
			if($xavp(callee_real_prefs[0]=>clir) == 1)
			{
				xlog("L_INFO", "Anonymization request from History-Info[$var(hih_loop_idx)] user $var(hih_user), clir='$xavp(callee_real_prefs[0]=>clir)' - [% logreq -%]\n");
				if($(var(hih_cur){param.value,cause}) != '')
				{
					$var(new_hih) = $_s(<sip:$(var(hih_cur){nameaddr.uri}{uri.user})@$avp(s:callee_domain);user=phone;cause=$(var(hih_cur){param.value,cause})?privacy=id>;index=$(var(hih_cur){param.value,index}));
				}
				else
				{
					$var(new_hih) = $_s(<sip:$(var(hih_cur){nameaddr.uri}{uri.user})@$avp(s:callee_domain);user=phone?privacy=id>;index=$(var(hih_cur){param.value,index}));
				}
				$avp(s:hih_new) = $var(new_hih);
				$var(hih_rewrite) = 1;
			}
			else
			{
				$avp(s:hih_new) = $var(hih_cur);
			}
		}
		else
		{
			$avp(s:hih_new) = $var(hih_cur);
		}
		$var(hih_loop_idx) = $var(hih_loop_idx) + 1;
	}
	$var(hih_loop_idx) = 0;
	if($var(hih_rewrite) == 1)
	{
		remove_hf("History-Info");
		while($(avp(s:hih_new)[$var(hih_loop_idx)]) != $null)
		{
			xlog("L_INFO", "New History-Info[$var(hih_loop_idx)]: '$(avp(s:hih_new)[$var(hih_loop_idx)])' - [% logreq -%]\n");
			append_hf("History-Info: $(avp(s:hih_new)[$var(hih_loop_idx)])\r\n");
			$var(hih_loop_idx) = $var(hih_loop_idx) + 1;
		}
		$var(hih_loop_idx) = 0;
	}
}

########################################################################
# Pass parameters to b2b call-control module
########################################################################
route[ROUTE_CC_PREPAID]
{
	[% debug_dump('start', 'ROUTE_CC_PREPAID') %]
	if($xavp(caller_real_prefs[0]=>prepaid) == 1)
	{
		$var(cc_params) = "cc_sw_prepaid";
		xlog("L_INFO", "Prepaid call-control will bill this call to the caller/forwarder uuid=$avp(s:caller_uuid) and callee uuid=$avp(s:callee_uuid) - [% logreq -%]\n");
		$var(cc_params) = $var(cc_params) + ";prepaid_uuid=" + $avp(s:caller_uuid);
		$var(cc_params) = $var(cc_params) + ";a_uuid=" + $avp(s:caller_uuid);
		$var(cc_params) = $var(cc_params) + ";b_uuid=" + $avp(s:callee_uuid);
		$var(cc_params) = $var(cc_params) + ";a_number=" + $avp(s:caller_cli_userprov) +
						    ";b_number=" + $avp(s:acc_callee_user_in);
		$var(cc_params) = $var(cc_params) + ";a_domain=" + $avp(s:acc_caller_domain);
		$var(cc_params) = $var(cc_params) + ";b_domain=" + $avp(s:acc_callee_domain);
		$var(cc_params) = $var(cc_params) + ";callid=" + $ci;
		$var(cc_params) = $var(cc_params) + ";feature_code=ngcp";

		xlog("L_INFO", "Writing call-control parameters  $var(cc_params) - [% logreq -%]\n");
		append_hf("P-CallControl: $var(cc_params)\r\n");
	}
	else
	{
		# TODO: this is not implemented in sems yet
		xlog("L_INFO", "Skipping termination prepaid handling - [% logreq -%]\n");
	}
	[% debug_dump('end', 'ROUTE_CC_PREPAID') %]
}

########################################################################
# Reply route 'base-standard-reply'
########################################################################
onreply_route[REPLY_ROUTE_STD]     #Manwe: Maybe to dissapear. Left for local routes for now
{
	[% debug_dump('start', 'REPLY_ROUTE_STD') %]
	xlog("L_NOTICE", "Reply - [% logres_init -%]\n");

	if(sdp_content() && ($avp(s:from_faxserver) == 1 || $avp(s:to_faxserver) == 1))
	{
		# fix for T.38 to patton faxserver gateway, which chokes on upper-case
		xlog("L_INFO", "Rewriting T.38 'UDPTL' to 'udptl' - [% logres -%]\n");
		replace_body_all(" UDPTL ", " udptl ");
	}
	#!ifdef ENABLE_PBX
	if(status=~"18[0-3]|2[0-9][0-9]" && ($rm == "INVITE" || $rm == "PRACK" || $rm == "BYE"))
	{
		if(pv_isset("$avp(s:sca_active)"))
		{
			sca_call_info_update();
		}
	}
	#!endif

	if($avp(s:reply_sock) != 0)
	{
		append_hf("P-Out-Socket: $avp(s:reply_sock)\r\n");
	}
	if(status == "408")
	{
		$var(ext_timeout) = 1;
	}

	[% IF kamailio.proxy.allow_refer_method == "no" -%]
	if (hf_value_exists("Allow", "REFER")) {
		xlog("L_INFO", "Remove REFER from Allow - [% logres -%]\n");
		exclude_hf_value("Allow", "REFER");
		msg_apply_changes();
	}
	[% END -%]
	[% IF kamailio.proxy.allow_info_method == "no" -%]
	if (hf_value_exists("Allow", "INFO"))
	{
		xlog("L_INFO", "Remove INFO from Allow - [% logres -%]\n");
		exclude_hf_value("Allow", "INFO");
		msg_apply_changes();
	}
	[% END -%]
	[% debug_dump('exit', 'REPLY_ROUTE_STD') %]
	exit;
}

########################################################################
# Reply route 'base-nat-reply'
########################################################################
onreply_route[REPLY_ROUTE_NAT]
{
	[% debug_dump('start', 'REPLY_ROUTE_NAT') %]
	xlog("L_NOTICE", "NAT-Reply - [% logres_init -%]\n");
	force_rport();

	[% IF kamailio.proxy.allow_refer_method == "no" -%]
	if (hf_value_exists("Allow", "REFER")) {
		xlog("L_INFO", "Remove REFER from Allow - [% logres -%]\n");
		exclude_hf_value("Allow", "REFER");
		msg_apply_changes();
	}
	[% END -%]
	[% IF kamailio.proxy.allow_info_method == "no" -%]
	if (hf_value_exists("Allow", "INFO"))
	{
		xlog("L_INFO", "Remove INFO from Allow - [% logres -%]\n");
		exclude_hf_value("Allow", "INFO");
		msg_apply_changes();
	}
	[% END -%]

	if(sdp_content() && ($avp(s:from_faxserver) == 1 || $avp(s:to_faxserver) == 1))
	{
		# fix for T.38 to patton faxserver gateway, which chokes on upper-case
		xlog("L_INFO", "Rewriting T.38 'UDPTL' to 'udptl' - [% logres -%]\n");
		replace_body_all(" UDPTL ", " udptl ");
	}

	#!ifdef ENABLE_PBX
	if(pv_isset("$avp(s:colpid)"))
	{
		xlog("L_INFO", "Appending COLP identity '$avp(s:colpid)' to reply - [% logres -%]\n");
		append_hf("P-COLP-Identity: $avp(s:colpid)\r\n");
	}
	if(status=~"18[0-3]|2[0-9][0-9]" && ($rm == "INVITE" || $rm == "PRACK" || $rm == "BYE"))
	{
		if(pv_isset("$avp(s:sca_active)"))
		{
			sca_call_info_update();
		}
	}
	#!endif

	if(status=~"18[0-3]|2[0-9][0-9]" && ($rm == "INVITE" || $rm == "UPDATE"))
	{
		if(status=~"2[0-9][0-9]" && $rm == "INVITE")
		{
			if($xavp(caller_peer_prefs[0]=>sst_enable) == "no" || $xavp(caller_real_prefs[0]=>sst_enable) == "no")
			{
				if(hf_value_exists("Supported", "timer"))
				{
					xlog("L_INFO", "Remove timer from Supported in 200 OK - [% logres -%]\n");
					exclude_hf_value("Supported", "timer");
				}
				if(hf_value_exists("Require", "timer"))
				{
					xlog("L_INFO", "Remove timer from Require in 200 OK - [% logres -%]\n");
					exclude_hf_value("Require", "timer");
				}
				if(is_present_hf("Session-Expires"))
				{
					xlog("L_INFO", "Remove Session-Expires - [% logres -%]\n");
					remove_hf("Session-Expires");
				}
			}
		}

		if(!search("^Content-Length:[ ]*0") && !t_is_canceled() &&
			sdp_content() && isbflagset(FLB_RTPPROXY))
		{
			$var(ice_flags) = '';
			if (isflagset(FLAG_DOWNSTREAM))
			{ #same direction as original request
				if(isbflagset(FLB_ICE_CALLER_REPLACE))
				{
					xlog("L_INFO", "Replace existing ICE candidates (if any) for caller - [% logres -%]\n");
					$var(ice_flags) = "ICE=force ";
				}
				else if(isbflagset(FLB_ICE_CALLER_STRIP))
				{
					xlog("L_INFO", "Remove existing ICE candidates (if any) for caller - [% logres -%]\n");
					$var(ice_flags) = "ICE=remove ";
				}
				else if(isbflagset(FLB_ICE_CALLER_ADD))
				{
					xlog("L_INFO", "Add mediaproxy as ICE candidate for caller - [% logres -%]\n");
				}
			}
			else
			{ #opposite direction to original request
				if(isbflagset(FLB_ICE_CALLEE_REPLACE))
				{
					xlog("L_INFO", "Replace existing ICE candidates (if any) for callee with mediaproxy ICE canditate - [% logres -%]\n");
					$var(ice_flags) = "ICE=force ";
				}
				else if(isbflagset(FLB_ICE_CALLEE_STRIP))
				{
					xlog("L_INFO", "Remove existing ICE candidates (if any) for callee - [% logres -%]\n");
					$var(ice_flags) = "ICE=remove ";
				}
				else if(isbflagset(FLB_ICE_CALLEE_ADD))
				{
					xlog("L_INFO", "Add mediaproxy as ICE candidate for callee - [% logres -%]\n");
				}
			}
			# normally we do an rtpproxy lookup in the reply, unless
			# we have 200/ACK negotiation
			if(isbflagset(FLB_RTPPROXY_LOOKUP))
			{
				$var(rtpp_flags) = "replace-origin replace-session-connection rtcp-mux-demux ";
				xlog("L_INFO", "Use mediaproxy for backward direction - [% logres -%]\n");
				if($var(ice_flags) != '')
				{
					$var(rtpp_flags) = $var(rtpp_flags) + $var(ice_flags);
				}

				if(pv_isset("$avp(s:first_caller_transport_protocol)"))
				{
					xlog("L_INFO", "Try protocol '$avp(s:first_caller_transport_protocol)' for caller - [% logreq -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "transport-protocol=" + $avp(s:first_caller_transport_protocol);
				}

				xlog("L_INFO", "Engaging rtpengine in reply for caller did '$avp(s:lbrtp_dispatcher_id_caller)' and callee did '$avp(s:lbrtp_dispatcher_id_callee)' - [% logres -%]\n");
				if($avp(s:lbrtp_dispatcher_id_caller) == $avp(s:lbrtp_dispatcher_id_callee))
				{
					set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})");
				}
				else
				{
					set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})", "$(avp(s:lbrtp_dispatcher_id_callee){s.int})");
				}
				rtpengine_answer($var(rtpp_flags));
			}
			else
			{
				$var(rtpp_flags) = "replace-origin replace-session-connection rtcp-mux-demux ";
				if(isbflagset(FLB_CALLER_IPV6) && isbflagset(FLB_CALLEE_IPV6))
				{
					xlog("L_INFO", "Use mediaproxy offer for backward direction for IPv6/IPv6 - [% logres -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "address-family=IP6 ";
				}
				else if(isbflagset(FLB_CALLER_IPV6) && !isbflagset(FLB_CALLEE_IPV6))
				{
					xlog("L_INFO", "Use mediaproxy offer for backward direction for IPv6/IPv4 - [% logres -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "address-family=IP6 ";
				}
				# we need to switch ei/ie in case of 200/ACK negotiation
				else if(!isbflagset(FLB_CALLER_IPV6) && isbflagset(FLB_CALLEE_IPV6))
				{
					xlog("L_INFO", "Use mediaproxy offer for backward direction for IPv4/IPv6 - [% logres -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "address-family=IP4 ";
				}
				else # if(!isbflagset(FLB_CALLER_IPV6) && !isbflagset(FLB_CALLEE_IPV6))
				{
					xlog("L_INFO", "Use mediaproxy offer for backward direction for IPv4/IPv4 - [% logres -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "address-family=IP4 ";
				}
				if($var(ice_flags) != '')
				{
					$var(rtpp_flags) = $var(rtpp_flags) + $var(ice_flags);
				}
				xlog("L_INFO", "Engaging rtpengine in reply for caller did '$avp(s:lbrtp_dispatcher_id_caller)' and callee did '$avp(s:lbrtp_dispatcher_id_callee)' - [% logres -%]\n");
				if($avp(s:lbrtp_dispatcher_id_caller) == $avp(s:lbrtp_dispatcher_id_callee))
				{
					set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})");
				}
				else
				{
					set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})", "$(avp(s:lbrtp_dispatcher_id_callee){s.int})");
				}
				rtpengine_offer($var(rtpp_flags));
			}
		}
	}
	if($avp(s:reply_sock) != 0)
	{
		append_hf("P-Out-Socket: $avp(s:reply_sock)\r\n");
	}
	if(status == "408")
	{
		$var(ext_timeout) = 1;
	}
	[% debug_dump('exit', 'REPLY_ROUTE_NAT') %]
	exit;
}

########################################################################
# Failure route for early rejects
########################################################################
failure_route[FAILURE_ROUTE_EARLY_REJECT]
{
	[% debug_dump('start', 'FAILURE_ROUTE_EARLY_REJECT') %]
	xlog("L_NOTICE", "Failure route for early rejection, rs='$T_rpl($rs)', expected rs='$avp(s:announce_code)' - [% logreq -%]\n");

	route(ROUTE_STOP_RTPPROXY_BRANCH);
	if($T_rpl($rs) != $avp(s:announce_code) && $T_rpl($rs) != 487)
	{
		xlog("L_INFO", "Overriding reply code '$T_rpl($rs)' with '$avp(s:announce_code)' - [% logreq -%]\n");
		route(ROUTE_ADD_CALLINFO_REPLY);
		t_reply("$avp(s:announce_code)", "$avp(s:announce_reason)");
	}
	[% debug_dump('exit', 'FAILURE_ROUTE_EARLY_REJECT') %]
	exit;
}

########################################################################
# Failure route 'pstn-failover'
########################################################################
failure_route[FAILURE_ROUTE_PSTN]
{
	[% debug_dump('start', 'FAILURE_ROUTE_PSTN') %]
	# reset previous D-Uri, otherwise the wrong destination is
	# used for cfb
	$du = $null;

	# initialise variables when entering failure route
	route(ROUTE_INITVARS);
	$var(to_pstn) = 1;

	xlog("L_NOTICE", "Failure route for PSTN call - [% logreq -%]\n");

	if(!lua_run("del_dlg_profile_peer", "$ci"))
	{
		xlog("L_ERROR", "Can't del peer[out]:$avp(s:lcr_flags) profiles\n");
	}
	xlog("L_INFO", "Unset dialog mark peer and peerout '$avp(s:lcr_flags)' - [% logreq -%]\n");
	if(t_check_status("402") && $T_rpl($si) == "[% sip_int_ips.0 %]" && $T_rpl($sp) == "[% sems.bindport %]")
	{
		xlog("L_NOTICE", "Prepaid account has no credit - [% logreq -%]\n");
		$var(announce_handle) = "no_credit";
		$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
		$(avp(s:announce_code)[*]) = 402;
		$(avp(s:announce_reason)[*]) = "Insufficient Credit";
		route(ROUTE_EARLY_REJECT);
	}
	route(ROUTE_FILTER_FAILOVER);
	setbflag(FLB_NATB);
	while($var(allow_peer) != 1)
	{
		$var(allow_peer) = 1;
		if(!next_gw())
		{
			xlog("L_NOTICE", "No more peering servers found - [% logreq -%]\n");
			#!ifdef ENABLE_PBX
			if(pv_isset("$avp(s:sca_active)"))
			{
				sca_call_info_update();
			}
			#!endif
			route(ROUTE_STOP_RTPPROXY_BRANCH);
			[% debug_dump('exit', 'FAILURE_ROUTE_PSTN') %]
			exit;
		}

		if($avp(s:lcr_flags) != $null && $avp(s:lcr_flags) != 0)
		{
			route(ROUTE_CLEAR_PEER_OUT_PREF);
			route(ROUTE_LOAD_PEER_OUT_PREF);
		}

		if(pv_isset("$xavp(callee_peer_prefs[0]=>concurrent_max)") &&
		   $xavp(callee_peer_prefs[0]=>concurrent_max) != 0 &&
		   $avp(s:em_call) != 1)
		{
			if(lua_run("get_profile_size","peer:$avp(s:lcr_flags)","size"))
			{
				if ($avp(s:size) >= $xavp(callee_peer_prefs[0]=>concurrent_max))
				{
					xlog("L_NOTICE", "Concurrent_max calls exceeded for peer '$avp(s:lcr_flags)' - [% logreq -%]\n");
					$var(allow_peer) = 0;
					$du = $null;
				}
			}
			else
			{
				xlog("L_ERROR", "Can't get peer:$avp(s:lcr_flags) profile_size\n");
				$var(allow_peer) = 0;
				$du = $null;
			}
		}
		if(pv_isset("$xavp(callee_peer_prefs[0]=>concurrent_max_out)") &&
		   $xavp(callee_peer_prefs[0]=>concurrent_max_out) != 0 &&
		   $avp(s:em_call) != 1)
		{
			if(lua_run("get_profile_size","peerout:$avp(s:lcr_flags)","size"))
			{
				if ($avp(s:size) >= $xavp(callee_peer_prefs[0]=>concurrent_max_out))
				{
					xlog("L_NOTICE", "Concurrent_max_out calls exceeded for peer '$avp(s:lcr_flags)' - [% logreq -%]\n");
					$var(allow_peer) = 0;
					$du = $null;
				}
			}
			else
			{
				xlog("L_ERROR", "Can't get peerout:$avp(s:lcr_flags) profile_size\n");
				$var(allow_peer) = 0;
				$du = $null;
			}
		}
	}

	if(!lua_run("set_dlg_profile_peer", "$ci"))
	{
		xlog("L_ERROR", "Can't set peer profile\n");
	}
	else
	{
		xlog("L_INFO", "Dialog set mark peer and peerout '$avp(s:lcr_flags)' - [% logreq -%]\n");
	}

	resetbflag(FLB_CALLEE_IPV6);
	if($rd =~ "^\[[a-fA-F0-9\:\.]+\]$")
	{
		setbflag(FLB_CALLEE_IPV6);
	}

	t_on_failure("FAILURE_ROUTE_PSTN");
	# suppress writing records in outbound route
	$var(no_acc) = 1;
	# trigger rewrite of callee acc leg in branch route
	# to reflect the current gw ip in destination domain of cdr
	$var(reset_acc_callee) = 1;
	#t_on_branch("BRANCH_ROUTE_SBC");
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'FAILURE_ROUTE_PSTN') %]
}

########################################################################
# Failure route for Faxserver
########################################################################
failure_route[FAILURE_ROUTE_FAXSERVER]
{
	[% debug_dump('start', 'FAILURE_ROUTE_FAXSERVER') %]
	route(ROUTE_FILTER_FAILOVER);
	$var(to_local_endpoint) = 1;
	setbflag(FLB_NATB);
	if(!ds_next_dst())
	{
		xlog("L_ERR", "Failed to select next Faxserver gateway - [% logreq -%]\n");
		route(ROUTE_STOP_RTPPROXY_BRANCH);
		[% debug_dump('exit', 'FAILURE_ROUTE_FAXSERVER') %]
		exit;
	}

	t_on_failure("FAILURE_ROUTE_FAXSERVER");
	$var(no_acc) = 1;
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'FAILURE_ROUTE_FAXSERVER') %]
}

########################################################################
# Failure route for Application Server
########################################################################
failure_route[FAILURE_ROUTE_APPSRV]
{
	[% debug_dump('start', 'FAILURE_ROUTE_APPSRV') %]
	xlog("L_NOTICE", "Failure route for Application Server call - [% logreq -%]\n");

	# initialise variables when entering failure route
	route(ROUTE_INITVARS);

	#!ifdef ENABLE_PRESENCE
	if(t_check_status("300") && !t_is_canceled())
	{
		xlog("L_NOTICE", "Awakened by NOTIFY from PUA (user registered) - [% logreq -%]\n");
		$rU = $avp(s:acc_callee_user_in);
		$rd = $avp(s:acc_callee_domain_in);
		$var(from_push_server) = 1;
		resetbflag(FLB_NATB);
		route(ROUTE_INVITE_TO_INT);
		[% debug_dump('exit', 'FAILURE_ROUTE_APPSRV') %]
		exit;
	}
	#!endif
	route(ROUTE_FILTER_FAILOVER);
	$var(to_local_endpoint) = 1;
	setbflag(FLB_NATB);
	if(!ds_next_dst())
	{
		xlog("L_ERR", "Failed to select next Application Server server - [% logreq -%]\n");
		route(ROUTE_STOP_RTPPROXY_BRANCH);
		[% debug_dump('exit', 'FAILURE_ROUTE_APPSRV') %]
		exit;
	}

	t_on_failure("FAILURE_ROUTE_APPSRV");
	$var(no_acc) = 1;
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'FAILURE_ROUTE_APPSRV') %]
}

#!ifdef ENABLE_PBX
########################################################################
# Failure route for Cloud PBX Server
########################################################################
failure_route[FAILURE_ROUTE_PBXSRV]
{
	[% debug_dump('start', 'FAILURE_ROUTE_PBXSRV') %]
	xlog("L_NOTICE", "Failure route for hosted PBX call - [% logreq -%]\n");

	route(ROUTE_FILTER_FAILOVER);
	$var(to_local_endpoint) = 1;
	setbflag(FLB_NATB);
	if(!ds_next_dst())
	{
		xlog("L_ERR", "Failed to select next cloud PBX server - [% logreq -%]\n");
		route(ROUTE_STOP_RTPPROXY_BRANCH);
		[% debug_dump('exit', 'FAILURE_ROUTE_PBXSRV') %]
		exit;
	}

	t_on_failure("FAILURE_ROUTE_PBXSRV");
	$var(no_acc) = 1;
	route(ROUTE_OUTBOUND);
	[% debug_dump('end', 'FAILURE_ROUTE_PBXSRV') %]
}
#!endif

########################################################################
# Failure route 'base-standard-failure'
########################################################################
failure_route[FAILURE_ROUTE_LOCAL]
{
	[% debug_dump('start', 'FAILURE_ROUTE_LOCAL') %]
	xlog("L_NOTICE", "Failure route for local call - [% logreq -%]\n");

	# reset previous D-Uri, otherwise the wrong destination is
	# used for cfb
	$du = $null;

	# initialise variables when entering failure route
	route(ROUTE_INITVARS);

	route(ROUTE_STOP_RTPPROXY_BRANCH);
	if($xavp(callee_real_prefs[0]=>serial_forking_by_q_value) == 1)
	{
		if(t_next_contacts())
		{
			setflag(FLAG_SET_RUSER);
			t_on_failure("FAILURE_ROUTE_LOCAL");
			t_on_branch_failure("redirect");
			$var(no_acc) = 1;
			route(ROUTE_OUTBOUND);
		}
	}
	if(t_check_status("402") && $T_rpl($si) == "[% sip_int_ips.0 %]" && $T_rpl($sp) == "[% sems.bindport %]")
	{
		xlog("L_NOTICE", "Prepaid account has no credit - [% logreq -%]\n");
		$var(announce_handle) = "no_credit";
		$var(announce_set) = $xavp(caller_real_prefs[0]=>sound_set);
		$(avp(s:announce_code)[*]) = 402;
		$(avp(s:announce_reason)[*]) = "Insufficient Credit";
		route(ROUTE_EARLY_REJECT);
	}
	if(t_check_status("401") && is_method("NOTIFY"))
	{
		xlog("L_INFO", "Pass authentication reply for NOTIFY to UAC - [% logreq -%]\n");
		[% debug_dump('exit', 'FAILURE_ROUTE_LOCAL') %]
		exit;
	}
	if((t_check_status("402|422|481|487") && $avp(s:to_huntgroup_initial) != 1) || t_is_canceled())
	{
		xlog("L_NOTICE", "Final reply - [% logreq -%]\n");
		#!ifdef ENABLE_PBX
		if(pv_isset("$avp(s:sca_active)"))
		{
			sca_call_info_update();
		}
		#!endif
		[% debug_dump('exit', 'FAILURE_ROUTE_LOCAL') %]
		exit;
	}
	if(t_check_status("404") && ($avp(s:has_extension) == 1 || $xavp(callee_real_prefs[0]=>e164_to_ruri) == 1) && !isflagset(FLAG_IN_FALLBACK))
	{
		$(avp(s:acc_state)[*]) = "cfu";
		$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
		$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
		$(avp(s:acc_caller_user)[*]) = $avp(s:acc_callee_user);
		$(avp(s:acc_caller_domain)[*]) = $avp(s:acc_callee_domain);
		$rU = $avp(s:callee_user);
		$rd = $avp(s:callee_domain);
		setflag(FLAG_IN_FALLBACK);
		append_branch();

		if($avp(s:has_extension) == 1)
		{
			xlog("L_NOTICE", "Fallback from extension to user - [% logreq -%]\n");
		}
		else
		{
			xlog("L_NOTICE", "Fallback from E164 number to user - [% logreq -%]\n");
		}
		$var(forward) = 1;
		$var(no_acc) = 1;
		# caller is the same user, skip loading caller's prefs
		#route(ROUTE_LOAD_CALLER_PREF);
		route(ROUTE_FIND_CALLEE);
	}
	if(t_check_status("486"))
	{
		if(pv_isset("$xavp(callee_real_prefs[0]=>cfb[0])") && $avp(s:p_to_group) == 1 &&
		   pv_isset("$xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting)") &&
		   $xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting) == 1)
		{
			xlog("L_NOTICE", "Disregard CFB for callee when called within a hunt group - [% logreq -%]\n");
			pv_unset("$xavp(callee_real_prefs[0]=>cfb[*])");
		}
		while(pv_isset("$xavp(callee_real_prefs[0]=>cfb[0])"))
		{
			$var(cf_id) = $xavp(callee_real_prefs[0]=>cfb[0]);
			xlog("L_NOTICE", "CFB to CF map id '$var(cf_id)' found - [% logreq -%]\n");
			route(ROUTE_LOAD_CF_MAP);
			while($avp(s:cf_destinations) != $null && $(avp(s:cf_destinations)[0]) =~ "^sip:localuser@.+\.local$")
			{
				xlog("L_INFO", "CFB breakout to local user skipped - [% logreq -%]\n");
				$(avp(s:cf_timeouts)[0]) = $null;
				$(avp(s:cf_destinations)[0]) = $null;
			}
			while($avp(s:p_to_group) == 1 && $avp(s:cf_destinations) != $null &&
			 $(avp(s:cf_destinations)[0]) =~ "^sip:.+@.+\.local$")
			{
				xlog("L_INFO", "Local endpoint '$(avp(s:cf_destinations)[0])' skipped for group hunting - [% logreq -%]\n");
				$(avp(s:cf_timeouts)[0]) = $null;
				$(avp(s:cf_destinations)[0]) = $null;
			}
			if($avp(s:cf_destinations) == $null)
			{
				xlog("L_INFO", "CFB skipped due to forward destinations definitions - [% logreq -%]\n");
			}
			else
			{
				route(ROUTE_CHECK_CF_PERIOD);
				if($rc == 1)
				{
					xlog("L_NOTICE", "CFB to destination '$(avp(s:cf_destinations)[0])' with timeout '$(avp(s:cf_timeouts)[0])' activated - [% logreq -%]\n");
					$ru = $(avp(s:cf_destinations)[0]);
					$(avp(s:cf_destinations)[0]) = $null;
					$(avp(s:callee_fr_inv_timer)[*]) = $(avp(s:cf_timeouts)[0]) * 1000;
					t_set_fr("$avp(s:callee_fr_inv_timer)");
					$(avp(s:cf_timeouts)[0]) = $null;
					$(avp(s:cf_depth)[*]) = $(avp(s:cf_depth){s.int}) + 1;
					$(avp(s:acc_state)[*]) = "cfb";
					$(avp(s:hih_cause)[*]) = "486";
					$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
					$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
					$(avp(s:acc_caller_user)[*]) = $avp(s:acc_callee_user);
					$(avp(s:acc_caller_domain)[*]) = $avp(s:acc_callee_domain);
					append_branch();
					route(ROUTE_EXECUTE_CF_LOOP);
					[% debug_dump('exit', 'FAILURE_ROUTE_LOCAL') %]
					exit;
				}
				else
				{
					xlog("L_INFO", "CFB skipped due to time period definitions - [% logreq -%]\n");
				}
			}
			pv_unset("$xavp(callee_real_prefs[0]=>cfb[0])");
		}
		if($avp(s:p_to_group) != 1 && $avp(hih_cause) == 0 && $avp(s:from_pbx) != 1)
		{
			$var(announce_handle) = "callee_busy";
			$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
		}
		else
		{
			$var(announce_handle) = "";
			$var(announce_set) = 0;
		}
		$(avp(s:announce_code)[*]) = 486;
		$(avp(s:announce_reason)[*]) = "Busy Here";
		route(ROUTE_EARLY_REJECT);
	}
	else if((t_check_status("408") && $var(ext_timeout) != 1) || $avp(s:to_huntgroup_initial) == 1)
	{
		if(pv_isset("$xavp(callee_real_prefs[0]=>cft[0])") && $avp(s:p_to_group) == 1 &&
		   pv_isset("$xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting)") &&
		   $xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting) == 1)
		{
			xlog("L_NOTICE", "Disregard CFT for callee when called within a hunt group - [% logreq -%]\n");
			pv_unset("$xavp(callee_real_prefs[0]=>cft[*])");
		}
		while(pv_isset("$xavp(callee_real_prefs[0]=>cft[0])"))
		{
			$var(cf_id) = $xavp(callee_real_prefs[0]=>cft[0]);
			xlog("L_NOTICE", "CFT to CF map id '$var(cf_id)' found - [% logreq -%]\n");
			route(ROUTE_LOAD_CF_MAP);
			while($avp(s:cf_destinations) != $null && $(avp(s:cf_destinations)[0]) =~ "^sip:localuser@.+\.local$")
			{
				xlog("L_INFO", "CFT breakout to local user skipped - [% logreq -%]\n");
				$(avp(s:cf_timeouts)[0]) = $null;
				$(avp(s:cf_destinations)[0]) = $null;
			}
			while($avp(s:p_to_group) == 1 && $avp(s:cf_destinations) != $null &&
			 $(avp(s:cf_destinations)[0]) =~ "^sip:.+@.+\.local$")
			{
				xlog("L_INFO", "Local endpoint '$(avp(s:cf_destinations)[0])' skipped for group hunting - [% logreq -%]\n");
				$(avp(s:cf_timeouts)[0]) = $null;
				$(avp(s:cf_destinations)[0]) = $null;
			}
			if($avp(s:cf_destinations) == $null)
			{
				xlog("L_INFO", "CFT skipped due to forward destinations definitions - [% logreq -%]\n");
			}
			else
			{
				route(ROUTE_CHECK_CF_PERIOD);
				if($rc == 1)
				{
					xlog("L_NOTICE", "CFT to destination '$(avp(s:cf_destinations)[0])' with timeout '$(avp(s:cf_timeouts)[0])' activated - [% logreq -%]\n");
					$ru = $(avp(s:cf_destinations)[0]);
					$(avp(s:cf_destinations)[0]) = $null;
					$(avp(s:callee_fr_inv_timer)[*]) = $(avp(s:cf_timeouts)[0]) * 1000;
					t_set_fr("$avp(s:callee_fr_inv_timer)");
					$(avp(s:cf_timeouts)[0]) = $null;
					$(avp(s:cf_depth)[*]) = $(avp(s:cf_depth){s.int}) + 1;
					$(avp(s:acc_state)[*]) = "cft";
					$(avp(s:hih_cause)[*]) = "408";
					$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
					$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
					$(avp(s:acc_caller_user)[*]) = $avp(s:acc_callee_user);
					$(avp(s:acc_caller_domain)[*]) = $avp(s:acc_callee_domain);
					append_branch();
					route(ROUTE_EXECUTE_CF_LOOP);
						[% debug_dump('exit', 'FAILURE_ROUTE_LOCAL') %]
					exit;
				}
				else
				{
					xlog("L_INFO", "CFT skipped due to time period definitions - [% logreq -%]\n");
				}
			}
			pv_unset("$xavp(callee_real_prefs[0]=>cft[0])");
		}
		# if it's a call leg to HG member - play the early announce only on incoming leg
		# if it's a call leg to HG itself - play the early announce only if
		# call has not been looped through pbx yet, e.g. call from PSTN to HG
		if($avp(s:p_to_group) != 1 && $avp(hih_cause) == 0 && $avp(s:from_pbx) != 1)
		{
			$var(announce_handle) = "callee_tmp_unavailable";
			$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
		}
		else
		{
			$var(announce_handle) = "";
			$var(announce_set) = 0;
		}
		$(avp(s:announce_code)[*]) = 408;
		$(avp(s:announce_reason)[*]) = "Request Timeout";
		route(ROUTE_EARLY_REJECT);
	}
	if(pv_isset("$xavp(callee_real_prefs[0]=>cfna[0])") && $avp(s:p_to_group) == 1 &&
	   pv_isset("$xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting)") &&
	   $xavp(callee_contract_prefs[0]=>ignore_cf_when_hunting) == 1)
	{
		xlog("L_NOTICE", "Disregard CFNA for callee when called within a hunt group - [% logreq -%]\n");
		pv_unset("$xavp(callee_real_prefs[0]=>cfna[*])");
	}
	while(pv_isset("$xavp(callee_real_prefs[0]=>cfna[0])"))
	{
		$var(cf_id) = $xavp(callee_real_prefs[0]=>cfna[0]);
		xlog("L_NOTICE", "CFNA to CF map id '$var(cf_id)' found - [% logreq -%]\n");
		route(ROUTE_LOAD_CF_MAP);
		while($avp(s:cf_destinations) != $null && $(avp(s:cf_destinations)[0]) =~ "^sip:localuser@.+\.local$")
		{
			xlog("L_INFO", "CFNA breakout to local user skipped - [% logreq -%]\n");
			$(avp(s:cf_timeouts)[0]) = $null;
			$(avp(s:cf_destinations)[0]) = $null;
		}
		while($avp(s:p_to_group) == 1 && $avp(s:cf_destinations) != $null &&
		 $(avp(s:cf_destinations)[0]) =~ "^sip:.+@.+\.local$")
		{
			xlog("L_INFO", "Local endpoint '$(avp(s:cf_destinations)[0])' skipped for group hunting - [% logreq -%]\n");
			$(avp(s:cf_timeouts)[0]) = $null;
			$(avp(s:cf_destinations)[0]) = $null;
		}
		if($avp(s:cf_destinations) == $null)
		{
			xlog("L_INFO", "CFNA skipped due to forward destinations definitions - [% logreq -%]\n");
		}
		else
		{
			route(ROUTE_CHECK_CF_PERIOD);
			if($rc == 1)
			{
				xlog("L_NOTICE", "CFNA to destination '$(avp(s:cf_destinations)[0])' with timeout '$(avp(s:cf_timeouts)[0])' activated - [% logreq -%]\n");
				$ru = $(avp(s:cf_destinations)[0]);
				$(avp(s:cf_destinations)[0]) = $null;
				$(avp(s:callee_fr_inv_timer)[*]) = $(avp(s:cf_timeouts)[0]) * 1000;
				t_set_fr("$avp(s:callee_fr_inv_timer)");
				$(avp(s:cf_timeouts)[0]) = $null;
				$(avp(s:cf_depth)[*]) = $(avp(s:cf_depth){s.int}) + 1;
				$(avp(s:acc_state)[*]) = "cfna";
				$(avp(s:hih_cause)[*]) = "404";
				$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
				$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
				$(avp(s:acc_caller_user)[*]) = $avp(s:acc_callee_user);
				$(avp(s:acc_caller_domain)[*]) = $avp(s:acc_callee_domain);
				append_branch();
				route(ROUTE_EXECUTE_CF_LOOP);
				[% debug_dump('exit', 'FAILURE_ROUTE_LOCAL') %]
				exit;
			}
			else
			{
				xlog("L_INFO", "CFNA skipped due to time period definitions - [% logreq -%]\n");
			}
		}
		pv_unset("$xavp(callee_real_prefs[0]=>cfna[0])");
	}
	#!ifdef ENABLE_PBX
	if(pv_isset("$avp(s:sca_active)"))
	{
		sca_call_info_update();
	}
	#!endif
	if($avp(s:p_to_group) != 1 && $avp(hih_cause) == 0 && $avp(s:from_pbx) != 1)
	{
		$var(announce_handle) = "callee_tmp_unavailable";
		$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
	}
	else
	{
		$var(announce_handle) = "";
		$var(announce_set) = 0;
	}
	$(avp(s:announce_code)[*]) = $T_rpl($rs);
	$(avp(s:announce_reason)[*]) = $T_rpl($rr);
	route(ROUTE_EARLY_REJECT);
	[% debug_dump('end', 'FAILURE_ROUTE_LOCAL') %]
}

########################################################################
# Failure route for serial call hunting
########################################################################
failure_route[FAILURE_ROUTE_HUNT]
{
	[% debug_dump('start', 'FAILURE_ROUTE_HUNT') %]
	xlog("L_NOTICE", "Failure route for hunt call - [% logreq -%]\n");
	route(ROUTE_STOP_RTPPROXY_BRANCH);
	if(t_check_status("402|422|481|487") || t_is_canceled())
	{
		xlog("L_NOTICE", "Final reply - [% logreq -%]\n");
		[% debug_dump('exit', 'FAILURE_ROUTE_HUNT') %]
		exit;
	}

	# reset previous D-Uri, otherwise the wrong destination is
	# used for cfb
	$du = $null;

	# initialise variables when entering failure route
	route(ROUTE_INITVARS);
	$var(hunt_failure) = 1;
	# increment hih counter
	$(avp(s:cf_loop_counter)[*]) = $(avp(s:cf_loop_counter){s.int}) + 1;
	xlog("L_INFO", "++++++++++ incremented History-Info counter, $$avp(s:cf_loop_counter)='$avp(s:cf_loop_counter)' - [% logreq -%]\n");
	xlog("L_INFO", "++++++++++ History-Info: (hunt failure) rcv_index='$avp(s:hih_caller_index)' - [% logreq -%]\n");

	if($avp(s:acc_state) != "cfu")
	{
		while($avp(s:cf_destinations) != $null && $(avp(s:cf_destinations)[0]) =~ "^sip:localuser@.+\.local$")
		{
			xlog("L_INFO", "CF breakout to local user skipped - [% logreq -%]\n");
			$(avp(s:cf_timeouts)[0]) = $null;
			$(avp(s:cf_destinations)[0]) = $null;
		}
	}
	if($avp(s:cf_destinations) != $null)
	{
		$ru = $(avp(s:cf_destinations)[0]);

		if($ru =~ "^sip:localuser@.+\.local$")
		{
			t_reset_fr();
			$(avp(s:cf_destinations)[*]) = $null;
			$(avp(s:cf_timeouts)[*]) = $null;
			$(avp(s:cf_periods)[*]) = $null;
			pv_unset("$xavp(callee_real_prefs[0]=>cfu[*])");
			$ru = "sip:" + $avp(s:acc_callee_user) + "@" + $avp(s:acc_callee_domain);
			xlog("L_NOTICE", "Stop hunting for CFU to own subscriber - [% logreq -%]\n");
			$var(forward) = 1;
			$(avp(s:nohunt)[*]) = 1;
			append_branch();
			# no need to load caller prefs as only the destination changes
			route(ROUTE_FIND_CALLEE);
		}

		$(avp(s:cf_destinations)[0]) = $null;
		$(avp(s:callee_fr_inv_timer)[*]) = $(avp(s:cf_timeouts)[0]) * 1000;
		t_set_fr("$avp(s:callee_fr_inv_timer)");
		$(avp(s:cf_timeouts)[0]) = $null;
		$(avp(s:cf_depth)[*]) = $(avp(s:cf_depth){s.int}) + 1;
		append_branch();
		if($rd =~ "^.+\.local$")
		{
			avp_delete("$avp(s:caller_uuid)/g");
			avp_copy("$avp(s:callee_uuid)", "$avp(s:caller_uuid)/d");
			$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
			$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
			$(avp(s:acc_caller_user)[*]) = $avp(s:acc_callee_user);
			$(avp(s:acc_caller_domain)[*]) = $avp(s:acc_callee_domain);
			$var(forward) = 1;
			route(ROUTE_LOAD_CALLER_PREF);
			route(ROUTE_FIND_CALLEE);
			[% debug_dump('exit', 'FAILURE_ROUTE_HUNT') %]
			exit;
		}
		else
		{
			route(ROUTE_EXECUTE_CF_LOOP);
			[% debug_dump('exit', 'FAILURE_ROUTE_HUNT') %]
			exit;
		}
	}
	#!ifdef ENABLE_PBX
	if(pv_isset("$avp(s:sca_active)"))
	{
		sca_call_info_update();
	}
	#!endif
	[% debug_dump('end', 'FAILURE_ROUTE_HUNT') %]
}

########################################################################
# Branch route for forwarding loop
########################################################################
branch_route[BRANCH_ROUTE_FWD_LOOP]
{
	[% debug_dump('start', 'BRANCH_ROUTE_FWD_LOOP') %]
	$(avp(s:app_server_params)[*]) = $null;
	if(([% FOREACH ip IN sip_int_ips -%]$du != "sip:[% ip %]:[% kamailio.proxy.port %]" && [% END -%]is_domain_local("$rd")) ||
		$dd =~ "\.local$" || ($du == $null && $rd =~ "\.local$"))
	{
		xlog("L_INFO", "Dropping local hunt branch - [% logreq -%]\n");
		drop;
		[% debug_dump('exit', 'BRANCH_ROUTE_FWD_LOOP') %]
		exit;
	}
	#!ifdef ENABLE_PREPAID
	if($xavp(caller_real_prefs[0]=>prepaid) == 1 || $xavp(callee_real_prefs[0]=>prepaid) == 1)
	{
		route(ROUTE_CC_PREPAID);
	}
	#!endif
	if(is_present_hf("History-Info") && $var(cf_loop) != 1 &&
	   !($avp(s:acc_state) == "cfna" || $avp(s:acc_state) == "cft" || $avp(s:acc_state) == "cfb"))
	{
	        route(ROUTE_PROCESS_INCOMING_HIH);
	}

	# set the History-Info header
	if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
	{
		$var(ccli_selector) = $xavp(callee_peer_prefs[0]=>outbound_history_info);
	}
	else
	{
		$var(ccli_selector) = $xavp(callee_real_prefs[0]=>outbound_history_info);
	}
	if($var(ccli_selector) != "" && $var(ccli_selector) != 0)
	{
		#if($var(cf_loop) == 1)
		#{
			if(!($avp(s:callee_base_user) =~ "^\+"))
				$var(new_hih_user) = "+" + $avp(s:callee_base_user);
			else
				$var(new_hih_user) = $avp(s:callee_base_user);

			if($avp(s:our_hih_user) == $avp(s:callee_base_user))
				xlog("L_NOTICE", "Skip History-Info setting, received History-Info '$hdr(History-Info)' is our user '$var(new_hih_user)' - [% logreq -%]\n");
			else
			{
				xlog("L_INFO", "Prepare History-Info setting, rcv_index='$avp(s:hih_caller_index)', loop_count='$avp(s:cf_loop_counter)' - [% logreq -%]\n");
				###############################
				# calculate index
				###############################
				if($avp(s:hih_caller_index) != 0 && ($avp(s:acc_state) == "cfna" || $avp(s:acc_state) == "cft" || $avp(s:acc_state) == "cfb"))
				{
					xlog("L_INFO", "Not adding hunt failure counter to History-Info index, reason='$avp(s:acc_state)' - [% logreq -%]\n");
				}
				else if($avp(s:hih_caller_index) != 0)
				{
					if($var(hunt_failure) == 0)
						$(avp(s:hih_caller_index)[*]) = $_s($avp(s:hih_caller_index).$avp(s:cf_loop_counter));
				}
				else
				{
					$(avp(s:hih_caller_index)[*]) = $avp(s:cf_loop_counter);
				}
				xlog("L_INFO", "++++++++++ History-Info: new index='$avp(s:hih_caller_index)' - [% logreq -%]\n");
				###############################
				# add cause
				##############################
				$var(hih_uri) = $_s(sip:$var(new_hih_user)@$avp(s:callee_domain):5060);
				# TODO: is $var(cf_loop)==1?
				if($avp(s:hih_cause) != 0 && $var(cf_loop) == 1)
				{
					$var(hih_uri) = $_s($var(hih_uri);cause=$avp(s:hih_cause));
				}
				###############################
				# add user=phone and privacy
				###############################
				if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
				{
					$var(history_info) = $_s(<$var(hih_uri)>;index=$avp(s:hih_caller_index));
				}
				else if($xavp(callee_real_prefs[0]=>clir) == 1)
				{
					$var(history_info) = $_s(<$var(hih_uri);user=phone?privacy=history>;index=$avp(s:hih_caller_index));
				}
				else
				{
					$var(history_info) = $_s(<$var(hih_uri);user=phone>;index=$avp(s:hih_caller_index));
				}
				###############################
				# append History-Info
				###############################
				xlog("L_NOTICE", "Setting History-Info (HUNT route) to '$var(history_info)' - [% logreq -%]\n");
				append_hf("History-Info: $var(history_info)\r\n");
			}
		#}
	}
	remove_hf("P-CF-Loop-Count");
	if($var(hunt_failure) == 1)
	{
		append_hf("P-CF-Loop-Count: $avp(s:cf_loop_counter)\r\n");
		$var(hunt_failure) = 0;
	}
	remove_hf("P-HIH-Cause");
	append_hf("P-HIH-Cause: $avp(s:hih_cause)\r\n");

	xlog("L_INFO", "Setting sbcprofile to cf - [% logreq -%]\n");
	$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";profile=ngcp_cf";

	#Write sbc params
	xlog("L_INFO", "Writing sbc parameters  $avp(s:app_server_params) - [% logreq -%]\n");
	append_hf("P-App-Param: $avp(s:app_server_params)\r\n");
	if(is_present_hf("P-App-Param"))
	{
		remove_hf("P-App-Param");
	}

	if(is_present_hf("P-App-Name"))
	{
		remove_hf("P-App-Name");
	}
	append_hf("P-App-Name: sbc\r\n");
	#Append P-D-URI
	xlog("L_NOTICE", "Appending P-D-URI '$du' - [% logreq -%]\n");
	remove_hf("P-D-Uri");
	append_hf("P-D-Uri: $du\r\n");

	#Append CF-specific headers
	remove_hf("P-Caller-UUID");
	append_hf("P-Caller-UUID: $avp(s:callee_uuid)\r\n");
	remove_hf("P-First-Caller-UPN");
	append_hf("P-First-Caller-UPN: $avp(s:first_caller_cli_userprov)\r\n");
	remove_hf("P-First-Caller-NPN");
	append_hf("P-First-Caller-NPN: $avp(s:first_caller_cli_netprov)\r\n");
	remove_hf("P-First-Caller-UPD");
	append_hf("P-First-Caller-UPD: $avp(s:first_caller_domain_userprov)\r\n");
	remove_hf("P-First-Caller-NPD");
	append_hf("P-First-Caller-NPD: $avp(s:first_caller_domain_netprov)\r\n");
	remove_hf("P-Acc-Caller-User");
	append_hf("P-Acc-Caller-User: $avp(s:acc_caller_user)\r\n");
	remove_hf("P-Acc-Caller-Domain");
	append_hf("P-Acc-Caller-Domain: $avp(s:acc_caller_domain)\r\n");
	remove_hf("P-Acc-State");
	append_hf("P-Acc-State: $avp(s:acc_state)\r\n");
	remove_hf("P-From-Peer");
	# make sure to set P-From-Peer for direct calls from pstn and
	# for CF loops originating from pstn
	if($avp(s:from_pstn) == 1)
	{
		$(avp(s:cf_from_pstn)[*]) = 1;
	}
	append_hf("P-From-Peer: $avp(s:cf_from_pstn)\r\n");
	remove_hf("P-First-V46-RTP");
	append_hf("P-First-V46-RTP: $avp(s:first_caller_ipv46_for_rtpproxy)\r\n");
	remove_hf("P-First-RTP");
	append_hf("P-First-RTP: $avp(s:first_caller_use_rtpproxy)\r\n");
	if($avp(s:from_pbx) == 1)
	{
		$(avp(s:first_caller_transport_protocol)[*]) = "RTP/AVP";
	}
	remove_hf("P-First-RTP-Transport");
	append_hf("P-First-RTP-Transport: $avp(s:first_caller_transport_protocol)\r\n");
	remove_hf("P-First-Caller-CLIR");
	append_hf("P-First-Caller-CLIR: $avp(s:caller_clir)\r\n");
	remove_hf("P-CF-Depth");
	append_hf("P-CF-Depth: $avp(s:cf_depth)\r\n");
	remove_hf("P-First-Caller-UA-Mode");
	if(pv_isset("$avp(s:first_caller_ua_header_mode)"))
	{
		append_hf("P-First-Caller-UA-Mode: $avp(s:first_caller_ua_header_mode)\r\n");
	}
	remove_hf("P-First-Caller-UA-Replace");
	if(pv_isset("$avp(s:first_caller_ua_header_replace)"))
	{
		append_hf("P-First-Caller-UA-Replace: $avp(s:first_caller_ua_header_replace)\r\n");
	}
	remove_hf("P-First-Caller-Cloud-PBX");
	if(pv_isset("$avp(s:first_caller_pbx_account_id)"))
	{
		append_hf("P-First-Caller-Cloud-PBX: $avp(s:first_caller_pbx_account_id)\r\n");
	}

	remove_hf("P-Callee-Ext-Subs-ID");
	append_hf("P-Callee-Ext-Subs-ID: $var(callee_ext_subscriber_id)\r\n");
	remove_hf("P-Callee-Ext-Contr-ID");
	append_hf("P-Callee-Ext-Contr-ID: $var(callee_ext_contract_id)\r\n");
	remove_hf("P-Callee-Account-ID");
	append_hf("P-Callee-Account-ID: $var(callee_account_id)\r\n");
	remove_hf("P-Orig-Callee-Dialed");
	append_hf("P-Orig-Callee-Dialed: $avp(s:acc_callee_user_in)\r\n");

	$var(first_caller_rtp_interface) = "ext";
	$var(first_callee_rtp_interface) = "ext";
	$var(first_caller_rtp_interface_source) = "default";
	$var(first_callee_rtp_interface_source) = "default";
	if($avp(s:from_pstn) == 1 && pv_isset("$xavp(caller_peer_prefs[0]=>rtp_interface)"))
	{
		$var(first_caller_rtp_interface) = $xavp(caller_peer_prefs[0]=>rtp_interface);
		$var(first_caller_rtp_interface_source) = "caller peer";
	}
	else if(pv_isset("$xavp(caller_real_prefs[0]=>rtp_interface)"))
	{
		$var(first_caller_rtp_interface) = $xavp(caller_real_prefs[0]=>rtp_interface);
		$var(first_caller_rtp_interface_source) = "caller";
	}
	if(is_present_hf("P-First-Caller-RTP-Interface"))
	{
		remove_hf("P-First-Caller-RTP-Interface");
	}
	if(is_present_hf("P-First-Caller-RTP-Interface-Source"))
	{
		remove_hf("P-First-Caller-RTP-Interface-Source");
	}
	append_hf("P-First-Caller-RTP-Interface: $var(first_caller_rtp_interface)\r\n");
	append_hf("P-First-Caller-RTP-Interface-Source: $var(first_caller_rtp_interface_source)\r\n");

	$du = "sip:[% sip_int_ips.0 %]:[% sems.bindport %]";
	xlog("L_NOTICE", "Forcing request via B2BUA '$du' - [% logreq -%]\n");
	route(ROUTE_ADD_CALLINFO);
	[% debug_dump('end', 'BRANCH_ROUTE_FWD_LOOP') %]
}

########################################################################
# Branch route for mediaproxy activation and a few typical functions -
# required calls going through sbc as well as calls to application servers
########################################################################
route[ROUTE_BRANCH_ACC_RTP]
{	
	[% debug_dump('start', 'ROUTE_BRANCH_ACC_RTP') %]
	if($var(reset_acc_callee) == 1)
	{
		# rewrite callee acc leg to put in correct destination domain
		$(avp(i:902)[*]) = $null;
		$(avp(s:acc_callee_domain)[*]) = $rd;
		route(ROUTE_ACC_CALLEE);
	}

	resetbflag(FLB_PEERAUTH);

	# we still need to set the params in case of 200/ACK and later re-invite
	if($avp(s:first_caller_use_rtpproxy) == "ice_replace_candidates")
	{
		add_rr_param(";ice_caller=replace");
		setbflag(FLB_ICE_CALLER_REPLACE);
	}
	else if($avp(s:first_caller_use_rtpproxy) == "ice_add_candidates")
	{
		add_rr_param(";ice_caller=add");
		setbflag(FLB_ICE_CALLER_ADD);
	}
	else #if($avp(s:first_caller_use_rtpproxy) == "ice_strip_candidates")
	{
		add_rr_param(";ice_caller=strip");
		setbflag(FLB_ICE_CALLER_STRIP);
	}

	if($avp(s:from_pbx) == 1 ||
	   ($var(from_local_endpoint) == 1 &&
	   # if from voicemail or iaxmodem - transcode to RTP
	   !($avp(s:from_faxserver) == 1 && $var(sendfax) != 1))
	  )
	{
		$(avp(s:first_caller_transport_protocol)[*]) = "RTP/AVP";
	}

	if($xavp(callee_peer_prefs[0]=>use_rtpproxy) == "ice_replace_candidates" ||
	   $xavp(callee_real_prefs[0]=>use_rtpproxy) == "ice_replace_candidates")
	{
		add_rr_param(";ice_callee=replace");
		setbflag(FLB_ICE_CALLEE_REPLACE);
	}
	else if($xavp(callee_peer_prefs[0]=>use_rtpproxy) == "ice_add_candidates" ||
	        $xavp(callee_real_prefs[0]=>use_rtpproxy) == "ice_add_candidates")
	{
		add_rr_param(";ice_callee=add");
		setbflag(FLB_ICE_CALLEE_ADD);
	}
	else 
	     #if($xavp(callee_peer_prefs[0]=>use_rtpproxy) == "ice_strip_candidates" ||
	     #   $xavp(callee_real_prefs[0]=>use_rtpproxy) == "ice_strip_candidates")
	{
		add_rr_param(";ice_callee=strip");
		setbflag(FLB_ICE_CALLEE_STRIP);
	}
	$var(callee_transport_protocol) = "";
	# webrtc endpoint automatic detection
	if($(ru{uri.param,transport}) == "ws")
	{
		$var(callee_transport_protocol) = "UDP/TLS/RTP/SAVPF";
	}
	else if(($var(to_local_endpoint) == 1 && $var(callee_is_hwfax) != 1) ||
		($var(to_pbx) == 1 && $var(no_sbc) == 1))
	# don't transcode to RTP call to hwfax because this overwrites "UDPTL" to "RTP/AVP"
	{
		$var(callee_transport_protocol) = "RTP/AVP";
	}
	else if($var(to_pstn) == 1 && pv_isset("$xavp(callee_peer_prefs[0]=>transport_protocol)"))
	{
		$var(callee_transport_protocol) = $xavp(callee_peer_prefs[0]=>transport_protocol);
	}
	else if(pv_isset("$xavp(callee_real_prefs[0]=>transport_protocol)"))
	{
		$var(callee_transport_protocol) = $xavp(callee_real_prefs[0]=>transport_protocol);
	}
	if(sdp_content())
	{
		if($avp(s:from_faxserver) == 1 || $avp(s:to_faxserver) == 1)
		{
			# fix for T.38 to patton faxserver gateway, which chokes on upper-case
			xlog("L_INFO", "Rewriting T.38 'UDPTL' to 'udptl' - [% logreq -%]\n");
			replace_body_all(" UDPTL ", " udptl ");
		}

		if(($xavp(callee_real_prefs[0]=>use_rtpproxy) == "never" || 
		    $xavp(callee_peer_prefs[0]=>use_rtpproxy) == "never" || 
		    $avp(s:first_caller_use_rtpproxy) == "never") && 
		   $var(from_local_endpoint) == 0 && $var(to_local_endpoint) == 0)
		{
			xlog("L_INFO", "Usage of mediaproxy unforced by preference - [% logreq -%]\n");
			resetbflag(FLB_RTPPROXY);
		}
		else if($xavp(caller_real_prefs[0]=>bypass_rtpproxy) == "same_nat" &&
			$avp(s:nat) == "1" && $du != $null && $du != $ru &&
			$(du{uri.param,received}{s.unescape.param}{uri.host}) == $avp(s:ip))
		{
			xlog("L_INFO", "Usage of mediaproxy unforced for callee behind same NAT '$(du{uri.param,received}{s.unescape.param}{uri.host})' - [% logreq -%]\n");
			resetbflag(FLB_RTPPROXY);
		}
		else if($var(proxylu_src) == 1)
		{
			xlog("L_INFO", "Usage of mediaproxy unforced on proxylu source - [% logreq -%]\n");
			resetbflag(FLB_RTPPROXY);
		}
		else
		{
			$var(rtpp_flags) = "replace-origin replace-session-connection rtcp-mux-demux ";

			if(!isbflagset(FLB_NATB))
			{
				xlog("L_INFO", "Usage of mediaproxy forced by preference - [% logreq -%]\n");
			}

			if($avp(s:first_caller_ipv46_for_rtpproxy) == "force_ipv4")
			{
				xlog("L_INFO", "Force IPv4 in mediaproxy for initial caller - [% logreq -%]\n");
				resetbflag(FLB_CALLER_IPV6);
			}
			else if($avp(s:first_caller_ipv46_for_rtpproxy) == "force_ipv6")
			{
				xlog("L_INFO", "Force IPv6 in mediaproxy for initial caller - [% logreq -%]\n");
				setbflag(FLB_CALLER_IPV6);
			}
			if($xavp(callee_peer_prefs[0]=>ipv46_for_rtpproxy) == "force_ipv4" || 
			   $xavp(callee_real_prefs[0]=>ipv46_for_rtpproxy) == "force_ipv4")
			{
				xlog("L_INFO", "Force IPv4 in mediaproxy for callee - [% logreq -%]\n");
				resetbflag(FLB_CALLEE_IPV6);
			}
			else if($xavp(callee_peer_prefs[0]=>ipv46_for_rtpproxy) == "force_ipv6" ||
			        $xavp(callee_real_prefs[0]=>ipv46_for_rtpproxy) == "force_ipv6")
			{
				xlog("L_INFO", "Force IPv6 in mediaproxy for callee - [% logreq -%]\n");
				setbflag(FLB_CALLEE_IPV6);
			}

			if(isbflagset(FLB_CALLER_IPV6) && isbflagset(FLB_CALLEE_IPV6))
			{
				xlog("L_INFO", "Use mediaproxy for forward direction for IPv6/IPv6 - [% logreq -%]\n");
				$var(rtpp_flags) = $var(rtpp_flags) + "address-family=IP6 ";
			}
			else if(isbflagset(FLB_CALLER_IPV6) && !isbflagset(FLB_CALLEE_IPV6))
			{
				xlog("L_INFO", "Use mediaproxy for forward direction for IPv6/IPv4 - [% logreq -%]\n");
				$var(rtpp_flags) = $var(rtpp_flags) + "address-family=IP4 ";
			}
			else if(!isbflagset(FLB_CALLER_IPV6) && isbflagset(FLB_CALLEE_IPV6))
			{
				xlog("L_INFO", "Use mediaproxy for forward direction for IPv4/IPv6 - [% logreq -%]\n");
				$var(rtpp_flags) = $var(rtpp_flags) + "address-family=IP6 ";
			}
			else # if(!isbflagset(FLB_CALLER_IPV6) && !isbflagset(FLB_CALLEE_IPV6))
			{
				xlog("L_INFO", "Use mediaproxy for forward direction for IPv4/IPv4 - [% logreq -%]\n");
				$var(rtpp_flags) = $var(rtpp_flags) + "address-family=IP4 ";
			}

			$var(caller_rtp_interface) = "ext";
			$var(callee_rtp_interface) = "ext";
			$var(caller_rtp_interface_source) = "default";
			$var(callee_rtp_interface_source) = "default";
			if($var(cf_loop) == 1)
			{
				if(pv_isset("$avp(s:first_caller_rtp_interface)") && pv_isset("$avp(s:first_caller_rtp_interface_source)"))
				{
					$var(caller_rtp_interface) = $avp(s:first_caller_rtp_interface);
					$var(caller_rtp_interface_source) = "original " + $avp(s:first_caller_rtp_interface_source);
				}
			}
			else if($avp(s:from_pstn) == 1 && pv_isset("$xavp(caller_peer_prefs[0]=>rtp_interface)"))
			{
				$var(caller_rtp_interface) = $xavp(caller_peer_prefs[0]=>rtp_interface);
				$var(caller_rtp_interface_source) = "caller peer";
			}
			else if(pv_isset("$xavp(caller_real_prefs[0]=>rtp_interface)"))
			{
				$var(caller_rtp_interface) = $xavp(caller_real_prefs[0]=>rtp_interface);
				$var(caller_rtp_interface_source) = "caller";
			}
			if($var(to_pstn) == 1 && pv_isset("$xavp(callee_peer_prefs[0]=>rtp_interface)"))
			{
				$var(callee_rtp_interface) = $xavp(callee_peer_prefs[0]=>rtp_interface);
				$var(callee_rtp_interface_source) = "callee peer";
			}
			else if(pv_isset("$xavp(callee_real_prefs[0]=>rtp_interface)"))
			{
				$var(callee_rtp_interface) = $xavp(callee_real_prefs[0]=>rtp_interface);
				$var(callee_rtp_interface_source) = "callee";
			}
			if ($var(caller_rtp_interface_source) != "default" || $var(callee_rtp_interface_source) != "default")
			{
				xlog("L_INFO", "Bridge RTP interfaces $var(caller_rtp_interface)/$var(callee_rtp_interface) configured for $var(caller_rtp_interface_source)/$var(callee_rtp_interface_source) - [% logreq -%]\n");
				$var(rtpp_flags) = $var(rtpp_flags) + "direction=$var(caller_rtp_interface) direction=$var(callee_rtp_interface) ";
			}

			if(isflagset(FLAG_DOWNSTREAM))
			{
				if(isbflagset(FLB_ICE_CALLEE_REPLACE))
				{
					xlog("L_INFO", "Replace existing ICE candidates (if any) for callee with mediaproxy ICE canditate - [% logreq -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "ICE=force ";
				}
				else if(isbflagset(FLB_ICE_CALLEE_STRIP))
				{
					xlog("L_INFO", "Remove existing ICE candidates (if any) for callee - [% logreq -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "ICE=remove ";
				}
				else if(isbflagset(FLB_ICE_CALLEE_ADD))
				{
					xlog("L_INFO", "Add mediaproxy as ICE candidate for callee - [% logreq -%]\n");
				}

				if($var(callee_transport_protocol) != "")
				{
					xlog("L_INFO", "Try protocol '$var(callee_transport_protocol)' for callee - [% logreq -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "transport-protocol=" + $var(callee_transport_protocol);
				}
			}
			else if(isflagset(FLAG_UPSTREAM))
			{
				if(isbflagset(FLB_ICE_CALLER_REPLACE))
				{
					xlog("L_INFO", "Replace existing ICE candidates (if any) for caller with mediaproxy ICE canditate - [% logreq -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "ICE=force ";
				}
				else if(isbflagset(FLB_ICE_CALLER_STRIP))
				{
					xlog("L_INFO", "Remove existing ICE candidates (if any) for caller - [% logreq -%]\n");
					$var(rtpp_flags) = $var(rtpp_flags) + "ICE=remove ";
				}
				else if(isbflagset(FLB_ICE_CALLER_ADD))
				{
					xlog("L_INFO", "Add mediaproxy as ICE candidate for caller - [% logreq -%]\n");
				}
			}

			xlog("L_INFO", "Engaging rtpengine in request for caller did '$avp(s:lbrtp_dispatcher_id_caller)' and callee did '$avp(s:lbrtp_dispatcher_id_callee)' - [% logreq -%]\n");
			if($avp(s:lbrtp_dispatcher_id_caller) == $avp(s:lbrtp_dispatcher_id_callee))
			{
				set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})");
				add_rr_param(";aset=$avp(s:lbrtp_dispatcher_id_caller)");
			}
			else
			{
				set_rtpengine_set("$(avp(s:lbrtp_dispatcher_id_caller){s.int})", "$(avp(s:lbrtp_dispatcher_id_callee){s.int})");
				add_rr_param(";aset=$avp(s:lbrtp_dispatcher_id_caller)");
				add_rr_param(";bset=$avp(s:lbrtp_dispatcher_id_callee)");
			}
			rtpengine_offer($var(rtpp_flags));
			setbflag(FLB_RTPPROXY); # remember that we use rtpproxy
			setbflag(FLB_RTPPROXY_LOOKUP); # force rtpproxy lookup in the reply (opposed to 200/ACK)
			add_rr_param(";rtpprx=yes");
		}
	}
	else
	{
		xlog("L_INFO", "No SDP found, skip mediaproxy for forward direction - [% logreq -%]\n");
		setbflag(FLB_RTPPROXY);
		add_rr_param(";rtpprx=yes");
 	}

	if($avp(s:caller_uuid) != $null && !is_present_hf("P-Caller-UUID"))
	{
		xlog("L_INFO", "Setting P-Caller-UUID to '$avp(s:caller_uuid)' - [% logreq -%]\n");
		append_hf("P-Caller-UUID: $avp(s:caller_uuid)\r\n");
	}
	if($avp(s:callee_uuid) != $null && !is_present_hf("P-Callee-UUID"))
	{
		xlog("L_INFO", "Setting P-Callee-UUID to '$avp(s:callee_uuid)' - [% logreq -%]\n");
		append_hf("P-Callee-UUID: $avp(s:callee_uuid)\r\n");
	}
	if(is_present_hf("User-Agent"))
	{
		if($avp(s:first_caller_ua_header_mode) == "replace" && pv_isset("$avp(s:first_caller_ua_header_replace)"))
		{
			if(remove_hf("User-Agent"))
			{
				# User Agent header removed
		    		insert_hf("User-Agent: $avp(s:first_caller_ua_header_replace)\r\n", "Call-ID");
				xlog("L_INFO", "Setting User-Agent to '$avp(s:first_caller_ua_header_replace)' - [% logreq -%]\n");
			}
		}
		else if($avp(s:first_caller_ua_header_mode) == "strip")
		{
			if(remove_hf("User-Agent"))
			{
				xlog("L_INFO", "User Agent header removed - [% logreq -%]\n");
			}
		}
	}
	else if(pv_isset("$avp(s:first_caller_ua_header_replace)"))
	{
    		insert_hf("User-Agent: $avp(s:first_caller_ua_header_replace)\r\n", "Call-ID");
		xlog("L_INFO", "Setting User-Agent to '$avp(s:first_caller_ua_header_replace)' - [% logreq -%]\n");
	}
	[% debug_dump('end', 'ROUTE_BRANCH_ACC_RTP') %]
}

########################################################################
# Common route for setting session timer parameters - used for regular calls going via sems sbc 
# as well as calls to application and pbx servers (called from branch routes sbc and no_sbc)
########################################################################
route[ROUTE_PREPARE_SST]
{
	[% debug_dump('start', 'ROUTE_PREPARE_SST') %]
	#pass caller's settings as aleg_sst_* 
	if($avp(s:from_pstn) == 1)
	{
		if($xavp(caller_peer_prefs[0]=>sst_enable) == "yes")
		{
			xlog("L_INFO", "Sessions Timers enabled for caller with interval $xavp(caller_peer_prefs[0]=>sst_expires) and method $xavp(caller_peer_prefs[0]=>sst_refresh_method) - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";aleg_sst_enable=yes" + 
				";aleg_sst_expires=" + $xavp(caller_peer_prefs[0]=>sst_expires) + 
				";aleg_sst_min_timer=" + $xavp(caller_peer_prefs[0]=>sst_min_timer) + 
				";aleg_sst_max_timer=" + $xavp(caller_peer_prefs[0]=>sst_max_timer) + 
				";aleg_sst_refresh_method=" + $xavp(caller_peer_prefs[0]=>sst_refresh_method);
		}
		else
		{
			xlog("L_INFO", "Sessions Timers disabled for caller - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";aleg_sst_enable=no";
		}
	}
	else if($avp(s:from_pstn) == 0)
	{
		if($xavp(caller_real_prefs[0]=>sst_enable) == "yes" && $avp(s:from_faxserver) == 0 && $avp(s:from_voicebox) == 0)
		{
			xlog("L_INFO", "Sessions Timers enabled for caller with interval $xavp(caller_real_prefs[0]=>sst_expires) and method $xavp(caller_real_prefs[0]=>sst_refresh_method) - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";aleg_sst_enable=yes" + 
				";aleg_sst_expires=" + $xavp(caller_real_prefs[0]=>sst_expires) + 
				";aleg_sst_min_timer=" + $xavp(caller_real_prefs[0]=>sst_min_timer) + 
				";aleg_sst_max_timer=" + $xavp(caller_real_prefs[0]=>sst_max_timer) + 
				";aleg_sst_refresh_method=" + $xavp(caller_real_prefs[0]=>sst_refresh_method);
		}
		else
		{
			xlog("L_INFO", "Sessions Timers disabled for caller - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";aleg_sst_enable=no";
		}
	}
	#pass callee's settings as sst_* 
	if($var(to_pstn) == 1)
	{
		if($xavp(callee_peer_prefs[0]=>sst_enable) == "yes")
		{
			xlog("L_INFO", "Sessions Timers enabled for callee with interval $xavp(callee_peer_prefs[0]=>sst_expires) and method $xavp(callee_peer_prefs[0]=>sst_refresh_method) - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";sst_enable=yes" + 
				";sst_expires=" + $xavp(callee_peer_prefs[0]=>sst_expires) + 
				";sst_min_timer=" + $xavp(callee_peer_prefs[0]=>sst_min_timer) + 
				";sst_max_timer=" + $xavp(callee_peer_prefs[0]=>sst_max_timer) + 
				";sst_refresh_method=" + $xavp(callee_peer_prefs[0]=>sst_refresh_method);
		}
		else
		{
			xlog("L_INFO", "Sessions Timers disabled for callee - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";sst_enable=no";
			if (hf_value_exists("Supported", "timer"))
			{
				xlog("L_INFO", "Remove timer from Supported - [% logreq -%]\n");
				exclude_hf_value("Supported", "timer");
			}
			if(is_present_hf("Session-Expires"))
			{
				xlog("L_INFO", "Remove Session-Expires - [% logreq -%]\n");
				remove_hf("Session-Expires");
			}
		}
	}
	else if($var(to_pstn) == 0)
	{
		if($xavp(callee_real_prefs[0]=>sst_enable) == "yes")
		{
			xlog("L_INFO", "Sessions Timers enabled for callee with interval $xavp(callee_real_prefs[0]=>sst_expires) and method $xavp(callee_real_prefs[0]=>sst_refresh_method) - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";sst_enable=yes" +
				";sst_expires=" + $xavp(callee_real_prefs[0]=>sst_expires) + 
				";sst_min_timer=" + $xavp(callee_real_prefs[0]=>sst_min_timer) +
				";sst_max_timer=" + $xavp(callee_real_prefs[0]=>sst_max_timer) + 
				";sst_refresh_method=" + $xavp(callee_real_prefs[0]=>sst_refresh_method);
		}
		else
		{
			xlog("L_INFO", "Sessions Timers disabled for callee - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";sst_enable=no";
			if (hf_value_exists("Supported", "timer"))
			{
				xlog("L_INFO", "Remove timer from Supported - [% logreq -%]\n");
				exclude_hf_value("Supported", "timer");
			}
			if(is_present_hf("Session-Expires"))
			{
				xlog("L_INFO", "Remove Session-Expires - [% logreq -%]\n");
				remove_hf("Session-Expires");
			}
		}
	}
	[% debug_dump('end', 'ROUTE_PREPARE_SST') %]
}

########################################################################
# Branch route 'no-sbc'
# Handle typical application server parameters (calling card, pbx etc)
########################################################################
branch_route[BRANCH_ROUTE_NO_SBC]
{
	[% debug_dump('start', 'BRANCH_ROUTE_NO_SBC') %]
	# Activate mediaproxy
	route(ROUTE_BRANCH_ACC_RTP);
	# here we handle e164_to_ruri option on CF when callee is a PBX user
	if(isflagset(FLAG_SET_RUSER))
	{
		route(ROUTE_SET_RUSER);
	}
	[% IF kamailio.proxy.filter_100rel_from_supported == "yes" -%]
	if (hf_value_exists("Supported", "100rel"))
	{
		xlog("L_INFO", "Remove 100rel from Supported - [% logreq -%]\n");
		exclude_hf_value("Supported", "100rel");
	}
	[% END -%]
	if($var(no_sbc) == 1)
	{
		# agranig: don't rewrite From for caller-loop to PBX
		#!ifdef ENABLE_PBX
		if($var(from_pbx_initial) || $var(is_replaces))
		{
			xlog("L_INFO", "Don't set caller/callee for initial loop to PBX - [% logreq -%]\n");
		}
		else if($var(to_pbx) == 1 && $var(to_local_endpoint) == 1)
		{
			xlog("L_INFO", "Don't set caller/callee for call to PBX endpoint - [% logreq -%]\n");
		}
		else if($avp(s:from_pbx) == 1 && $avp(s:p_to_device) == 0 && $avp(s:p_to_group) == 0 &&
			$var(to_pbx) == 1 && $var(no_sbc) == 1)
		{
			xlog("L_INFO", "Don't set caller/callee for call from PBX endpoint (AA/OH) - [% logreq -%]\n");
		}
		else
		{
		#!endif
			route(ROUTE_SET_CALLER_CLI);
			route(ROUTE_SET_CALLEE);
		#!ifdef ENABLE_PBX
		}
		#!endif
		if($rU == "mobilepush" && $rd == "app.local")
		{
			$(avp(s:app_server_params)[*]) = ";caller=" + $avp(s:caller_cli_userprov) + ";callee=" + $avp(s:acc_callee_user_in) + ";domain=" + $avp(s:callee_domain);
			if(pv_isset("$xavp(callee_real_prefs[0]=>mobile_push_expiry)"))
			{
				 $(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";expires=" + $xavp(callee_real_prefs[0]=>mobile_push_expiry);
			}
			if($avp(s:rbt_file_id) != $null)
			{
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";audio_id=" + $avp(s:rbt_file_id);
			}
			# application-specific data_*
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";data_sender_number=" + $avp(s:caller_cli_userprov);
			if(pv_isset("$xavp(caller_real_prefs[0]=>display_name)"))
			{
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";data_sender_name=" + $xavp(caller_real_prefs[0]=>display_name);
			}
			else if($var(out_from_display) != 0)
			{
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";data_sender_name=" + $var(out_from_display);
			}
			else
			{
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";data_sender_name=" + $avp(s:caller_cli_userprov);
			}
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";data_type=call;data_sender_sip=" +
				$avp(s:caller_cli_userprov) + "@" + $avp(s:acc_caller_domain) + ";apns_sound='[% kamailio.proxy.push.apns_sound %]';apns_badge=0;apns_alert='[% kamailio.proxy.push.apns_alert %]'";
			xlog("L_INFO", "Writing mobile_push params '$avp(s:app_server_params)' - [% logreq -%]\n");
			if(is_present_hf("P-App-Param"))
			{
				remove_hf("P-App-Param");
			}
			append_hf("P-App-Param: $avp(s:app_server_params)\r\n");

			if(is_present_hf("P-App-Name"))
			{
				remove_hf("P-App-Name");
			}
			append_hf("P-App-Name: mobile_push\r\n");

			xlog("L_INFO", "Setting P-Called-Party-ID '<sip:$tU@$td>' - [% logreq -%]\n");
			if(is_present_hf("P-Called-Party-ID"))
			{
				remove_hf("P-Called-Party-ID");
			}
			append_hf("P-Called-Party-ID: <sip:$tU@$td>\r\n");

			xlog("L_INFO", "Setting P-Orig-Callee-User to '$avp(s:callee_user)' - [% logreq -%]\n");
			if(is_present_hf("P-Orig-Callee-User"))
			{
				remove_hf("P-Orig-Callee-User");
			}
			append_hf("P-Orig-Callee-User: $avp(s:callee_user)\r\n");
			#append_hf("P-Orig-Callee-Domain: $avp(s:callee_domain)\r\n");
		}
		#!ifdef ENABLE_PBX
		else if($var(to_pbx) == 1)
		{
			if($var(rgroup_uris) != 0)
			{
				$var(pbx_app_name) = "sbc";
				append_hf("P-Huntgroup-Members: $var(rgroup_uris)\r\n");
				if(pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy)"))
				{
					append_hf("P-Hunting-Policy: $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy)\r\n");
				}
				if(pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_timeout)") &&
				   pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy)") &&
				   $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy) != "parallel")
				{
					append_hf("P-Hunting-Timeout: $xavp(callee_real_prefs[0]=>cloud_pbx_hunt_timeout)\r\n");
				}
				xlog("L_INFO", "Set hunt policy to '$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_policy)' with timeout '$xavp(callee_real_prefs[0]=>cloud_pbx_hunt_timeout)' - [% logreq -%]\n");
			}
			if($(var(pbx_app_name){s.len}) > 0 && $var(pbx_app_name) =~ "callqueues")
			{
				if(!pv_isset("$xavp(callee_real_prefs[0]=>contract_sound_set)"))
				{
					# TODO: agranig: reject if there is no sound set?
					$xavp(callee_real_prefs[0]=>contract_sound_set) = "0";
				}
				if($avp(s:p_to_group) == 1 && $var(group_uuid) != 0)
				{
					$(avp(s:app_server_params)[*]) = "uuid=" + $var(group_uuid);
				}
				else
				{
					$(avp(s:app_server_params)[*]) = "uuid=" + $avp(s:callee_uuid);
				}
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";contract_sound_set_id=" + $xavp(callee_real_prefs[0]=>contract_sound_set)
								 + ";sound_set_id=" + $xavp(caller_real_prefs[0]=>sound_set)
								 + ";phone_uri=sip:" + $avp(s:callee_user) + "@" + $avp(s:callee_domain);
				if(pv_isset("$xavp(callee_real_prefs[0]=>max_queue_length)"))
				{
					$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";max_queue_length=" + $xavp(callee_real_prefs[0]=>max_queue_length);
				}
				if(pv_isset("$xavp(callee_real_prefs[0]=>queue_wrap_up_time)"))
				{
					$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";callee_wrap_up_time=" + $xavp(callee_real_prefs[0]=>queue_wrap_up_time);
				}
				if($var(cloud_pbx_hg_members) > 0)
				{
					$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";queueless_parallel_calls=" + $var(cloud_pbx_hg_members);
				}
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";phone_hdrs=P-To-Device: 1\\r\\nP-NGCP-From-CallQueue: 1\\r\\n";
				if(pv_isset("$avp(s:caller_clir)") && $avp(s:caller_clir) == 1)
				{
					$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + "P-Caller-CLIR: 1\\r\\n";
				}
			}
			else if($var(pbx_app_name) == 0)
			{
				# call forwarding to pbx
				$var(pbx_app_name) = $rU;
			}
			if(is_present_hf("P-App-Name"))
			{
				remove_hf("P-App-Name");
			}
			append_hf("P-App-Name: $var(pbx_app_name)\r\n");

			if(is_present_hf("P-App-Param"))
			{
				remove_hf("P-App-Param");
			}
			if($var(pbx_app_name) == "sbc")
			{
				route(ROUTE_PREPARE_MOH_PBX);
				route(ROUTE_PREPARE_SST);
			}
			if($var(caller_account_id) != 0 && $var(caller_account_id) != $null && $var(caller_account_id) != '')
			{
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";a_park_domain=" + $var(caller_account_id);
			}
			if($var(callee_account_id) != 0 && $var(callee_account_id) != $null && $var(callee_account_id) != '')
			{
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";b_park_domain=" + $var(callee_account_id);
			}

			xlog("L_INFO", "Writing pbx params '$avp(s:app_server_params)' - [% logreq -%]\n");
			append_hf("P-App-Param: $avp(s:app_server_params)\r\n");

			if($avp(s:from_pstn) == 1)
			{
				if(is_present_hf("P-Peer-ID"))
					remove_hf("P-Peer-ID");
				append_hf("P-Peer-ID: $avp(s:lcr_flags)\r\n");
			}
			else if($avp(s:from_faxserver) == 1)
			{
				if(is_present_hf("P-Faxserver-ID"))
					remove_hf("P-Faxserver-ID");
				append_hf("P-Faxserver-ID: $avp(s:tmpfaxgw)\r\n");
			}
			else if($avp(s:from_voicebox) == 1)
			{
				if(is_present_hf("P-Voicebox-ID"))
					remove_hf("P-Voicebox-ID");
				append_hf("P-Voicebox-ID: 1\r\n");
			}
			# set COLP and sca in branch route to avoid duplication
			if(
				!pv_isset("$avp(s:colpid)") && $var(from_pbx_initial) == 1 &&
				$xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
				$xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
				$xavp(caller_real_prefs[0]=>account_id) == $xavp(callee_real_prefs[0]=>account_id) &&
				pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_ext)")
			)
			{
				if(pv_isset("$xavp(callee_real_prefs[0]=>display_name)"))
				{
					$var(dpn) = $xavp(callee_real_prefs[0]=>display_name);
				}
				else
				{
					$var(dpn) = $xavp(callee_real_prefs[0]=>cloud_pbx_ext);
				}
				$(avp(s:colpid)[*]) = "\"" + $var(dpn) + "\" <sip:" + $xavp(callee_real_prefs[0]=>cloud_pbx_ext) + "@" + $fd + ">";
			}
			else if(
				!pv_isset("$avp(s:colpid)") && $var(from_pbx_initial) == 1 &&
				$xavp(caller_real_prefs[0]=>cloud_pbx) == 1 &&
				$xavp(callee_real_prefs[0]=>cloud_pbx) == 1 &&
				$xavp(caller_real_prefs[0]=>account_id) != $xavp(callee_real_prefs[0]=>account_id) &&
				pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx_ext)")
			)
			{
				# TODO set to CLI of caller
				#$(avp(s:colpid)[*]) = "\"" + $var(dpn) + "\" <sip:" + $xavp(callee_real_prefs[0]=>cloud_pbx_ext) + "@" + $fd + ">";
				xlog("L_INFO", "Need to set colpid for intrapbx - [% logreq -%]\n");
			}
			if($avp(s:sca_active) == 1)
			{
				add_rr_param(";sca=1");
			}
			if(pv_isset("$avp(s:colpid)"))
			{
				add_rr_param(";colp=$(avp(s:colpid){s.encode.hexa})");
			}
			route(ROUTE_LOAD_PBXSRV);
			xlog("L_NOTICE", "Forcing request via PBX '$du' - [% logreq -%]\n");
		}
		#!endif

		# if we're the source of a proxylu redirection, pass CLIs on in separate headers
		# without any normalization
		#!ifdef PROXY_LOOKUP
		if($var(proxylu_src) == 1)
		{
			route(ROUTE_CLEAR_PROXYLU_HEADERS);
			append_hf("P-First-Caller-UPN: sip:$avp(s:first_caller_cli_userprov)@$avp(s:first_caller_domain_userprov)\r\n");
			append_hf("P-First-Caller-NPN: sip:$avp(s:first_caller_cli_netprov)@$avp(s:first_caller_domain_netprov)\r\n");
			append_hf("P-First-Forwarder-UPN: sip:$avp(s:forwarder_cli_userprov)@$avp(s:forwarder_domain_userprov)\r\n");
			append_hf("P-Caller-UPN: sip:$avp(s:caller_cli_userprov)@$avp(s:caller_domain_userprov)\r\n");
			append_hf("P-Caller-NPN: sip:$avp(s:caller_cli_netprov)@$avp(s:caller_domain_netprov)\r\n");
			append_hf("P-First-V46-RTP: $avp(s:first_caller_ipv46_for_rtpproxy)\r\n");
			append_hf("P-First-RTP: $avp(s:first_caller_use_rtpproxy)\r\n");
			append_hf("P-First-RTP-Transport: $avp(s:first_caller_transport_protocol)\r\n");
			append_hf("P-Caller-CLIR: $avp(s:caller_clir)\r\n");
			append_hf("P-First-Caller-UA-Mode: $avp(s:first_caller_ua_header_mode)\r\n");
			append_hf("P-First-Caller-UA-Replace: $avp(s:first_caller_ua_header_replace)\r\n");
			append_hf("P-Caller-From-PSTN: $avp(s:lcr_flags)\r\n");
			if(pv_isset("$xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer)")) 
			{
				$var(tmppinfo) = $xavp(caller_real_prefs[0]=>force_outbound_calls_to_peer);
			}
			else if(pv_isset("$xavp(caller_peer_prefs[0]=>force_outbound_calls_to_peer)"))
			{
				$var(tmppinfo) = $xavp(caller_peer_prefs[0]=>force_outbound_calls_to_peer);
			}
			if(pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_user)") &&
			   pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_realm)") &&
			   pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_pass)"))
			{
				$var(tmppinfo) = 
					$var(tmppinfo) + ";" + 
					$xavp(caller_real_prefs[0]=>peer_auth_user) + ";" + 
					$xavp(caller_real_prefs[0]=>peer_auth_realm) + ";" + 
					$xavp(caller_real_prefs[0]=>peer_auth_pass);
			}
			append_hf("P-Caller-PeerInfo: $var(tmppinfo)\r\n");
			append_hf("P-Peer-By-Uuid: $xavp(caller_peer_prefs[0]=>find_subscriber_by_uuid)\r\n");


			xlog("L_NOTICE", "Setting P-Called-Party-ID '<sip:$tU@$td>' - [% logreq -%]\n");
			append_hf("P-Called-Party-ID: <sip:$tU@$td>\r\n");
		}
		#!endif
	}

	route(ROUTE_ADD_CALLINFO);
	xlog("L_NOTICE", "Request leaving server, D-URI='$du' - [% logreq -%]\n");
	[% debug_dump('end', 'BRANCH_ROUTE_NO_SBC') %]
}

########################################################################
# Branch route 'sbc'
# Handle sems sbc application parameters
########################################################################
branch_route[BRANCH_ROUTE_SBC]
{
	[% debug_dump('start', 'BRANCH_ROUTE_SBC') %]
	$(avp(s:app_server_params)[*]) = $null;

	#!ifdef ENABLE_PBX
	# Panasonic SLA needs this header
	if($avp(s:from_pbx) == 1 && ($avp(s:p_to_device) == 1 || $avp(s:p_to_group) == 1) &&
	   pv_isset("$xavp(callee_real_prefs[0]=>cloud_pbx)") && $xavp(callee_real_prefs[0]=>cloud_pbx) == 1)
	{
		append_hf("Call-Info: <sip:$avp(s:callee_domain)>;appearance-index=1\r\n");
	}
	#!endif

	# Activate mediaproxy
	route(ROUTE_BRANCH_ACC_RTP);
	if(isflagset(FLAG_SET_RUSER))
	{
		route(ROUTE_SET_RUSER);
	}
	if(is_domain_local("$rd") || $dd =~ "\.local$" || ($du == $null && $rd =~ "\.local$"))
	{
		xlog("L_INFO", "Dropping local branch - [% logreq -%]\n");
		drop;
		[% debug_dump('exit', 'BRANCH_ROUTE_ACC_RTP') %]
		exit;
	}
	[% IF kamailio.proxy.filter_100rel_from_supported == "yes" -%]
	if (hf_value_exists("Supported", "100rel"))
	{
		xlog("L_INFO", "Remove 100rel from Supported - [% logreq -%]\n");
		exclude_hf_value("Supported", "100rel");
	}
	[% END -%]
	# Activate prepaid
	#!ifdef ENABLE_PREPAID
	if($xavp(caller_real_prefs[0]=>prepaid) == 1 || $xavp(callee_real_prefs[0]=>prepaid) == 1)
	{
		route(ROUTE_CC_PREPAID);
	}
	#!endif
	if(is_present_hf("History-Info") && $var(cf_loop) !=1 && $avp(s:from_pstn) == 1)
	{
	        route(ROUTE_PROCESS_INCOMING_HIH);
	}
	if($var(no_sbc) == 0)
	{
		# Auth credentials for caller (b2bua leg-b callee)
		if($var(to_pstn) == 1)
		{
			if(pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_user)") &&
			   pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_realm)") &&
			   pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_pass)"))
			{
				xlog("L_NOTICE", "Adding b-leg subscriber specific peer authentication header P-App-Param with 'u=$xavp(caller_real_prefs[0]=>peer_auth_user);d=$xavp(caller_real_prefs[0]=>peer_auth_realm);p=$xavp(caller_real_prefs[0]=>peer_auth_pass)' - [% logreq -%]\n");
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";u=" + $xavp(caller_real_prefs[0]=>peer_auth_user) + ";d=" + $xavp(caller_real_prefs[0]=>peer_auth_realm) + ";p=" + $xavp(caller_real_prefs[0]=>peer_auth_pass);
				setbflag(FLB_PEERAUTH);
			}
			if(pv_isset("$xavp(callee_peer_prefs[0]=>peer_auth_user)") &&
			   pv_isset("$xavp(callee_peer_prefs[0]=>peer_auth_realm)") &&
			   pv_isset("$xavp(callee_peer_prefs[0]=>peer_auth_pass)"))
			{
				xlog("L_NOTICE", "Adding b-leg peer authentication header P-App-Param with 'u=$xavp(callee_peer_prefs[0]=>peer_auth_user);d=$xavp(callee_peer_prefs[0]=>peer_auth_realm);p=$xavp(callee_peer_prefs[0]=>peer_auth_pass)' - [% logreq -%]\n");
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";u=" + $xavp(callee_peer_prefs[0]=>peer_auth_user) + ";d=" + $xavp(callee_peer_prefs[0]=>peer_auth_realm) + ";p=" + $xavp(callee_peer_prefs[0]=>peer_auth_pass);
				setbflag(FLB_PEERAUTH);
			}
		}
		#!ifdef AUTH_BYE
		else #UAS auth credentials for callee
		{
			$(avp(s:uas_auth_user)[*]) = $null;
			$(avp(s:uas_auth_realm)[*]) = $null;
			$(avp(s:uas_auth_password)[*]) = $null;
		
			avp_db_query("select username,domain,password from kamailio.subscriber where uuid='$(avp(s:callee_uuid){s.escape.common})'", "$avp(s:uas_auth_user),$avp(s:uas_auth_realm),$avp(s:uas_auth_password)");
			xlog("L_NOTICE", "Adding UAS b-leg authentication params 'su=$avp(s:uas_auth_user);sr=$avp(s:uas_auth_realm);sp=$avp(s:uas_auth_password)' - [% logreq -%]\n");
			$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";su=" + $avp(s:uas_auth_user) + ";sr=" + $avp(s:uas_auth_realm) + ";sp=" + $avp(s:uas_auth_password);
		}
		#!endif
		# Auth credentials for callee (b2bua leg-a caller)
		if($avp(s:from_pstn) == 1)
		{
			if(pv_isset("$xavp(callee_real_prefs[0]=>peer_auth_user)") &&
			   pv_isset("$xavp(callee_real_prefs[0]=>peer_auth_realm)") &&
			   pv_isset("$xavp(callee_real_prefs[0]=>peer_auth_pass)"))
			{
				xlog("L_NOTICE", "Adding a-leg subscriber specific peer authentication header P-App-Param with 'au=$xavp(callee_real_prefs[0]=>peer_auth_user);ad=$xavp(callee_real_prefs[0]=>peer_auth_realm);ap=$xavp(callee_real_prefs[0]=>peer_auth_pass)' - [% logreq -%]\n");
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";au=" + $xavp(callee_real_prefs[0]=>peer_auth_user) + ";ad=" + $xavp(callee_real_prefs[0]=>peer_auth_realm) + ";ap=" + $xavp(callee_real_prefs[0]=>peer_auth_pass);
				setbflag(FLB_PEERAUTH);
			}
			if(pv_isset("$xavp(caller_peer_prefs[0]=>peer_auth_user)") &&
			   pv_isset("$xavp(caller_peer_prefs[0]=>peer_auth_realm)") &&
			   pv_isset("$xavp(caller_peer_prefs[0]=>peer_auth_pass)"))
			{
				xlog("L_NOTICE", "Adding a-leg peer authentication header P-App-Param with 'au=$xavp(caller_peer_prefs[0]=>peer_auth_user);ad=$xavp(caller_peer_prefs[0]=>peer_auth_realm);ap=$xavp(caller_peer_prefs[0]=>peer_auth_pass)' - [% logreq -%]\n");
				$(avp(s:app_server_params)[*]) = $avp(s:app_server_params) + ";au=" + $xavp(caller_peer_prefs[0]=>peer_auth_user) + ";ad=" + $xavp(caller_peer_prefs[0]=>peer_auth_realm) + ";ap=" + $xavp(caller_peer_prefs[0]=>peer_auth_pass);
				setbflag(FLB_PEERAUTH);
			}
		}
		route(ROUTE_PREPARE_SST);
		route(ROUTE_PREPARE_MOH);

		# route below MUST be called after setbflag(FLB_PEERAUTH)

		if(is_present_hf("P-Called-Party-ID"))
		{
			remove_hf("P-Called-Party-ID");
		}

		route(ROUTE_SET_CALLER_CLI);
		route(ROUTE_SET_CALLEE);
		if(!pv_isset("$avp(s:orig_callee_dialed)"))
		{
			$(avp(s:orig_callee_dialed)[*]) = $rU;
		}
		if($var(to_pstn) == 1 && $var(forced_outbound_call_to_peer) == 0)
		{
			$var(outbound_to_user) = $xavp(callee_peer_prefs[0]=>outbound_to_user);
		}
		else
		{
			$var(outbound_to_user) = $xavp(callee_real_prefs[0]=>outbound_to_user);
		}
		xlog("L_INFO", "Prepare P-Called-Party-ID setting using selector '$var(outbound_to_user)' - [% logreq -%]\n");
		if($var(outbound_to_user) == "orig_callee")
		{
			$var(to_domain) = $td;
			if(($var(to_pstn) == 1 && $xavp(callee_peer_prefs[0]=>outbound_to_user_is_phone) == 1) ||
			   ($var(to_pstn) == 0 && $xavp(callee_real_prefs[0]=>outbound_to_user_is_phone) == 1) &&
			   is_tel_number("$avp(s:orig_callee_dialed)"))
			{
				$var(to_domain) = $var(to_domain) + ";user=phone";
			}
			xlog("L_NOTICE", "Setting P-Called-Party-ID '<sip:$avp(s:orig_callee_dialed)@$var(to_domain)>' - [% logreq -%]\n");
			append_hf("P-Called-Party-ID: <sip:$avp(s:orig_callee_dialed)@$var(to_domain)>\r\n");
		}
		else if($var(outbound_to_user) == "rcvd_to")
		{
			$var(to_domain) = $avp(s:callee_domain);
			if(($var(to_pstn) == 1 && $xavp(callee_peer_prefs[0]=>outbound_to_user_is_phone) == 1) ||
			   ($var(to_pstn) == 0 && $xavp(callee_real_prefs[0]=>outbound_to_user_is_phone) == 1) &&
			   is_tel_number("$tU"))
			{
				$var(to_domain) = $var(to_domain) + ";user=phone";
			}
			xlog("L_NOTICE", "Setting P-Called-Party-ID '<sip:$tU@$var(to_domain)>' - [% logreq -%]\n");
			append_hf("P-Called-Party-ID: <sip:$tU@$var(to_domain)>\r\n");
		}
		else
		# if($var(outbound_to_user) == "callee")
		{
			$var(to_domain) = $avp(s:callee_domain);
			if($rU == $null)
			{
				# fallback to "received To-username" if $rU is undefined
				if(($var(to_pstn) == 1 && $xavp(callee_peer_prefs[0]=>outbound_to_user_is_phone) == 1) ||
				   ($var(to_pstn) == 0 && $xavp(callee_real_prefs[0]=>outbound_to_user_is_phone) == 1) &&
				   is_tel_number("$tU"))
				{
					$var(to_domain) = $var(to_domain) + ";user=phone";
				}
				xlog("L_NOTICE", "Setting P-Called-Party-ID '<sip:$tU@$var(to_domain)>' - [% logreq -%]\n");
				append_hf("P-Called-Party-ID: <sip:$tU@$var(to_domain)>\r\n");
			}
			else
			{
				if(($var(to_pstn) == 1 && $xavp(callee_peer_prefs[0]=>outbound_to_user_is_phone) == 1) ||
				   ($var(to_pstn) == 0 && $xavp(callee_real_prefs[0]=>outbound_to_user_is_phone) == 1) &&
				   is_tel_number("$rU"))
				{
					$var(to_domain) = $var(to_domain) + ";user=phone";
				}
				xlog("L_NOTICE", "Setting P-Called-Party-ID '<sip:$rU@$var(to_domain)>' - [% logreq -%]\n");
				append_hf("P-Called-Party-ID: <sip:$rU@$var(to_domain)>\r\n");
			}
		}

		#Write sbc params
		xlog("L_INFO", "Writing sbc parameters  $avp(s:app_server_params) - [% logreq -%]\n");
		if(is_present_hf("P-App-Param"))
		{
			remove_hf("P-App-Param");
		}
		append_hf("P-App-Param: $avp(s:app_server_params)\r\n");

		if(is_present_hf("P-App-Name"))
		{
			remove_hf("P-App-Name");
		}
		append_hf("P-App-Name: sbc\r\n");
		[%  IF kamailio.proxy.set_ruri_to_peer_auth_realm == "yes" %]
		if(pv_isset("$xavp(caller_real_prefs[0]=>peer_auth_realm)"))
		{
			xlog("L_NOTICE", "Setting R-URI '$rU@$xavp(caller_real_prefs[0]=>peer_auth_realm)' using peer auth realm of subscriber - [% logreq -%]\n");
			$ru = "sip:" + $rU + "@" + $xavp(caller_real_prefs[0]=>peer_auth_realm);
		}
		else if(pv_isset("$xavp(callee_peer_prefs[0]=>peer_auth_realm)"))
		{
			xlog("L_NOTICE", "Setting R-URI '$rU@$xavp(callee_peer_prefs[0]=>peer_auth_realm)' using peer auth realm of peer - [% logreq -%]\n");
			$ru = "sip:" + $rU + "@" + $xavp(callee_peer_prefs[0]=>peer_auth_realm);
		}
		[% END %]
		if($var(to_pstn) == 1 || $avp(s:to_faxserver) == 1)
		{
			if($du == $null || $du == $ru)
			{
				xlog("L_NOTICE", "Setting 'sip:$rd:$rp' taken from R-URI as next hop after lb for PSTN call - [% logreq -%]\n");
				if($var(foreign_dom) == 0)
				{
					if($(ru{uri.param,transport}) != $null && $(ru{uri.param,transport}) != '')
					{
						$du = $var(lburi) + ";received='sip:" + $rd + ":" + $rp + ";lr" + ";transport=" + $(ru{uri.param,transport}) + "'";
					}
					else
					{
						$du = $var(lburi) + ";received=sip:" + $rd + ":" + $rp + ";lr";
					}
					if(pv_isset("$xavp(callee_peer_prefs[0]=>outbound_socket)"))
					{
						xlog("L_NOTICE", "Forcing outbound socket '$xavp(callee_peer_prefs[0]=>outbound_socket)' to peer - [% logreq -%]\n");
						$du = $du + ";socket='" + $xavp(callee_peer_prefs[0]=>outbound_socket) + "'";
					}
				}
				else
				{
					# for calls to foreign domains we don't set received param, as kamailio-lb
					# is unable to do an SRV lookup for $du
					if($(ru{uri.param,transport}) != $null && $(ru{uri.param,transport}) != '')
					{
						$du = $var(lburi) + ";transport=" + $(ru{uri.param,transport}) + "'";
					}
					else
					{
						$du = $var(lburi);
					}
				}
				if(pv_isset("$avp(s:peer_out_route)"))
				{
					xlog("L_NOTICE", "Adding peer route set '$avp(s:peer_out_route)' - [% logreq -%]\n");
					$du = $du + ";peer_route=" + $(avp(s:peer_out_route){s.encode.hexa});
				}
			}
			else
			{
				xlog("L_NOTICE", "Setting 'sip:$dd:$dp' taken from D-URI as next hop after lb for PSTN call - [% logreq -%]\n");
				if($(du{uri.param,transport}) != $null && $(du{uri.param,transport}) != '')
				{
					$du = $var(lburi) + ";received='sip:" + $dd + ":" + $dp + ";lr" + ";transport=" + $(du{uri.param,transport}) + "'";
				}
				else
				{
					$du = $var(lburi) + ";received=sip:" + $dd + ":" + $dp + ";lr";
				}
				if(pv_isset("$xavp(callee_peer_prefs[0]=>outbound_socket)"))
				{
					xlog("L_NOTICE", "Forcing outbound socket '$xavp(callee_peer_prefs[0]=>outbound_socket)' to peer - [% logreq -%]\n");
					$du = $du + ";socket='" + $xavp(callee_peer_prefs[0]=>outbound_socket) + "'";
				}
				if(pv_isset("$avp(s:peer_out_route)"))
				{
					xlog("L_NOTICE", "Adding peer route set '$avp(s:peer_out_route)' - [% logreq -%]\n");
					$du = $du + ";peer_route=" + $(avp(s:peer_out_route){s.encode.hexa});
				}
			}
		}

		route(ROUTE_ADD_CALLINFO);

		xlog("L_NOTICE", "Appending P-D-URI '$du' - [% logreq -%]\n");
		remove_hf("P-D-Uri");
		append_hf("P-D-Uri: $du\r\n");

		$du = "sip:[% sip_int_ips.0 %]:[% sems.bindport %]";
		xlog("L_NOTICE", "Forcing request via B2BUA '$du' - [% logreq -%]\n");
	}
	else
	{
		route(ROUTE_ADD_CALLINFO);
	}

	xlog("L_NOTICE", "Request leaving server, D-URI='$du' - [% logreq -%]\n");
	[% debug_dump('end', 'BRANCH_ROUTE_SBC') %]
}

event_route[tm:branch-failure:redirect]
{
	[% debug_dump('start', 'redirect') %]
	route(ROUTE_STOP_RTPPROXY_BRANCH);
	if($T_rpl($rs) == 301 || $T_rpl($rs) == 302)
	{
		# initialise variables when entering failure route
		route(ROUTE_INITVARS);

		# these need to be avps because we need it in reply/failure-route
		$(avp(s:from_faxserver)[*]) = 0;
		$(avp(s:to_faxserver)[*]) = 0;
		$(avp(s:cf_from_pstn)[*]) = 0;
		$(avp(s:from_pstn)[*]) = 0;
		$(avp(s:proxylu_from_pstn)[*]) = 0;
		$(avp(s:lcr_flags)[*]) = 0;
		$(avp(s:em_call)[*]) = 0;
		$(avp(s:from_pbx)[*]) = 0;
		$(avp(s:p_to_device)[*]) = 0;
		$(avp(s:p_to_group)[*]) = 0;
		$(avp(s:is_primary)[*]) = 0;

		# now let's process a 30x
		$(avp(s:acc_state)[*]) = "cfb";
		$(avp(s:orig_acc_caller_user)[*]) = $avp(s:acc_caller_user);
		$(avp(s:orig_acc_caller_domain)[*]) = $avp(s:acc_caller_domain);
		$(avp(s:acc_caller_user)[*]) = $avp(s:acc_callee_user);
		$(avp(s:acc_caller_domain)[*]) = $avp(s:acc_callee_domain);
		$(avp(s:caller_uuid)[*]) = $avp(s:callee_uuid);
		$(avp(s:callee_uuid)[*]) = $null;

		# get last URI from destination-set and set it as R-URI
		$var(contact) = $T_rpl($ct);
		$var(contact) = $(var(contact){nameaddr.uri});
		if($var(contact) == 0 || $var(contact) == $null)
		{

			xlog("L_ERROR", "Failed to fetch contact '$ct' from 301/302 - [% logreq -%]\n");
			acc_db_request("480", "acc");
			$var(announce_handle) = "callee_tmp_unavailable";
			$var(announce_set) = $xavp(callee_real_prefs[0]=>sound_set);
			$(avp(s:announce_code)[*]) = 480;
			$(avp(s:announce_reason)[*]) = "Temporarily Unavailable";
			route(ROUTE_EARLY_REJECT);
		}
		$ru = $var(contact);
		# not needed in per-branch failure route?
		#append_branch();

		#t_on_branch("BRANCH_ROUTE_SBC");
		xlog("L_NOTICE", "Redirect from UAC intercepted - [% logreq -%]\n");
		$(avp(s:forwarder_cli_userprov)[*]) = $T_rpl($tU);
		$(avp(s:forwarder_domain_userprov)[*]) = $T_rpl($td);
		$var(forward) = 1;
		$var(redirected_forward) = 1;
		route(ROUTE_LOAD_CALLER_PREF);
		route(ROUTE_FIND_CALLEE);
	}
	[% debug_dump('end', 'redirect') %]
}

event_route[dialog:end]
{
	[% debug_dump('start', 'dialog:end') %]
	if (!lua_run("del_dlg_profile", "$ci"))
	{
		xlog("L_ERROR", "Failed to decrease redis counters - [% logreq -%]\n");
	}
	else
	{
		xlog("L_INFO", "removed redis counters - [% logreq -%]\n");
	}
	#!ifdef ENABLE_PBX
	lua_run("del_dlg_list", "$ci");
	#!endif
	[% debug_dump('end', 'dialog:end') %]
}

event_route[dialog:failed]
{
	[% debug_dump('start', 'dialog:failed') %]
	if (!lua_run("del_dlg_profile", "$ci"))
	{
		xlog("L_ERROR", "Failed to decrease redis counters - [% logreq -%]\n");
	}
	else
	{
		xlog("L_INFO", "removed redis counters - [% logreq -%]\n");
	}
	#!ifdef ENABLE_PBX
	lua_run("del_dlg_list", "$ci");
	#!endif
	[% debug_dump('end', 'dialog:failed') %]
}
# vim: ft=cfg
